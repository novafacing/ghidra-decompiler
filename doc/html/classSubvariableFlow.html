<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>decompiler: SubvariableFlow Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSubvariableFlow-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SubvariableFlow Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for shrinking big Varnodes carrying smaller logical values.  
 <a href="classSubvariableFlow.html#details">More...</a></p>

<p><code>#include &lt;subflow.hh&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow_1_1PatchRecord.html">PatchRecord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation with a new logical value as (part of) input, but output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is unchanged.  <a href="classSubvariableFlow_1_1PatchRecord.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow_1_1ReplaceOp.html">ReplaceOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder node for <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a> operating on smaller logical values.  <a href="classSubvariableFlow_1_1ReplaceOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder node for <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> holding a smaller logical value.  <a href="classSubvariableFlow_1_1ReplaceVarnode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a64ea117213dcf604786d194e90806480"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a64ea117213dcf604786d194e90806480">SubvariableFlow</a> (<a class="el" href="classFuncdata.html">Funcdata</a> *f, <a class="el" href="classVarnode.html">Varnode</a> *root, uintb mask, bool aggr, bool sext, bool big)</td></tr>
<tr class="memdesc:a64ea117213dcf604786d194e90806480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classSubvariableFlow.html#a64ea117213dcf604786d194e90806480">More...</a><br /></td></tr>
<tr class="separator:a64ea117213dcf604786d194e90806480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b6ba93a3249ba31526a01198111496"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#ad6b6ba93a3249ba31526a01198111496">doTrace</a> (void)</td></tr>
<tr class="memdesc:ad6b6ba93a3249ba31526a01198111496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace logical value through data-flow, constructing transform.  <a href="classSubvariableFlow.html#ad6b6ba93a3249ba31526a01198111496">More...</a><br /></td></tr>
<tr class="separator:ad6b6ba93a3249ba31526a01198111496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75dd5e28aa46641f1561b1c51f0876c1"><td class="memItemLeft" align="right" valign="top"><a id="a75dd5e28aa46641f1561b1c51f0876c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a75dd5e28aa46641f1561b1c51f0876c1">doReplacement</a> (void)</td></tr>
<tr class="memdesc:a75dd5e28aa46641f1561b1c51f0876c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the discovered transform, making logical values explicit. <br /></td></tr>
<tr class="separator:a75dd5e28aa46641f1561b1c51f0876c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8dd69a2e2a4ed1313914bbc8dcf40e3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a8dd69a2e2a4ed1313914bbc8dcf40e3e">getReplacementAddress</a> (<a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn) const</td></tr>
<tr class="memdesc:a8dd69a2e2a4ed1313914bbc8dcf40e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculcate address of replacement <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> for given subgraph variable node.  <a href="classSubvariableFlow.html#a8dd69a2e2a4ed1313914bbc8dcf40e3e">More...</a><br /></td></tr>
<tr class="separator:a8dd69a2e2a4ed1313914bbc8dcf40e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c0bdac6dfac824759dba300c06dc62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#ab8c0bdac6dfac824759dba300c06dc62">setReplacement</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, uintb mask, bool &amp;inworklist)</td></tr>
<tr class="memdesc:ab8c0bdac6dfac824759dba300c06dc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> as a new node in the logical subgraph.  <a href="classSubvariableFlow.html#ab8c0bdac6dfac824759dba300c06dc62">More...</a><br /></td></tr>
<tr class="separator:ab8c0bdac6dfac824759dba300c06dc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de777c3aa9ee9bcd1a170e5fae7d05f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubvariableFlow_1_1ReplaceOp.html">ReplaceOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a2de777c3aa9ee9bcd1a170e5fae7d05f">createOp</a> (<a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> opc, int4 numparam, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *outrvn)</td></tr>
<tr class="memdesc:a2de777c3aa9ee9bcd1a170e5fae7d05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a logical subgraph operator node given its output variable node.  <a href="classSubvariableFlow.html#a2de777c3aa9ee9bcd1a170e5fae7d05f">More...</a><br /></td></tr>
<tr class="separator:a2de777c3aa9ee9bcd1a170e5fae7d05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49b0d75a96ac7875cc9a4538fc4d943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubvariableFlow_1_1ReplaceOp.html">ReplaceOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#ad49b0d75a96ac7875cc9a4538fc4d943">createOpDown</a> (<a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> opc, int4 numparam, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *inrvn, int4 slot)</td></tr>
<tr class="memdesc:ad49b0d75a96ac7875cc9a4538fc4d943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a logical subgraph operator node given one of its input variable nodes.  <a href="classSubvariableFlow.html#ad49b0d75a96ac7875cc9a4538fc4d943">More...</a><br /></td></tr>
<tr class="separator:ad49b0d75a96ac7875cc9a4538fc4d943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63eb516c7ab571aadb912c35c5b6bea8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a63eb516c7ab571aadb912c35c5b6bea8">tryCallPull</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn, int4 slot)</td></tr>
<tr class="memdesc:a63eb516c7ab571aadb912c35c5b6bea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the given subgraph variable can act as a parameter to the given CALL op.  <a href="classSubvariableFlow.html#a63eb516c7ab571aadb912c35c5b6bea8">More...</a><br /></td></tr>
<tr class="separator:a63eb516c7ab571aadb912c35c5b6bea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550879200c908733016f9537c4bf3c48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a550879200c908733016f9537c4bf3c48">tryReturnPull</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn, int4 slot)</td></tr>
<tr class="memdesc:a550879200c908733016f9537c4bf3c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the given subgraph variable can act as return value for the given RETURN op.  <a href="classSubvariableFlow.html#a550879200c908733016f9537c4bf3c48">More...</a><br /></td></tr>
<tr class="separator:a550879200c908733016f9537c4bf3c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575b1e0006753064afb611fb07955432"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a575b1e0006753064afb611fb07955432">tryCallReturnPush</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn)</td></tr>
<tr class="memdesc:a575b1e0006753064afb611fb07955432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the given subgraph variable can act as a <em>created</em> value for the given INDIRECT op.  <a href="classSubvariableFlow.html#a575b1e0006753064afb611fb07955432">More...</a><br /></td></tr>
<tr class="separator:a575b1e0006753064afb611fb07955432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58422de83336c092c19ff94a44e3cf26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a58422de83336c092c19ff94a44e3cf26">trySwitchPull</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn)</td></tr>
<tr class="memdesc:a58422de83336c092c19ff94a44e3cf26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the subgraph variable can act as a switch variable for the given BRANCHIND.  <a href="classSubvariableFlow.html#a58422de83336c092c19ff94a44e3cf26">More...</a><br /></td></tr>
<tr class="separator:a58422de83336c092c19ff94a44e3cf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dec9be4f0c0467e3df5a0d9c4434392"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a3dec9be4f0c0467e3df5a0d9c4434392">traceForward</a> (<a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn)</td></tr>
<tr class="memdesc:a3dec9be4f0c0467e3df5a0d9c4434392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace the logical data-flow forward for the given subgraph variable.  <a href="classSubvariableFlow.html#a3dec9be4f0c0467e3df5a0d9c4434392">More...</a><br /></td></tr>
<tr class="separator:a3dec9be4f0c0467e3df5a0d9c4434392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4ceb7c191460b4bbc54932ce79bf54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a3e4ceb7c191460b4bbc54932ce79bf54">traceBackward</a> (<a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn)</td></tr>
<tr class="memdesc:a3e4ceb7c191460b4bbc54932ce79bf54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace the logical data-flow backward for the given subgraph variable.  <a href="classSubvariableFlow.html#a3e4ceb7c191460b4bbc54932ce79bf54">More...</a><br /></td></tr>
<tr class="separator:a3e4ceb7c191460b4bbc54932ce79bf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23446f878dbf46ac35472c3f14fb10ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a23446f878dbf46ac35472c3f14fb10ff">traceForwardSext</a> (<a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn)</td></tr>
<tr class="memdesc:a23446f878dbf46ac35472c3f14fb10ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace logical data-flow forward assuming sign-extensions.  <a href="classSubvariableFlow.html#a23446f878dbf46ac35472c3f14fb10ff">More...</a><br /></td></tr>
<tr class="separator:a23446f878dbf46ac35472c3f14fb10ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb1b62aee996ef277d511fbbd23c05b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#aacb1b62aee996ef277d511fbbd23c05b">traceBackwardSext</a> (<a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn)</td></tr>
<tr class="memdesc:aacb1b62aee996ef277d511fbbd23c05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace logical data-flow backward assuming sign-extensions.  <a href="classSubvariableFlow.html#aacb1b62aee996ef277d511fbbd23c05b">More...</a><br /></td></tr>
<tr class="separator:aacb1b62aee996ef277d511fbbd23c05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a3ab237f4db9eddb1b4fff510c96a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a66a3ab237f4db9eddb1b4fff510c96a1">createLink</a> (<a class="el" href="classSubvariableFlow_1_1ReplaceOp.html">ReplaceOp</a> *rop, uintb mask, int4 slot, <a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a66a3ab237f4db9eddb1b4fff510c96a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new variable to the logical subgraph as an input to the given operation.  <a href="classSubvariableFlow.html#a66a3ab237f4db9eddb1b4fff510c96a1">More...</a><br /></td></tr>
<tr class="separator:a66a3ab237f4db9eddb1b4fff510c96a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c16f50f66821e5433d63c9ac23907a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a8c16f50f66821e5433d63c9ac23907a3">createCompareBridge</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *inrvn, int4 slot, <a class="el" href="classVarnode.html">Varnode</a> *othervn)</td></tr>
<tr class="memdesc:a8c16f50f66821e5433d63c9ac23907a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend the logical subgraph through a given comparison operator if possible.  <a href="classSubvariableFlow.html#a8c16f50f66821e5433d63c9ac23907a3">More...</a><br /></td></tr>
<tr class="separator:a8c16f50f66821e5433d63c9ac23907a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a953ed2be3b0195775fb3a259f3c259"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a5a953ed2be3b0195775fb3a259f3c259">addPush</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *pushOp, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn)</td></tr>
<tr class="memdesc:a5a953ed2be3b0195775fb3a259f3c259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark an operation where original data-flow is being pushed into a subgraph variable.  <a href="classSubvariableFlow.html#a5a953ed2be3b0195775fb3a259f3c259">More...</a><br /></td></tr>
<tr class="separator:a5a953ed2be3b0195775fb3a259f3c259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1055cd15d23d55e0672d6c6033b99908"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a1055cd15d23d55e0672d6c6033b99908">addTerminalPatch</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *pullop, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn)</td></tr>
<tr class="memdesc:a1055cd15d23d55e0672d6c6033b99908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark an operation where a subgraph variable is naturally copied into the original data-flow.  <a href="classSubvariableFlow.html#a1055cd15d23d55e0672d6c6033b99908">More...</a><br /></td></tr>
<tr class="separator:a1055cd15d23d55e0672d6c6033b99908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afeebdabbaf720633f14f06f7f4de7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a8afeebdabbaf720633f14f06f7f4de7d">addTerminalPatchSameOp</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *pullop, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn, int4 slot)</td></tr>
<tr class="memdesc:a8afeebdabbaf720633f14f06f7f4de7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark an operation where a subgraph variable is naturally pulled into the original data-flow.  <a href="classSubvariableFlow.html#a8afeebdabbaf720633f14f06f7f4de7d">More...</a><br /></td></tr>
<tr class="separator:a8afeebdabbaf720633f14f06f7f4de7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bb4d70077d7a8672030ac9dd6d2c2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a67bb4d70077d7a8672030ac9dd6d2c2c">addBooleanPatch</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *pullop, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn, int4 slot)</td></tr>
<tr class="memdesc:a67bb4d70077d7a8672030ac9dd6d2c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a subgraph bit variable flowing into an operation taking a boolean input.  <a href="classSubvariableFlow.html#a67bb4d70077d7a8672030ac9dd6d2c2c">More...</a><br /></td></tr>
<tr class="separator:a67bb4d70077d7a8672030ac9dd6d2c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672ac552629697cecbe03711945d2e78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a672ac552629697cecbe03711945d2e78">addSuggestedPatch</a> (<a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn, <a class="el" href="classPcodeOp.html">PcodeOp</a> *pushop, int4 sa)</td></tr>
<tr class="memdesc:a672ac552629697cecbe03711945d2e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a subgraph variable flowing to an operation that expands it by padding with zero bits.  <a href="classSubvariableFlow.html#a672ac552629697cecbe03711945d2e78">More...</a><br /></td></tr>
<tr class="separator:a672ac552629697cecbe03711945d2e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00938c49309a50004642d46c701b28c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#ac00938c49309a50004642d46c701b28c">addComparePatch</a> (<a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *in1, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *in2, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:ac00938c49309a50004642d46c701b28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark subgraph variables flowing into a comparison operation.  <a href="classSubvariableFlow.html#ac00938c49309a50004642d46c701b28c">More...</a><br /></td></tr>
<tr class="separator:ac00938c49309a50004642d46c701b28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5362dd3955608e0cb7f64d3d5c1c95d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a5362dd3955608e0cb7f64d3d5c1c95d2">addConstant</a> (<a class="el" href="classSubvariableFlow_1_1ReplaceOp.html">ReplaceOp</a> *rop, uintb mask, uint4 slot, uintb val)</td></tr>
<tr class="memdesc:a5362dd3955608e0cb7f64d3d5c1c95d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constant variable node to the logical subgraph.  <a href="classSubvariableFlow.html#a5362dd3955608e0cb7f64d3d5c1c95d2">More...</a><br /></td></tr>
<tr class="separator:a5362dd3955608e0cb7f64d3d5c1c95d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2093247c8b43e880d990573d05cfa59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#aa2093247c8b43e880d990573d05cfa59">createNewOut</a> (<a class="el" href="classSubvariableFlow_1_1ReplaceOp.html">ReplaceOp</a> *rop, uintb mask)</td></tr>
<tr class="memdesc:aa2093247c8b43e880d990573d05cfa59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new, non-shadowing, subgraph variable node as an operation output.  <a href="classSubvariableFlow.html#aa2093247c8b43e880d990573d05cfa59">More...</a><br /></td></tr>
<tr class="separator:aa2093247c8b43e880d990573d05cfa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8c80032b3fa35e825e18b3d8d98197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a8f8c80032b3fa35e825e18b3d8d98197">replaceInput</a> (<a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn)</td></tr>
<tr class="memdesc:a8f8c80032b3fa35e825e18b3d8d98197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> in the subgraph with a temporary register.  <a href="classSubvariableFlow.html#a8f8c80032b3fa35e825e18b3d8d98197">More...</a><br /></td></tr>
<tr class="separator:a8f8c80032b3fa35e825e18b3d8d98197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6eb4dd6e57b774f3a79ca8c8fceb41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a5c6eb4dd6e57b774f3a79ca8c8fceb41">useSameAddress</a> (<a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn)</td></tr>
<tr class="memdesc:a5c6eb4dd6e57b774f3a79ca8c8fceb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide if we use the same memory range of the original <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> for the logical replacement.  <a href="classSubvariableFlow.html#a5c6eb4dd6e57b774f3a79ca8c8fceb41">More...</a><br /></td></tr>
<tr class="separator:a5c6eb4dd6e57b774f3a79ca8c8fceb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6975acfca24824c2c0ae4f2b6b70dea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a6975acfca24824c2c0ae4f2b6b70dea3">getReplaceVarnode</a> (<a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *rvn)</td></tr>
<tr class="memdesc:a6975acfca24824c2c0ae4f2b6b70dea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the logical <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> which will replace its original containing <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a>.  <a href="classSubvariableFlow.html#a6975acfca24824c2c0ae4f2b6b70dea3">More...</a><br /></td></tr>
<tr class="separator:a6975acfca24824c2c0ae4f2b6b70dea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43e138fb9680fa85394ca16d83c9a18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#aa43e138fb9680fa85394ca16d83c9a18">processNextWork</a> (void)</td></tr>
<tr class="memdesc:aa43e138fb9680fa85394ca16d83c9a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend the subgraph from the next node in the worklist.  <a href="classSubvariableFlow.html#aa43e138fb9680fa85394ca16d83c9a18">More...</a><br /></td></tr>
<tr class="separator:aa43e138fb9680fa85394ca16d83c9a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a39275946de3e6e519e7c6b8a1c2b6428"><td class="memItemLeft" align="right" valign="top">static int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a39275946de3e6e519e7c6b8a1c2b6428">doesOrSet</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *orop, uintb mask)</td></tr>
<tr class="memdesc:a39275946de3e6e519e7c6b8a1c2b6428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <em>slot</em> of constant if INT_OR op sets all bits in mask, otherwise -1.  <a href="classSubvariableFlow.html#a39275946de3e6e519e7c6b8a1c2b6428">More...</a><br /></td></tr>
<tr class="separator:a39275946de3e6e519e7c6b8a1c2b6428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff6e343a0750a70d83657b326eda2ff"><td class="memItemLeft" align="right" valign="top">static int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#afff6e343a0750a70d83657b326eda2ff">doesAndClear</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *andop, uintb mask)</td></tr>
<tr class="memdesc:afff6e343a0750a70d83657b326eda2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <em>slot</em> of constant if INT_AND op clears all bits in mask, otherwise -1.  <a href="classSubvariableFlow.html#afff6e343a0750a70d83657b326eda2ff">More...</a><br /></td></tr>
<tr class="separator:afff6e343a0750a70d83657b326eda2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a1b26e6297105169ea18fd62844d9d0fd"><td class="memItemLeft" align="right" valign="top"><a id="a1b26e6297105169ea18fd62844d9d0fd"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a1b26e6297105169ea18fd62844d9d0fd">flowsize</a></td></tr>
<tr class="memdesc:a1b26e6297105169ea18fd62844d9d0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the logical data-flow in bytes. <br /></td></tr>
<tr class="separator:a1b26e6297105169ea18fd62844d9d0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70070bdaa79b04d9d99bfefac65f5233"><td class="memItemLeft" align="right" valign="top"><a id="a70070bdaa79b04d9d99bfefac65f5233"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a70070bdaa79b04d9d99bfefac65f5233">bitsize</a></td></tr>
<tr class="memdesc:a70070bdaa79b04d9d99bfefac65f5233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits in logical variable. <br /></td></tr>
<tr class="separator:a70070bdaa79b04d9d99bfefac65f5233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3f97ee182f7b9b14179645f1595649"><td class="memItemLeft" align="right" valign="top"><a id="a9f3f97ee182f7b9b14179645f1595649"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a9f3f97ee182f7b9b14179645f1595649">returnsTraversed</a></td></tr>
<tr class="memdesc:a9f3f97ee182f7b9b14179645f1595649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Have we tried to flow logical value across CPUI_RETURNs. <br /></td></tr>
<tr class="separator:a9f3f97ee182f7b9b14179645f1595649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdde71897645f51c6a4aba63b83ab122"><td class="memItemLeft" align="right" valign="top"><a id="afdde71897645f51c6a4aba63b83ab122"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#afdde71897645f51c6a4aba63b83ab122">aggressive</a></td></tr>
<tr class="memdesc:afdde71897645f51c6a4aba63b83ab122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do we "know" initial seed point must be a sub variable. <br /></td></tr>
<tr class="separator:afdde71897645f51c6a4aba63b83ab122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef621e54ef724866d8b65648c9f01d6"><td class="memItemLeft" align="right" valign="top"><a id="a8ef621e54ef724866d8b65648c9f01d6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a8ef621e54ef724866d8b65648c9f01d6">sextrestrictions</a></td></tr>
<tr class="memdesc:a8ef621e54ef724866d8b65648c9f01d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for logical variables that are always sign extended into their container. <br /></td></tr>
<tr class="separator:a8ef621e54ef724866d8b65648c9f01d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4967964b7fe88cfd29b13520c76ed077"><td class="memItemLeft" align="right" valign="top"><a id="a4967964b7fe88cfd29b13520c76ed077"></a>
<a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a4967964b7fe88cfd29b13520c76ed077">fd</a></td></tr>
<tr class="memdesc:a4967964b7fe88cfd29b13520c76ed077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Containing function. <br /></td></tr>
<tr class="separator:a4967964b7fe88cfd29b13520c76ed077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933b0e9f110692081ed8e7a99b5d5955"><td class="memItemLeft" align="right" valign="top"><a id="a933b0e9f110692081ed8e7a99b5d5955"></a>
map&lt; <a class="el" href="classVarnode.html">Varnode</a> *, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a933b0e9f110692081ed8e7a99b5d5955">varmap</a></td></tr>
<tr class="memdesc:a933b0e9f110692081ed8e7a99b5d5955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from original Varnodes to the overlaying subgraph nodes. <br /></td></tr>
<tr class="separator:a933b0e9f110692081ed8e7a99b5d5955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51111c29844fdd06d2e30996632e80d"><td class="memItemLeft" align="right" valign="top"><a id="ae51111c29844fdd06d2e30996632e80d"></a>
list&lt; <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#ae51111c29844fdd06d2e30996632e80d">newvarlist</a></td></tr>
<tr class="memdesc:ae51111c29844fdd06d2e30996632e80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for subgraph variable nodes. <br /></td></tr>
<tr class="separator:ae51111c29844fdd06d2e30996632e80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a84f5274a6346d09f8f17cb860f22d6"><td class="memItemLeft" align="right" valign="top"><a id="a8a84f5274a6346d09f8f17cb860f22d6"></a>
list&lt; <a class="el" href="classSubvariableFlow_1_1ReplaceOp.html">ReplaceOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a8a84f5274a6346d09f8f17cb860f22d6">oplist</a></td></tr>
<tr class="memdesc:a8a84f5274a6346d09f8f17cb860f22d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for subgraph op nodes. <br /></td></tr>
<tr class="separator:a8a84f5274a6346d09f8f17cb860f22d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20eb2c458459b59cab7c5ca821374c7"><td class="memItemLeft" align="right" valign="top"><a id="aa20eb2c458459b59cab7c5ca821374c7"></a>
list&lt; <a class="el" href="classSubvariableFlow_1_1PatchRecord.html">PatchRecord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#aa20eb2c458459b59cab7c5ca821374c7">patchlist</a></td></tr>
<tr class="memdesc:aa20eb2c458459b59cab7c5ca821374c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations getting patched (but with no flow thru) <br /></td></tr>
<tr class="separator:aa20eb2c458459b59cab7c5ca821374c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e9880cefec3f4d280347a51d37e7f9"><td class="memItemLeft" align="right" valign="top"><a id="a80e9880cefec3f4d280347a51d37e7f9"></a>
vector&lt; <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a80e9880cefec3f4d280347a51d37e7f9">worklist</a></td></tr>
<tr class="memdesc:a80e9880cefec3f4d280347a51d37e7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subgraph variable nodes still needing to be traced. <br /></td></tr>
<tr class="separator:a80e9880cefec3f4d280347a51d37e7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a636435e09513d7602228fc4b048245"><td class="memItemLeft" align="right" valign="top"><a id="a2a636435e09513d7602228fc4b048245"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubvariableFlow.html#a2a636435e09513d7602228fc4b048245">pullcount</a></td></tr>
<tr class="memdesc:a2a636435e09513d7602228fc4b048245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of instructions pulling out the logical value. <br /></td></tr>
<tr class="separator:a2a636435e09513d7602228fc4b048245"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for shrinking big Varnodes carrying smaller logical values. </p>
<p>Given a root within the syntax tree and dimensions of a logical variable, this class traces the flow of this logical variable through its containing Varnodes. It then creates a subgraph of this flow, where there is a correspondence between nodes in the subgraph and nodes in the original graph containing the logical variable. When doReplacement is called, this subgraph is duplicated as a new separate piece within the syntax tree. Ops are replaced to reflect the manipulation of of the logical variable, rather than the containing variable. Operations in the original graph which pluck out the logical variable from the containing variable, are replaced with copies from the corresponding node in the new section of the graph, which frequently causes the operations on the original container Varnodes to becomes dead code. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a64ea117213dcf604786d194e90806480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ea117213dcf604786d194e90806480">&#9670;&nbsp;</a></span>SubvariableFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SubvariableFlow::SubvariableFlow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>big</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>is the function to attempt the subvariable transform on </td></tr>
    <tr><td class="paramname">root</td><td>is a starting <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> containing a smaller logical value </td></tr>
    <tr><td class="paramname">mask</td><td>is a mask where 1 bits indicate the position of the logical value within the <em>root</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </td></tr>
    <tr><td class="paramname">aggr</td><td>is <b>true</b> if we should use aggressive (less restrictive) tests during the trace </td></tr>
    <tr><td class="paramname">sext</td><td>is <b>true</b> if we should assume sign extensions from the logical value into its container </td></tr>
    <tr><td class="paramname">big</td><td>is <b>true</b> if we look for subvariable flow for <em>big</em> (8-byte) logical values </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classSubvariableFlow.html#afdde71897645f51c6a4aba63b83ab122">aggressive</a>, <a class="el" href="classSubvariableFlow.html#a70070bdaa79b04d9d99bfefac65f5233">bitsize</a>, <a class="el" href="classSubvariableFlow.html#a66a3ab237f4db9eddb1b4fff510c96a1">createLink()</a>, <a class="el" href="classSubvariableFlow.html#a4967964b7fe88cfd29b13520c76ed077">fd</a>, <a class="el" href="classSubvariableFlow.html#a1b26e6297105169ea18fd62844d9d0fd">flowsize</a>, <a class="el" href="address_8hh.html#ac4d874e14dba4c4dabbbdc0a15653755">leastsigbit_set()</a>, <a class="el" href="address_8hh.html#aa894bdd40ffc8c7a6237e49062c62177">mostsigbit_set()</a>, <a class="el" href="classSubvariableFlow.html#a9f3f97ee182f7b9b14179645f1595649">returnsTraversed</a>, and <a class="el" href="classSubvariableFlow.html#a8ef621e54ef724866d8b65648c9f01d6">sextrestrictions</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a67bb4d70077d7a8672030ac9dd6d2c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67bb4d70077d7a8672030ac9dd6d2c2c">&#9670;&nbsp;</a></span>addBooleanPatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SubvariableFlow::addBooleanPatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>pullop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark a subgraph bit variable flowing into an operation taking a boolean input. </p>
<p>This doesn't count as a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> holding a logical value that needs to be patched (by itself). A <a class="el" href="classSubvariableFlow_1_1PatchRecord.html" title="Operation with a new logical value as (part of) input, but output Varnode is unchanged.">PatchRecord</a> terminating the logical subgraph along the given edge is created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pullop</td><td>is the operation taking the boolean input </td></tr>
    <tr><td class="paramname">rvn</td><td>is the given bit variable </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot of the variable to the operation </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classSubvariableFlow_1_1PatchRecord.html#a36246381da40b955494923b58ee46b2baed4af286797d6341d6d1fb22ef3e2dbf">SubvariableFlow::PatchRecord::parameter_patch</a>, and <a class="el" href="classSubvariableFlow.html#aa20eb2c458459b59cab7c5ca821374c7">patchlist</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a3dec9be4f0c0467e3df5a0d9c4434392">traceForward()</a>.</p>

</div>
</div>
<a id="ac00938c49309a50004642d46c701b28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00938c49309a50004642d46c701b28c">&#9670;&nbsp;</a></span>addComparePatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SubvariableFlow::addComparePatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark subgraph variables flowing into a comparison operation. </p>
<p>The operation accomplishes the logical comparison by comparing the larger containers. A <a class="el" href="classSubvariableFlow_1_1PatchRecord.html" title="Operation with a new logical value as (part of) input, but output Varnode is unchanged.">PatchRecord</a> is created indicating that data-flow from the subgraph terminates at the comparison. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in1</td><td>is the first logical value to the comparison </td></tr>
    <tr><td class="paramname">in2</td><td>is the second logical value </td></tr>
    <tr><td class="paramname">op</td><td>is the comparison operation </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classSubvariableFlow_1_1PatchRecord.html#a36246381da40b955494923b58ee46b2baf96e8db2d6ca23b2d0566b44489e2b06">SubvariableFlow::PatchRecord::compare_patch</a>, <a class="el" href="classSubvariableFlow.html#aa20eb2c458459b59cab7c5ca821374c7">patchlist</a>, and <a class="el" href="classSubvariableFlow.html#a2a636435e09513d7602228fc4b048245">pullcount</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a8c16f50f66821e5433d63c9ac23907a3">createCompareBridge()</a>.</p>

</div>
</div>
<a id="a5362dd3955608e0cb7f64d3d5c1c95d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5362dd3955608e0cb7f64d3d5c1c95d2">&#9670;&nbsp;</a></span>addConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">SubvariableFlow::ReplaceVarnode</a> * SubvariableFlow::addConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceOp.html">ReplaceOp</a> *&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a constant variable node to the logical subgraph. </p>
<p>Unlike other subgraph variable nodes, this one does not maintain a mirror with the original containing <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>is the logical operation taking the constant as input </td></tr>
    <tr><td class="paramname">mask</td><td>is the set of bits holding the logical value (within a bigger value) </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot to the operation </td></tr>
    <tr><td class="paramname">val</td><td>is the bigger constant value holding the logical value </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5fbf3fb8e68fa3b0244adcccd49afd32">SubvariableFlow::ReplaceVarnode::def</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceOp.html#a443751debe8b031ff5038b6f2f7f9444">SubvariableFlow::ReplaceOp::input</a>, <a class="el" href="address_8hh.html#ac4d874e14dba4c4dabbbdc0a15653755">leastsigbit_set()</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5623c2ae905db06b3df24fa041ce111b">SubvariableFlow::ReplaceVarnode::mask</a>, <a class="el" href="classSubvariableFlow.html#ae51111c29844fdd06d2e30996632e80d">newvarlist</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a988f87113a6d09f1ebfc5228993853d6">SubvariableFlow::ReplaceVarnode::replacement</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5b3c1161d649496ae4d30af2512fa288">SubvariableFlow::ReplaceVarnode::val</a>, and <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a6c9a7b3ea519d06f2236a89928d2c3fd">SubvariableFlow::ReplaceVarnode::vn</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#ab8c0bdac6dfac824759dba300c06dc62">setReplacement()</a>, <a class="el" href="classSubvariableFlow.html#a3e4ceb7c191460b4bbc54932ce79bf54">traceBackward()</a>, <a class="el" href="classSubvariableFlow.html#aacb1b62aee996ef277d511fbbd23c05b">traceBackwardSext()</a>, and <a class="el" href="classSubvariableFlow.html#a23446f878dbf46ac35472c3f14fb10ff">traceForwardSext()</a>.</p>

</div>
</div>
<a id="a5a953ed2be3b0195775fb3a259f3c259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a953ed2be3b0195775fb3a259f3c259">&#9670;&nbsp;</a></span>addPush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SubvariableFlow::addPush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>pushOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark an operation where original data-flow is being pushed into a subgraph variable. </p>
<p>The operation is not manipulating the logical value, but it produces a variable containing the logical value. The original op will not change but will just produce a smaller value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pushOp</td><td>is the operation to mark </td></tr>
    <tr><td class="paramname">rvn</td><td>is the output variable holding the logical value </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classSubvariableFlow.html#aa20eb2c458459b59cab7c5ca821374c7">patchlist</a>, and <a class="el" href="classSubvariableFlow_1_1PatchRecord.html#a36246381da40b955494923b58ee46b2ba22e4ad863bb439a547bff85289db2426">SubvariableFlow::PatchRecord::push_patch</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a3e4ceb7c191460b4bbc54932ce79bf54">traceBackward()</a>, <a class="el" href="classSubvariableFlow.html#aacb1b62aee996ef277d511fbbd23c05b">traceBackwardSext()</a>, and <a class="el" href="classSubvariableFlow.html#a575b1e0006753064afb611fb07955432">tryCallReturnPush()</a>.</p>

</div>
</div>
<a id="a672ac552629697cecbe03711945d2e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672ac552629697cecbe03711945d2e78">&#9670;&nbsp;</a></span>addSuggestedPatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SubvariableFlow::addSuggestedPatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>pushop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark a subgraph variable flowing to an operation that expands it by padding with zero bits. </p>
<p>Data-flow along the specified edge within the logical subgraph is terminated by added a <a class="el" href="classSubvariableFlow_1_1PatchRecord.html" title="Operation with a new logical value as (part of) input, but output Varnode is unchanged.">PatchRecord</a>. This doesn't count as a logical value that needs to be patched (by itself). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rvn</td><td>is the given subgraph variable </td></tr>
    <tr><td class="paramname">pushop</td><td>is the operation that pads the variable </td></tr>
    <tr><td class="paramname">sa</td><td>is the amount the logical value is shifted to the left </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classSubvariableFlow_1_1PatchRecord.html#a36246381da40b955494923b58ee46b2bae36dc3d86be135a72c488815bd5bdc42">SubvariableFlow::PatchRecord::extension_patch</a>, <a class="el" href="address_8hh.html#ac4d874e14dba4c4dabbbdc0a15653755">leastsigbit_set()</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5623c2ae905db06b3df24fa041ce111b">SubvariableFlow::ReplaceVarnode::mask</a>, and <a class="el" href="classSubvariableFlow.html#aa20eb2c458459b59cab7c5ca821374c7">patchlist</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a3dec9be4f0c0467e3df5a0d9c4434392">traceForward()</a>.</p>

</div>
</div>
<a id="a1055cd15d23d55e0672d6c6033b99908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1055cd15d23d55e0672d6c6033b99908">&#9670;&nbsp;</a></span>addTerminalPatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SubvariableFlow::addTerminalPatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>pullop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark an operation where a subgraph variable is naturally copied into the original data-flow. </p>
<p>If the operations naturally takes the given logical value as input but the output doesn't need to be traced as a logical value, a subgraph terminator (<a class="el" href="classSubvariableFlow_1_1PatchRecord.html" title="Operation with a new logical value as (part of) input, but output Varnode is unchanged.">PatchRecord</a>) is created noting this. The original <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a> will be converted to a COPY. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pullop</td><td>is the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a> pulling the logical value out of the subgraph </td></tr>
    <tr><td class="paramname">rvn</td><td>is the given subgraph variable holding the logical value </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classSubvariableFlow_1_1PatchRecord.html#a36246381da40b955494923b58ee46b2badc2d4736e9aad6837b9c53654108e282">SubvariableFlow::PatchRecord::copy_patch</a>, <a class="el" href="classSubvariableFlow.html#aa20eb2c458459b59cab7c5ca821374c7">patchlist</a>, and <a class="el" href="classSubvariableFlow.html#a2a636435e09513d7602228fc4b048245">pullcount</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a3dec9be4f0c0467e3df5a0d9c4434392">traceForward()</a>, and <a class="el" href="classSubvariableFlow.html#a23446f878dbf46ac35472c3f14fb10ff">traceForwardSext()</a>.</p>

</div>
</div>
<a id="a8afeebdabbaf720633f14f06f7f4de7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afeebdabbaf720633f14f06f7f4de7d">&#9670;&nbsp;</a></span>addTerminalPatchSameOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SubvariableFlow::addTerminalPatchSameOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>pullop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark an operation where a subgraph variable is naturally pulled into the original data-flow. </p>
<p>If the operations naturally takes the given logical value as input but the output doesn't need to be traced as a logical value, a subgraph terminator (<a class="el" href="classSubvariableFlow_1_1PatchRecord.html" title="Operation with a new logical value as (part of) input, but output Varnode is unchanged.">PatchRecord</a>) is created noting this. The opcode of the operation will not change. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pullop</td><td>is the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a> pulling the logical value out of the subgraph </td></tr>
    <tr><td class="paramname">rvn</td><td>is the given subgraph variable holding the logical value </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot to the operation </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classSubvariableFlow_1_1PatchRecord.html#a36246381da40b955494923b58ee46b2baed4af286797d6341d6d1fb22ef3e2dbf">SubvariableFlow::PatchRecord::parameter_patch</a>, <a class="el" href="classSubvariableFlow.html#aa20eb2c458459b59cab7c5ca821374c7">patchlist</a>, and <a class="el" href="classSubvariableFlow.html#a2a636435e09513d7602228fc4b048245">pullcount</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a3dec9be4f0c0467e3df5a0d9c4434392">traceForward()</a>, and <a class="el" href="classSubvariableFlow.html#a23446f878dbf46ac35472c3f14fb10ff">traceForwardSext()</a>.</p>

</div>
</div>
<a id="a8c16f50f66821e5433d63c9ac23907a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c16f50f66821e5433d63c9ac23907a3">&#9670;&nbsp;</a></span>createCompareBridge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SubvariableFlow::createCompareBridge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>inrvn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>othervn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend the logical subgraph through a given comparison operator if possible. </p>
<p>Given the variable already in the subgraph that is compared and the other side of the comparison, add the other side as a logical value to the subgraph and create a <a class="el" href="classSubvariableFlow_1_1PatchRecord.html" title="Operation with a new logical value as (part of) input, but output Varnode is unchanged.">PatchRecord</a> for the comparison operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given comparison operation </td></tr>
    <tr><td class="paramname">inrvn</td><td>is the variable already in the logical subgraph </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot to the comparison of the variable already in the subgraph </td></tr>
    <tr><td class="paramname">othervn</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> holding the other side of the comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the logical subgraph can successfully be extended through the comparison </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow.html#ac00938c49309a50004642d46c701b28c">addComparePatch()</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5623c2ae905db06b3df24fa041ce111b">SubvariableFlow::ReplaceVarnode::mask</a>, <a class="el" href="classSubvariableFlow.html#ab8c0bdac6dfac824759dba300c06dc62">setReplacement()</a>, and <a class="el" href="classSubvariableFlow.html#a80e9880cefec3f4d280347a51d37e7f9">worklist</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a3dec9be4f0c0467e3df5a0d9c4434392">traceForward()</a>, and <a class="el" href="classSubvariableFlow.html#a23446f878dbf46ac35472c3f14fb10ff">traceForwardSext()</a>.</p>

</div>
</div>
<a id="a66a3ab237f4db9eddb1b4fff510c96a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a3ab237f4db9eddb1b4fff510c96a1">&#9670;&nbsp;</a></span>createLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SubvariableFlow::createLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceOp.html">ReplaceOp</a> *&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new variable to the logical subgraph as an input to the given operation. </p>
<p>The subgraph is extended by the specified input edge, and a new variable node is created if necessary or a preexisting node corresponding to the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is used. If the logical value described by the given mask cannot be made to line up with the subgraph variable node, <b>false</b> is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>is the given operation </td></tr>
    <tr><td class="paramname">mask</td><td>is the mask describing the logical value within the input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> to the operation </td></tr>
    <tr><td class="paramname">vn</td><td>is the original input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> holding the logical value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> is the subgraph is successfully extended to the input </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5fbf3fb8e68fa3b0244adcccd49afd32">SubvariableFlow::ReplaceVarnode::def</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceOp.html#a443751debe8b031ff5038b6f2f7f9444">SubvariableFlow::ReplaceOp::input</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceOp.html#a30caa45603a7ce1b61d9e5706807ff6e">SubvariableFlow::ReplaceOp::output</a>, <a class="el" href="classSubvariableFlow.html#ab8c0bdac6dfac824759dba300c06dc62">setReplacement()</a>, and <a class="el" href="classSubvariableFlow.html#a80e9880cefec3f4d280347a51d37e7f9">worklist</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a64ea117213dcf604786d194e90806480">SubvariableFlow()</a>, <a class="el" href="classSubvariableFlow.html#a3e4ceb7c191460b4bbc54932ce79bf54">traceBackward()</a>, <a class="el" href="classSubvariableFlow.html#aacb1b62aee996ef277d511fbbd23c05b">traceBackwardSext()</a>, <a class="el" href="classSubvariableFlow.html#a3dec9be4f0c0467e3df5a0d9c4434392">traceForward()</a>, and <a class="el" href="classSubvariableFlow.html#a23446f878dbf46ac35472c3f14fb10ff">traceForwardSext()</a>.</p>

</div>
</div>
<a id="aa2093247c8b43e880d990573d05cfa59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2093247c8b43e880d990573d05cfa59">&#9670;&nbsp;</a></span>createNewOut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SubvariableFlow::createNewOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceOp.html">ReplaceOp</a> *&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new, non-shadowing, subgraph variable node as an operation output. </p>
<p>The new node does not shadow a preexisting <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a>. Because the <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html" title="Placeholder node for Varnode holding a smaller logical value.">ReplaceVarnode</a> record is defined by rop (the -def- field is filled in) this can still be distinguished from a constant. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>is the logical operation taking the new output </td></tr>
    <tr><td class="paramname">mask</td><td>describes the logical value </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5fbf3fb8e68fa3b0244adcccd49afd32">SubvariableFlow::ReplaceVarnode::def</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5623c2ae905db06b3df24fa041ce111b">SubvariableFlow::ReplaceVarnode::mask</a>, <a class="el" href="classSubvariableFlow.html#ae51111c29844fdd06d2e30996632e80d">newvarlist</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceOp.html#a30caa45603a7ce1b61d9e5706807ff6e">SubvariableFlow::ReplaceOp::output</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a988f87113a6d09f1ebfc5228993853d6">SubvariableFlow::ReplaceVarnode::replacement</a>, and <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a6c9a7b3ea519d06f2236a89928d2c3fd">SubvariableFlow::ReplaceVarnode::vn</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a3dec9be4f0c0467e3df5a0d9c4434392">traceForward()</a>.</p>

</div>
</div>
<a id="a2de777c3aa9ee9bcd1a170e5fae7d05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de777c3aa9ee9bcd1a170e5fae7d05f">&#9670;&nbsp;</a></span>createOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSubvariableFlow_1_1ReplaceOp.html">SubvariableFlow::ReplaceOp</a> * SubvariableFlow::createOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td>
          <td class="paramname"><em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>numparam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>outrvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a logical subgraph operator node given its output variable node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opc</td><td>is the opcode of the new logical operator </td></tr>
    <tr><td class="paramname">numparam</td><td>is the number of parameters in the new operator </td></tr>
    <tr><td class="paramname">outrvn</td><td>is the given output variable node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new logical subgraph operator object </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5fbf3fb8e68fa3b0244adcccd49afd32">SubvariableFlow::ReplaceVarnode::def</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceOp.html#ad612d74b19ea7890d1b47c034a1ef161">SubvariableFlow::ReplaceOp::numparams</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceOp.html#ad65050e3083bec747cef322650f525fc">SubvariableFlow::ReplaceOp::op</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceOp.html#a87ddef8d635b777077b7931cab5a0d9b">SubvariableFlow::ReplaceOp::opc</a>, <a class="el" href="classSubvariableFlow.html#a8a84f5274a6346d09f8f17cb860f22d6">oplist</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceOp.html#a30caa45603a7ce1b61d9e5706807ff6e">SubvariableFlow::ReplaceOp::output</a>, and <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a6c9a7b3ea519d06f2236a89928d2c3fd">SubvariableFlow::ReplaceVarnode::vn</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a3e4ceb7c191460b4bbc54932ce79bf54">traceBackward()</a>, and <a class="el" href="classSubvariableFlow.html#aacb1b62aee996ef277d511fbbd23c05b">traceBackwardSext()</a>.</p>

</div>
</div>
<a id="ad49b0d75a96ac7875cc9a4538fc4d943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49b0d75a96ac7875cc9a4538fc4d943">&#9670;&nbsp;</a></span>createOpDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSubvariableFlow_1_1ReplaceOp.html">SubvariableFlow::ReplaceOp</a> * SubvariableFlow::createOpDown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td>
          <td class="paramname"><em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>numparam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>inrvn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a logical subgraph operator node given one of its input variable nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opc</td><td>is the opcode of the new logical operator </td></tr>
    <tr><td class="paramname">numparam</td><td>is the number of parameters in the new operator </td></tr>
    <tr><td class="paramname">op</td><td>is the original <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a> being replaced </td></tr>
    <tr><td class="paramname">inrvn</td><td>is the given input variable node </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot of the variable node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new logical subgraph operator objects </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow_1_1ReplaceOp.html#a443751debe8b031ff5038b6f2f7f9444">SubvariableFlow::ReplaceOp::input</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceOp.html#ad612d74b19ea7890d1b47c034a1ef161">SubvariableFlow::ReplaceOp::numparams</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceOp.html#ad65050e3083bec747cef322650f525fc">SubvariableFlow::ReplaceOp::op</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceOp.html#a87ddef8d635b777077b7931cab5a0d9b">SubvariableFlow::ReplaceOp::opc</a>, <a class="el" href="classSubvariableFlow.html#a8a84f5274a6346d09f8f17cb860f22d6">oplist</a>, and <a class="el" href="classSubvariableFlow_1_1ReplaceOp.html#a30caa45603a7ce1b61d9e5706807ff6e">SubvariableFlow::ReplaceOp::output</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a3dec9be4f0c0467e3df5a0d9c4434392">traceForward()</a>, and <a class="el" href="classSubvariableFlow.html#a23446f878dbf46ac35472c3f14fb10ff">traceForwardSext()</a>.</p>

</div>
</div>
<a id="afff6e343a0750a70d83657b326eda2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff6e343a0750a70d83657b326eda2ff">&#9670;&nbsp;</a></span>doesAndClear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 SubvariableFlow::doesAndClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>andop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <em>slot</em> of constant if INT_AND op clears all bits in mask, otherwise -1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">andop</td><td>is the given CPUI_INT_AND op </td></tr>
    <tr><td class="paramname">mask</td><td>is the given mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constant slot or -1 </dd></dl>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a3e4ceb7c191460b4bbc54932ce79bf54">traceBackward()</a>, and <a class="el" href="classSubvariableFlow.html#a3dec9be4f0c0467e3df5a0d9c4434392">traceForward()</a>.</p>

</div>
</div>
<a id="a39275946de3e6e519e7c6b8a1c2b6428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39275946de3e6e519e7c6b8a1c2b6428">&#9670;&nbsp;</a></span>doesOrSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 SubvariableFlow::doesOrSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>orop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <em>slot</em> of constant if INT_OR op sets all bits in mask, otherwise -1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orop</td><td>is the given CPUI_INT_OR op </td></tr>
    <tr><td class="paramname">mask</td><td>is the given mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constant slot or -1 </dd></dl>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a3e4ceb7c191460b4bbc54932ce79bf54">traceBackward()</a>, and <a class="el" href="classSubvariableFlow.html#a3dec9be4f0c0467e3df5a0d9c4434392">traceForward()</a>.</p>

</div>
</div>
<a id="ad6b6ba93a3249ba31526a01198111496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b6ba93a3249ba31526a01198111496">&#9670;&nbsp;</a></span>doTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SubvariableFlow::doTrace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trace logical value through data-flow, constructing transform. </p>
<p>Push the logical value around, setting up explicit transforms as we go that convert them into explicit Varnodes. If at any point, we cannot naturally interpret the flow of the logical value, return <b>false</b>. </p><dl class="section return"><dt>Returns</dt><dd><b>true</b> if a full transform has been constructed that can make logical values into explicit Varnodes </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow.html#a4967964b7fe88cfd29b13520c76ed077">fd</a>, <a class="el" href="classSubvariableFlow.html#aa43e138fb9680fa85394ca16d83c9a18">processNextWork()</a>, <a class="el" href="classSubvariableFlow.html#a2a636435e09513d7602228fc4b048245">pullcount</a>, <a class="el" href="classSubvariableFlow.html#a933b0e9f110692081ed8e7a99b5d5955">varmap</a>, and <a class="el" href="classSubvariableFlow.html#a80e9880cefec3f4d280347a51d37e7f9">worklist</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRuleSubvarAnd.html#a8537105bf8b9f97d9d312e84b7f2b39b">RuleSubvarAnd::applyOp()</a>, <a class="el" href="classRuleSubvarSubpiece.html#aa55e18a43a85344e1e29c985d707a393">RuleSubvarSubpiece::applyOp()</a>, <a class="el" href="classRuleSubvarCompZero.html#a4875048b2b35720b88c6dd2667c4164b">RuleSubvarCompZero::applyOp()</a>, <a class="el" href="classRuleSubvarShift.html#abfeba5a6e02b0d29a5cf98f34d3c3220">RuleSubvarShift::applyOp()</a>, <a class="el" href="classRuleSubvarZext.html#a9336da44138d6e55d5702de806649402">RuleSubvarZext::applyOp()</a>, and <a class="el" href="classRuleSubvarSext.html#a77ff5f0a097fc96ad1a34fea4eae3821">RuleSubvarSext::applyOp()</a>.</p>

</div>
</div>
<a id="a8dd69a2e2a4ed1313914bbc8dcf40e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd69a2e2a4ed1313914bbc8dcf40e3e">&#9670;&nbsp;</a></span>getReplacementAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddress.html">Address</a> SubvariableFlow::getReplacementAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculcate address of replacement <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> for given subgraph variable node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rvn</td><td>is the given subgraph variable node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the new logical <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow.html#a1b26e6297105169ea18fd62844d9d0fd">flowsize</a>, <a class="el" href="classAddress.html#aec0c5e9a64d45b7e913e61eb064bcc2d">Address::isBigEndian()</a>, <a class="el" href="address_8hh.html#ac4d874e14dba4c4dabbbdc0a15653755">leastsigbit_set()</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5623c2ae905db06b3df24fa041ce111b">SubvariableFlow::ReplaceVarnode::mask</a>, <a class="el" href="classAddress.html#a079f391c59a43a0e0fb8a5c66eaf6f64">Address::renormalize()</a>, and <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a6c9a7b3ea519d06f2236a89928d2c3fd">SubvariableFlow::ReplaceVarnode::vn</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a6975acfca24824c2c0ae4f2b6b70dea3">getReplaceVarnode()</a>.</p>

</div>
</div>
<a id="a6975acfca24824c2c0ae4f2b6b70dea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6975acfca24824c2c0ae4f2b6b70dea3">&#9670;&nbsp;</a></span>getReplaceVarnode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * SubvariableFlow::getReplaceVarnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the logical <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> which will replace its original containing <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a>. </p>
<p>This is the main routine for converting a logical variable in the subgraph into an actual <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rvn</td><td>is the logical variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (new or existing) <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> object </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5fbf3fb8e68fa3b0244adcccd49afd32">SubvariableFlow::ReplaceVarnode::def</a>, <a class="el" href="classSubvariableFlow.html#a4967964b7fe88cfd29b13520c76ed077">fd</a>, <a class="el" href="classSubvariableFlow.html#a1b26e6297105169ea18fd62844d9d0fd">flowsize</a>, <a class="el" href="classSubvariableFlow.html#a8dd69a2e2a4ed1313914bbc8dcf40e3e">getReplacementAddress()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncdata.html#a731f6fd415269577b7bb1943315b8a76">Funcdata::newUnique()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">Funcdata::newVarnode()</a>, <a class="el" href="classSubvariableFlow.html#a8f8c80032b3fa35e825e18b3d8d98197">replaceInput()</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a988f87113a6d09f1ebfc5228993853d6">SubvariableFlow::ReplaceVarnode::replacement</a>, <a class="el" href="classFuncdata.html#a84a9880613a03f3aea65acf3dd1343d6">Funcdata::setInputVarnode()</a>, <a class="el" href="classSubvariableFlow.html#a5c6eb4dd6e57b774f3a79ca8c8fceb41">useSameAddress()</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5b3c1161d649496ae4d30af2512fa288">SubvariableFlow::ReplaceVarnode::val</a>, and <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a6c9a7b3ea519d06f2236a89928d2c3fd">SubvariableFlow::ReplaceVarnode::vn</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a75dd5e28aa46641f1561b1c51f0876c1">doReplacement()</a>.</p>

</div>
</div>
<a id="aa43e138fb9680fa85394ca16d83c9a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43e138fb9680fa85394ca16d83c9a18">&#9670;&nbsp;</a></span>processNextWork()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SubvariableFlow::processNextWork </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend the subgraph from the next node in the worklist. </p>
<p>The subgraph is extended from the variable node at the top of the worklist. Data-flow is traced forward and backward one level, possibly extending the subgraph and adding new nodes to the worklist. </p><dl class="section return"><dt>Returns</dt><dd><b>true</b> if the node was successfully processed </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow.html#a8ef621e54ef724866d8b65648c9f01d6">sextrestrictions</a>, <a class="el" href="classSubvariableFlow.html#a3e4ceb7c191460b4bbc54932ce79bf54">traceBackward()</a>, <a class="el" href="classSubvariableFlow.html#aacb1b62aee996ef277d511fbbd23c05b">traceBackwardSext()</a>, <a class="el" href="classSubvariableFlow.html#a3dec9be4f0c0467e3df5a0d9c4434392">traceForward()</a>, <a class="el" href="classSubvariableFlow.html#a23446f878dbf46ac35472c3f14fb10ff">traceForwardSext()</a>, and <a class="el" href="classSubvariableFlow.html#a80e9880cefec3f4d280347a51d37e7f9">worklist</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#ad6b6ba93a3249ba31526a01198111496">doTrace()</a>.</p>

</div>
</div>
<a id="a8f8c80032b3fa35e825e18b3d8d98197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8c80032b3fa35e825e18b3d8d98197">&#9670;&nbsp;</a></span>replaceInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SubvariableFlow::replaceInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace an input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> in the subgraph with a temporary register. </p>
<p>This is used to avoid overlapping input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> errors. The temporary register is typically short lived and gets quickly eliminated in favor of the new logically sized <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rvn</td><td>is the logical variable to replace </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classSubvariableFlow.html#a4967964b7fe88cfd29b13520c76ed077">fd</a>, <a class="el" href="classFuncdata.html#a731f6fd415269577b7bb1943315b8a76">Funcdata::newUnique()</a>, <a class="el" href="classFuncdata.html#a84a9880613a03f3aea65acf3dd1343d6">Funcdata::setInputVarnode()</a>, <a class="el" href="classFuncdata.html#aab7f940f85609d395283520eca3a71f0">Funcdata::totalReplace()</a>, and <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a6c9a7b3ea519d06f2236a89928d2c3fd">SubvariableFlow::ReplaceVarnode::vn</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a6975acfca24824c2c0ae4f2b6b70dea3">getReplaceVarnode()</a>.</p>

</div>
</div>
<a id="ab8c0bdac6dfac824759dba300c06dc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c0bdac6dfac824759dba300c06dc62">&#9670;&nbsp;</a></span>setReplacement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">SubvariableFlow::ReplaceVarnode</a> * SubvariableFlow::setReplacement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>inworklist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> as a new node in the logical subgraph. </p>
<p>A new <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html" title="Placeholder node for Varnode holding a smaller logical value.">ReplaceVarnode</a> object is created, representing the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> within the logical subgraph, and returned. If an object representing the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> already exists it is returned. A mask describing the subset of bits within the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> representing the logical value is also passed in. This method also determines if the new node needs to be added to the worklist for continued tracing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> holding the logical value </td></tr>
    <tr><td class="paramname">mask</td><td>is the given mask describing the bits of the logical value </td></tr>
    <tr><td class="paramname">inworklist</td><td>will hold <b>true</b> if the new node should be traced further </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new subgraph variable node </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow.html#a5362dd3955608e0cb7f64d3d5c1c95d2">addConstant()</a>, <a class="el" href="classSubvariableFlow.html#afdde71897645f51c6a4aba63b83ab122">aggressive</a>, <a class="el" href="classSubvariableFlow.html#a70070bdaa79b04d9d99bfefac65f5233">bitsize</a>, <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5fbf3fb8e68fa3b0244adcccd49afd32">SubvariableFlow::ReplaceVarnode::def</a>, <a class="el" href="classSubvariableFlow.html#a1b26e6297105169ea18fd62844d9d0fd">flowsize</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5623c2ae905db06b3df24fa041ce111b">SubvariableFlow::ReplaceVarnode::mask</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a988f87113a6d09f1ebfc5228993853d6">SubvariableFlow::ReplaceVarnode::replacement</a>, <a class="el" href="classSubvariableFlow.html#a8ef621e54ef724866d8b65648c9f01d6">sextrestrictions</a>, <a class="el" href="address_8hh.html#a6f16b447a8d8851178b1f0709c14bde6">sign_extend()</a>, <a class="el" href="classSubvariableFlow.html#a933b0e9f110692081ed8e7a99b5d5955">varmap</a>, and <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a6c9a7b3ea519d06f2236a89928d2c3fd">SubvariableFlow::ReplaceVarnode::vn</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a8c16f50f66821e5433d63c9ac23907a3">createCompareBridge()</a>, <a class="el" href="classSubvariableFlow.html#a66a3ab237f4db9eddb1b4fff510c96a1">createLink()</a>, and <a class="el" href="classSubvariableFlow.html#a550879200c908733016f9537c4bf3c48">tryReturnPull()</a>.</p>

</div>
</div>
<a id="a3e4ceb7c191460b4bbc54932ce79bf54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4ceb7c191460b4bbc54932ce79bf54">&#9670;&nbsp;</a></span>traceBackward()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SubvariableFlow::traceBackward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trace the logical data-flow backward for the given subgraph variable. </p>
<p>Trace the logical value backward through one <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a> adding new nodes to the logical subgraph and updating the worklist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rvn</td><td>is the given logical value to trace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the logical value can be traced backward one level </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow.html#a5362dd3955608e0cb7f64d3d5c1c95d2">addConstant()</a>, <a class="el" href="classSubvariableFlow.html#a5a953ed2be3b0195775fb3a259f3c259">addPush()</a>, <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a40c57f047989281be90f40d4acc83d66">CPUI_BOOL_AND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a837d13895aa43a15cfc0ab7274237080">CPUI_BOOL_NEGATE</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a54a6e76c456fb2f580b2118f20be407e">CPUI_BOOL_OR</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a5b643eae5eb11ed82a24824f0f95cbda">CPUI_BOOL_XOR</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a50235a7bf50bada36dff73ff740c34d0">CPUI_CALL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a500b63ecb17a75652c705bfab98bc8e5">CPUI_CALLIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a07754146f173d59512a1d2df0c5afe0c">CPUI_FLOAT_EQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ac8b1ba1ca38b32b57eb8939c9d9d087f">CPUI_FLOAT_LESSEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2832ab38c22a958068640d83314b7aa6">CPUI_FLOAT_NAN</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2cba42d99e353c916ce2e8ec2f094a40">CPUI_FLOAT_NOTEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ae3942b7ee09733bcf388c575eb4b60cc">CPUI_INT_AND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a34b508b278aa7ad06b5f4412686d556a">CPUI_INT_CARRY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7abfca59d2db4cdc6126afa1d60e4aba51">CPUI_INT_EQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a057239d4bbf6b3ffc8fb2dae68ebc2d9">CPUI_INT_LEFT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a9fd7576d8174c8e8ad99a71b1bed2518">CPUI_INT_LESS</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2c6c583f14722fee36325c926280cbcc">CPUI_INT_LESSEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af4e88fc0408c2594dae2615b093aa68b">CPUI_INT_MULT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a9c0fdedf10c1c592fac2b5d9506fd7d1">CPUI_INT_NEGATE</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a82aa9ec8e7933e35b09e963cd87c2f30">CPUI_INT_NOTEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a3a89afc53cea68202d80ef9fc683eef9">CPUI_INT_OR</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aaf220264eb8b109f50d4986eb6c5d3ca">CPUI_INT_RIGHT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a130fb0f2aef7c9525d957efd807f0c0e">CPUI_INT_SBORROW</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a9d009bae29ddce29680b522c7c5262c6">CPUI_INT_SCARRY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a5fc7131a25cd3887d2ceabf181fa5b8a">CPUI_INT_SEXT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a0a05aafda58e54690ae841c3642e3b82">CPUI_INT_SLESS</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a49d2a9e93a7a397287ea70f8d6c6a132">CPUI_INT_SLESSEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ac499e9c9aa80f99bb51ea4792e4a770a">CPUI_INT_SRIGHT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a57325d4a11a85e526c5292c8aa6dd5e1">CPUI_INT_XOR</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a778868cfa2191f9621f632672e596702">CPUI_INT_ZEXT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a69a387d1e0b510d027e69bdde8f03caa">CPUI_PIECE</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classSubvariableFlow.html#a66a3ab237f4db9eddb1b4fff510c96a1">createLink()</a>, <a class="el" href="classSubvariableFlow.html#a2de777c3aa9ee9bcd1a170e5fae7d05f">createOp()</a>, <a class="el" href="classSubvariableFlow.html#afff6e343a0750a70d83657b326eda2ff">doesAndClear()</a>, <a class="el" href="classSubvariableFlow.html#a39275946de3e6e519e7c6b8a1c2b6428">doesOrSet()</a>, <a class="el" href="classSubvariableFlow.html#a1b26e6297105169ea18fd62844d9d0fd">flowsize</a>, <a class="el" href="address_8hh.html#ac4d874e14dba4c4dabbbdc0a15653755">leastsigbit_set()</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5623c2ae905db06b3df24fa041ce111b">SubvariableFlow::ReplaceVarnode::mask</a>, <a class="el" href="classSubvariableFlow.html#a575b1e0006753064afb611fb07955432">tryCallReturnPush()</a>, and <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a6c9a7b3ea519d06f2236a89928d2c3fd">SubvariableFlow::ReplaceVarnode::vn</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#aa43e138fb9680fa85394ca16d83c9a18">processNextWork()</a>.</p>

</div>
</div>
<a id="aacb1b62aee996ef277d511fbbd23c05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb1b62aee996ef277d511fbbd23c05b">&#9670;&nbsp;</a></span>traceBackwardSext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SubvariableFlow::traceBackwardSext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trace logical data-flow backward assuming sign-extensions. </p>
<p>Try to trace the logical variable up through its defining op, updating the logical subgraph. We assume (and check) that the logical variable has always been sign extended (sextstate) into its container. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rvn</td><td>is the given subgraph variable to trace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the logical value can successfully traced backward one level </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow.html#a5362dd3955608e0cb7f64d3d5c1c95d2">addConstant()</a>, <a class="el" href="classSubvariableFlow.html#a5a953ed2be3b0195775fb3a259f3c259">addPush()</a>, <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a50235a7bf50bada36dff73ff740c34d0">CPUI_CALL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a500b63ecb17a75652c705bfab98bc8e5">CPUI_CALLIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ae3942b7ee09733bcf388c575eb4b60cc">CPUI_INT_AND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a9c0fdedf10c1c592fac2b5d9506fd7d1">CPUI_INT_NEGATE</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a3a89afc53cea68202d80ef9fc683eef9">CPUI_INT_OR</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a5fc7131a25cd3887d2ceabf181fa5b8a">CPUI_INT_SEXT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ac499e9c9aa80f99bb51ea4792e4a770a">CPUI_INT_SRIGHT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a57325d4a11a85e526c5292c8aa6dd5e1">CPUI_INT_XOR</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a778868cfa2191f9621f632672e596702">CPUI_INT_ZEXT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classSubvariableFlow.html#a66a3ab237f4db9eddb1b4fff510c96a1">createLink()</a>, <a class="el" href="classSubvariableFlow.html#a2de777c3aa9ee9bcd1a170e5fae7d05f">createOp()</a>, <a class="el" href="classSubvariableFlow.html#a1b26e6297105169ea18fd62844d9d0fd">flowsize</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceOp.html#a443751debe8b031ff5038b6f2f7f9444">SubvariableFlow::ReplaceOp::input</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5623c2ae905db06b3df24fa041ce111b">SubvariableFlow::ReplaceVarnode::mask</a>, <a class="el" href="classSubvariableFlow.html#a575b1e0006753064afb611fb07955432">tryCallReturnPush()</a>, and <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a6c9a7b3ea519d06f2236a89928d2c3fd">SubvariableFlow::ReplaceVarnode::vn</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#aa43e138fb9680fa85394ca16d83c9a18">processNextWork()</a>.</p>

</div>
</div>
<a id="a3dec9be4f0c0467e3df5a0d9c4434392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dec9be4f0c0467e3df5a0d9c4434392">&#9670;&nbsp;</a></span>traceForward()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SubvariableFlow::traceForward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trace the logical data-flow forward for the given subgraph variable. </p>
<p>Try to trace the logical variable through descendant Varnodes creating new nodes in the logical subgraph and updating the worklist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rvn</td><td>is the given subgraph variable to trace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the logical value can be traced forward one level </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow.html#a67bb4d70077d7a8672030ac9dd6d2c2c">addBooleanPatch()</a>, <a class="el" href="classSubvariableFlow.html#a672ac552629697cecbe03711945d2e78">addSuggestedPatch()</a>, <a class="el" href="classSubvariableFlow.html#a1055cd15d23d55e0672d6c6033b99908">addTerminalPatch()</a>, <a class="el" href="classSubvariableFlow.html#a8afeebdabbaf720633f14f06f7f4de7d">addTerminalPatchSameOp()</a>, <a class="el" href="classSubvariableFlow.html#afdde71897645f51c6a4aba63b83ab122">aggressive</a>, <a class="el" href="classSubvariableFlow.html#a70070bdaa79b04d9d99bfefac65f5233">bitsize</a>, <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a40c57f047989281be90f40d4acc83d66">CPUI_BOOL_AND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a837d13895aa43a15cfc0ab7274237080">CPUI_BOOL_NEGATE</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a54a6e76c456fb2f580b2118f20be407e">CPUI_BOOL_OR</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a5b643eae5eb11ed82a24824f0f95cbda">CPUI_BOOL_XOR</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ac9526d56fc1c9dc6dc1f98c05729281a">CPUI_BRANCHIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a50235a7bf50bada36dff73ff740c34d0">CPUI_CALL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a500b63ecb17a75652c705bfab98bc8e5">CPUI_CALLIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a16130945560323d4b28ead4387094444">CPUI_CBRANCH</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ae3942b7ee09733bcf388c575eb4b60cc">CPUI_INT_AND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7abfca59d2db4cdc6126afa1d60e4aba51">CPUI_INT_EQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a057239d4bbf6b3ffc8fb2dae68ebc2d9">CPUI_INT_LEFT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a9fd7576d8174c8e8ad99a71b1bed2518">CPUI_INT_LESS</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2c6c583f14722fee36325c926280cbcc">CPUI_INT_LESSEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af4e88fc0408c2594dae2615b093aa68b">CPUI_INT_MULT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a9c0fdedf10c1c592fac2b5d9506fd7d1">CPUI_INT_NEGATE</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a82aa9ec8e7933e35b09e963cd87c2f30">CPUI_INT_NOTEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a3a89afc53cea68202d80ef9fc683eef9">CPUI_INT_OR</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aaf220264eb8b109f50d4986eb6c5d3ca">CPUI_INT_RIGHT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a5fc7131a25cd3887d2ceabf181fa5b8a">CPUI_INT_SEXT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ac499e9c9aa80f99bb51ea4792e4a770a">CPUI_INT_SRIGHT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a57325d4a11a85e526c5292c8aa6dd5e1">CPUI_INT_XOR</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a778868cfa2191f9621f632672e596702">CPUI_INT_ZEXT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a69a387d1e0b510d027e69bdde8f03caa">CPUI_PIECE</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af2f97499d0b08f223110ad8f59353b44">CPUI_RETURN</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classSubvariableFlow.html#a8c16f50f66821e5433d63c9ac23907a3">createCompareBridge()</a>, <a class="el" href="classSubvariableFlow.html#a66a3ab237f4db9eddb1b4fff510c96a1">createLink()</a>, <a class="el" href="classSubvariableFlow.html#aa2093247c8b43e880d990573d05cfa59">createNewOut()</a>, <a class="el" href="classSubvariableFlow.html#ad49b0d75a96ac7875cc9a4538fc4d943">createOpDown()</a>, <a class="el" href="classSubvariableFlow.html#afff6e343a0750a70d83657b326eda2ff">doesAndClear()</a>, <a class="el" href="classSubvariableFlow.html#a39275946de3e6e519e7c6b8a1c2b6428">doesOrSet()</a>, <a class="el" href="classSubvariableFlow.html#a1b26e6297105169ea18fd62844d9d0fd">flowsize</a>, <a class="el" href="classPcodeOp.html#af268eecc8bf4e8297f617005cb9a5413">PcodeOp::getRepeatSlot()</a>, <a class="el" href="classPcodeOp.html#a3bf80a4ef518e6a41cc0f0e8ae08e7b4">PcodeOp::getSlot()</a>, <a class="el" href="address_8hh.html#ac4d874e14dba4c4dabbbdc0a15653755">leastsigbit_set()</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5623c2ae905db06b3df24fa041ce111b">SubvariableFlow::ReplaceVarnode::mask</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceOp.html#a30caa45603a7ce1b61d9e5706807ff6e">SubvariableFlow::ReplaceOp::output</a>, <a class="el" href="classSubvariableFlow.html#a63eb516c7ab571aadb912c35c5b6bea8">tryCallPull()</a>, <a class="el" href="classSubvariableFlow.html#a550879200c908733016f9537c4bf3c48">tryReturnPull()</a>, <a class="el" href="classSubvariableFlow.html#a58422de83336c092c19ff94a44e3cf26">trySwitchPull()</a>, and <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a6c9a7b3ea519d06f2236a89928d2c3fd">SubvariableFlow::ReplaceVarnode::vn</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#aa43e138fb9680fa85394ca16d83c9a18">processNextWork()</a>.</p>

</div>
</div>
<a id="a23446f878dbf46ac35472c3f14fb10ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23446f878dbf46ac35472c3f14fb10ff">&#9670;&nbsp;</a></span>traceForwardSext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SubvariableFlow::traceForwardSext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trace logical data-flow forward assuming sign-extensions. </p>
<p>Try to trace the logical variable through descendant Varnodes, updating the logical subgraph. We assume (and check) that the logical variable has always been sign extended (sextstate) into its container. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rvn</td><td>is the given subgraph variable to trace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the logical value can successfully traced forward one level </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow.html#a5362dd3955608e0cb7f64d3d5c1c95d2">addConstant()</a>, <a class="el" href="classSubvariableFlow.html#a1055cd15d23d55e0672d6c6033b99908">addTerminalPatch()</a>, <a class="el" href="classSubvariableFlow.html#a8afeebdabbaf720633f14f06f7f4de7d">addTerminalPatchSameOp()</a>, <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ac9526d56fc1c9dc6dc1f98c05729281a">CPUI_BRANCHIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a50235a7bf50bada36dff73ff740c34d0">CPUI_CALL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a500b63ecb17a75652c705bfab98bc8e5">CPUI_CALLIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ae3942b7ee09733bcf388c575eb4b60cc">CPUI_INT_AND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7abfca59d2db4cdc6126afa1d60e4aba51">CPUI_INT_EQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a9fd7576d8174c8e8ad99a71b1bed2518">CPUI_INT_LESS</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2c6c583f14722fee36325c926280cbcc">CPUI_INT_LESSEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a9c0fdedf10c1c592fac2b5d9506fd7d1">CPUI_INT_NEGATE</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a82aa9ec8e7933e35b09e963cd87c2f30">CPUI_INT_NOTEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a3a89afc53cea68202d80ef9fc683eef9">CPUI_INT_OR</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a5fc7131a25cd3887d2ceabf181fa5b8a">CPUI_INT_SEXT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a0a05aafda58e54690ae841c3642e3b82">CPUI_INT_SLESS</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a49d2a9e93a7a397287ea70f8d6c6a132">CPUI_INT_SLESSEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ac499e9c9aa80f99bb51ea4792e4a770a">CPUI_INT_SRIGHT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a57325d4a11a85e526c5292c8aa6dd5e1">CPUI_INT_XOR</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af2f97499d0b08f223110ad8f59353b44">CPUI_RETURN</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classSubvariableFlow.html#a8c16f50f66821e5433d63c9ac23907a3">createCompareBridge()</a>, <a class="el" href="classSubvariableFlow.html#a66a3ab237f4db9eddb1b4fff510c96a1">createLink()</a>, <a class="el" href="classSubvariableFlow.html#ad49b0d75a96ac7875cc9a4538fc4d943">createOpDown()</a>, <a class="el" href="classSubvariableFlow.html#a1b26e6297105169ea18fd62844d9d0fd">flowsize</a>, <a class="el" href="classPcodeOp.html#af268eecc8bf4e8297f617005cb9a5413">PcodeOp::getRepeatSlot()</a>, <a class="el" href="classPcodeOp.html#a3bf80a4ef518e6a41cc0f0e8ae08e7b4">PcodeOp::getSlot()</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5623c2ae905db06b3df24fa041ce111b">SubvariableFlow::ReplaceVarnode::mask</a>, <a class="el" href="classSubvariableFlow.html#a63eb516c7ab571aadb912c35c5b6bea8">tryCallPull()</a>, <a class="el" href="classSubvariableFlow.html#a550879200c908733016f9537c4bf3c48">tryReturnPull()</a>, <a class="el" href="classSubvariableFlow.html#a58422de83336c092c19ff94a44e3cf26">trySwitchPull()</a>, and <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a6c9a7b3ea519d06f2236a89928d2c3fd">SubvariableFlow::ReplaceVarnode::vn</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#aa43e138fb9680fa85394ca16d83c9a18">processNextWork()</a>.</p>

</div>
</div>
<a id="a63eb516c7ab571aadb912c35c5b6bea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63eb516c7ab571aadb912c35c5b6bea8">&#9670;&nbsp;</a></span>tryCallPull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SubvariableFlow::tryCallPull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the given subgraph variable can act as a parameter to the given CALL op. </p>
<p>We assume the variable flows as a parameter to the CALL. If the CALL doesn't lock the parameter size, create a <a class="el" href="classSubvariableFlow_1_1PatchRecord.html" title="Operation with a new logical value as (part of) input, but output Varnode is unchanged.">PatchRecord</a> within the subgraph that allows the CALL to take the parameter with its smaller logical size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given CALL op </td></tr>
    <tr><td class="paramname">rvn</td><td>is the given subgraph variable acting as a parameter </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot of the variable within the CALL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the parameter can be successfully trimmed to its logical size </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow.html#afdde71897645f51c6a4aba63b83ab122">aggressive</a>, <a class="el" href="classSubvariableFlow.html#a4967964b7fe88cfd29b13520c76ed077">fd</a>, <a class="el" href="classFuncdata.html#a952f07a6db222c00cc243917767dcdc1">Funcdata::getCallSpecs()</a>, <a class="el" href="classFuncProto.html#aab52f093617d8bd8a67f011ba5a0d324">FuncProto::isInputLocked()</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5623c2ae905db06b3df24fa041ce111b">SubvariableFlow::ReplaceVarnode::mask</a>, <a class="el" href="classSubvariableFlow_1_1PatchRecord.html#a36246381da40b955494923b58ee46b2baed4af286797d6341d6d1fb22ef3e2dbf">SubvariableFlow::PatchRecord::parameter_patch</a>, <a class="el" href="classSubvariableFlow.html#aa20eb2c458459b59cab7c5ca821374c7">patchlist</a>, <a class="el" href="classSubvariableFlow.html#a2a636435e09513d7602228fc4b048245">pullcount</a>, and <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a6c9a7b3ea519d06f2236a89928d2c3fd">SubvariableFlow::ReplaceVarnode::vn</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a3dec9be4f0c0467e3df5a0d9c4434392">traceForward()</a>, and <a class="el" href="classSubvariableFlow.html#a23446f878dbf46ac35472c3f14fb10ff">traceForwardSext()</a>.</p>

</div>
</div>
<a id="a575b1e0006753064afb611fb07955432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575b1e0006753064afb611fb07955432">&#9670;&nbsp;</a></span>tryCallReturnPush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SubvariableFlow::tryCallReturnPush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the given subgraph variable can act as a <em>created</em> value for the given INDIRECT op. </p>
<p>Check if the INDIRECT is an <em>indirect</em> <em>creation</em> and is not representing a locked return value. If we can, create the INDIRECT node in the subgraph representing the logical <em>indirect</em> <em>creation</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given INDIRECT </td></tr>
    <tr><td class="paramname">rvn</td><td>is the given subgraph variable acting as the output of the INDIRECT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if we can successfully trim the value to its logical size </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow.html#a5a953ed2be3b0195775fb3a259f3c259">addPush()</a>, <a class="el" href="classSubvariableFlow.html#afdde71897645f51c6a4aba63b83ab122">aggressive</a>, <a class="el" href="classSubvariableFlow.html#a70070bdaa79b04d9d99bfefac65f5233">bitsize</a>, <a class="el" href="classSubvariableFlow.html#a4967964b7fe88cfd29b13520c76ed077">fd</a>, <a class="el" href="classFuncdata.html#a952f07a6db222c00cc243917767dcdc1">Funcdata::getCallSpecs()</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5623c2ae905db06b3df24fa041ce111b">SubvariableFlow::ReplaceVarnode::mask</a>, and <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a6c9a7b3ea519d06f2236a89928d2c3fd">SubvariableFlow::ReplaceVarnode::vn</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a3e4ceb7c191460b4bbc54932ce79bf54">traceBackward()</a>, and <a class="el" href="classSubvariableFlow.html#aacb1b62aee996ef277d511fbbd23c05b">traceBackwardSext()</a>.</p>

</div>
</div>
<a id="a550879200c908733016f9537c4bf3c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550879200c908733016f9537c4bf3c48">&#9670;&nbsp;</a></span>tryReturnPull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SubvariableFlow::tryReturnPull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the given subgraph variable can act as return value for the given RETURN op. </p>
<p>We assume the variable flows the RETURN. If the return value size is not locked. Create a <a class="el" href="classSubvariableFlow_1_1PatchRecord.html" title="Operation with a new logical value as (part of) input, but output Varnode is unchanged.">PatchRecord</a> within the subgraph that allows the RETURN to take a smaller logical value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given RETURN op </td></tr>
    <tr><td class="paramname">rvn</td><td>is the given subgraph variable flowing to the RETURN </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot of the subgraph variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the return value can be successfully trimmed to its logical size </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow.html#afdde71897645f51c6a4aba63b83ab122">aggressive</a>, <a class="el" href="classFuncdata.html#a47de4c82b4a74b356153eb8e4215f639">Funcdata::beginOp()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af2f97499d0b08f223110ad8f59353b44">CPUI_RETURN</a>, <a class="el" href="classFuncdata.html#ad24461680d41c61349b3717283d8b854">Funcdata::endOp()</a>, <a class="el" href="classSubvariableFlow.html#a4967964b7fe88cfd29b13520c76ed077">fd</a>, <a class="el" href="classPcodeOp.html#af4f85b05be28b424b0dccf3646029eb9">PcodeOp::getHaltType()</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5623c2ae905db06b3df24fa041ce111b">SubvariableFlow::ReplaceVarnode::mask</a>, <a class="el" href="classSubvariableFlow_1_1PatchRecord.html#a36246381da40b955494923b58ee46b2baed4af286797d6341d6d1fb22ef3e2dbf">SubvariableFlow::PatchRecord::parameter_patch</a>, <a class="el" href="classSubvariableFlow.html#aa20eb2c458459b59cab7c5ca821374c7">patchlist</a>, <a class="el" href="classSubvariableFlow.html#a2a636435e09513d7602228fc4b048245">pullcount</a>, <a class="el" href="classSubvariableFlow.html#a9f3f97ee182f7b9b14179645f1595649">returnsTraversed</a>, <a class="el" href="classSubvariableFlow.html#ab8c0bdac6dfac824759dba300c06dc62">setReplacement()</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a6c9a7b3ea519d06f2236a89928d2c3fd">SubvariableFlow::ReplaceVarnode::vn</a>, and <a class="el" href="classSubvariableFlow.html#a80e9880cefec3f4d280347a51d37e7f9">worklist</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a3dec9be4f0c0467e3df5a0d9c4434392">traceForward()</a>, and <a class="el" href="classSubvariableFlow.html#a23446f878dbf46ac35472c3f14fb10ff">traceForwardSext()</a>.</p>

</div>
</div>
<a id="a58422de83336c092c19ff94a44e3cf26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58422de83336c092c19ff94a44e3cf26">&#9670;&nbsp;</a></span>trySwitchPull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SubvariableFlow::trySwitchPull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the subgraph variable can act as a switch variable for the given BRANCHIND. </p>
<p>We query the <a class="el" href="classJumpTable.html" title="A map from values to control-flow targets within a function.">JumpTable</a> associated with the BRANCHIND to see if its switch variable can be trimmed as indicated by the logical flow. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given BRANCHIND op </td></tr>
    <tr><td class="paramname">rvn</td><td>is the subgraph variable flowing to the BRANCHIND </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the switch variable can be successfully trimmed to its logical size </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5623c2ae905db06b3df24fa041ce111b">SubvariableFlow::ReplaceVarnode::mask</a>, <a class="el" href="classSubvariableFlow_1_1PatchRecord.html#a36246381da40b955494923b58ee46b2baed4af286797d6341d6d1fb22ef3e2dbf">SubvariableFlow::PatchRecord::parameter_patch</a>, <a class="el" href="classSubvariableFlow.html#aa20eb2c458459b59cab7c5ca821374c7">patchlist</a>, <a class="el" href="classSubvariableFlow.html#a2a636435e09513d7602228fc4b048245">pullcount</a>, and <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a6c9a7b3ea519d06f2236a89928d2c3fd">SubvariableFlow::ReplaceVarnode::vn</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a3dec9be4f0c0467e3df5a0d9c4434392">traceForward()</a>, and <a class="el" href="classSubvariableFlow.html#a23446f878dbf46ac35472c3f14fb10ff">traceForwardSext()</a>.</p>

</div>
</div>
<a id="a5c6eb4dd6e57b774f3a79ca8c8fceb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6eb4dd6e57b774f3a79ca8c8fceb41">&#9670;&nbsp;</a></span>useSameAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SubvariableFlow::useSameAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html">ReplaceVarnode</a> *&#160;</td>
          <td class="paramname"><em>rvn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decide if we use the same memory range of the original <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> for the logical replacement. </p>
<p>Usually the logical <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> can use the <em>true</em> storage bytes that hold the value, but there are a few corner cases where we want to use a new temporary register to hold the value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rvn</td><td>is the subgraph variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the same memory range can be used to hold the value </dd></dl>

<p class="reference">References <a class="el" href="classSubvariableFlow.html#afdde71897645f51c6a4aba63b83ab122">aggressive</a>, <a class="el" href="classSubvariableFlow.html#a70070bdaa79b04d9d99bfefac65f5233">bitsize</a>, <a class="el" href="classVarnode.html#a61fd3ac206edbb80a9c42f3b69755b61">Varnode::isAddrTied()</a>, <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a5623c2ae905db06b3df24fa041ce111b">SubvariableFlow::ReplaceVarnode::mask</a>, and <a class="el" href="classSubvariableFlow_1_1ReplaceVarnode.html#a6c9a7b3ea519d06f2236a89928d2c3fd">SubvariableFlow::ReplaceVarnode::vn</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSubvariableFlow.html#a6975acfca24824c2c0ae4f2b6b70dea3">getReplaceVarnode()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="subflow_8hh.html">subflow.hh</a></li>
<li>subflow.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
