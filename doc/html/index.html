<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>decompiler: Decompiler Analysis Engine</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Decompiler Analysis Engine </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="toc"></a>
Table of Contents</h1>
<ul>
<li><a class="el" href="index.html#overview">Overview</a></li>
<li><a class="el" href="index.html#capabilities">Capabilities</a></li>
<li><a class="el" href="index.html#design">Design</a></li>
<li><a class="el" href="index.html#workflow">Main Work Flow</a></li>
<li>ghidraimpl</li>
<li><a class="el" href="sleigh.html">SLEIGH</a></li>
<li><a class="el" href="coreclasses.html">Core Classes</a></li>
<li>termrewriting</li>
</ul>
<h1><a class="anchor" id="overview"></a>
Overview</h1>
<p>Welcome to the <b>Decompiler</b> <b>Analysis</b> <b>Engine</b>. It is a complete library for performing automated data-flow analysis on software, starting from the binary executable. This documentation is geared toward understanding the source code and starts with a brief discussion of the libraries capabilities and moves immediately into the design of the decompiler and the main code workflow.</p>
<p>The library provides its own Register Transfer Languate (RTL), referred to internally as <b>p-code</b>, which is designed specifically for reverse engineering applications. The disassembly of processor specific machine-code languages, and subsequent translation into <b>p-code</b>, forms a major sub-system of the decompiler. There is a processor specification language, referred to as <b>SLEIGH</b>, which is dedicated to this translation task, and there is a corresponding section in the documentation for the classes and methods used to implement this language in the library (See <a class="el" href="sleigh.html">SLEIGH</a>). This piece of the code can be built as a standalone binary translation library, for use by other applications.</p>
<p>For getting up to speed quickly on the details of the source and the decompiler's main data structures, there is a specific documentation page describing the core classes and methods.</p>
<p>Finally there is a documentation page summarizing the simplification rules used in the core decompiler analysis.</p>
<h1><a class="anchor" id="capabilities"></a>
Capabilities</h1>
<h1><a class="anchor" id="design"></a>
Design</h1>
<p>The main design elements of the decompiler come straight from standard <em>Compiler</em> <em>Theory</em> data structures and algorithms. This should come as no surprise, as both compilers and decompilers are concerned with translating from one coding language to another. They both follow a general work flow:</p>
<ul>
<li>Parse/tokenize input language.</li>
<li>Build abstract syntax trees in an intermediate language.</li>
<li>Manipulate/optimize syntax trees.</li>
<li>Map intermediate language to output language constructs.</li>
<li>Emit final output language encoding.</li>
</ul>
<p>With direct analogs to (forward engineering) compilers, the decompiler uses:</p>
<ul>
<li>A Register Transfer Language (RTL) referred to as <b>p-code</b>.</li>
<li>Static Single Assignment (SSA) form.</li>
<li>Basic blocks and Control Flow Graphs.</li>
<li>Term rewriting rules.</li>
<li>Dead code elimination.</li>
<li><a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> tables and scopes.</li>
</ul>
<p>Despite these similarities, the differences between a decompiler and a compiler are substantial and run throughout the entire process. These all stem from the fact that, in general, descriptive elements and the higher-level organization of a piece of code can only be explicitly expressed in a high-level language. So the decompiler, working with a low-level language as input, can only infer this information.</p>
<p>The features mentioned above all have a decompiler specific slant to them, and there are other tasks that the decompiler must perform that have no real analog with a compiler. These include:</p>
<ul>
<li>Variable merging (vaguely related to register coloring)</li>
<li>Type propagation</li>
<li>Control flow structuring</li>
<li>Function prototype recovery</li>
<li>Expression recovery</li>
</ul>
<h1><a class="anchor" id="workflow"></a>
Main Work Flow</h1>
<p>Here is an outline of the decompiler work flow.</p>
<ol type="1">
<li><a class="el" href="index.html#step0">Specify Entry Point</a></li>
<li><a class="el" href="index.html#step1">Generate Raw P-code</a></li>
<li><a class="el" href="index.html#step2">Generate Basic Blocks and the CFG</a></li>
<li><a class="el" href="index.html#step3">Inspect Sub-functions</a></li>
<li><a class="el" href="index.html#step4">Adjust/Annotate P-code</a></li>
<li><a class="el" href="index.html#step5">The Main Simplification Loop</a><ul>
<li><a class="el" href="index.html#step5a">Generate SSA Form</a></li>
<li>Adjust p-code in special situations.</li>
<li><a class="el" href="index.html#step5b">Eliminate Dead Code</a></li>
<li><a class="el" href="index.html#step5c">Propagate Local Types</a></li>
<li><a class="el" href="index.html#step5d">Perform Term Rewriting</a></li>
<li><a class="el" href="index.html#step5e">Adjust Control Flow Graph</a></li>
<li><a class="el" href="index.html#step5f">Recover Control Flow Structure</a></li>
</ul>
</li>
<li><a class="el" href="index.html#step6">Perform Final P-code Transformations</a></li>
<li><a class="el" href="index.html#step7">Exit SSA Form and Merge Low-level Variables (phase 1)</a></li>
<li><a class="el" href="index.html#step8">Determine Expressions and Temporary Variables</a></li>
<li><a class="el" href="index.html#step9">Merge Low-level Variables (phase 2)</a></li>
<li><a class="el" href="index.html#step10">Add Type Casts</a></li>
<li><a class="el" href="index.html#step11">Establish Function's Prototype</a></li>
<li><a class="el" href="index.html#step12">Select Variable Names</a></li>
<li><a class="el" href="index.html#step13">Do Final Control Flow Structuring</a></li>
<li><a class="el" href="index.html#step14">Emit Final C Tokens</a></li>
</ol>
<h2><a class="anchor" id="step0"></a>
Specify Entry Point</h2>
<p>The user specifies a starting address for a particular function.</p>
<h2><a class="anchor" id="step1"></a>
Generate Raw P-code</h2>
<p>The p-code generation engine is called <b>SLEIGH</b>. Based on a processor specification file, it maps binary encoded machine instructions to sequences of p-code operations. P-code operations are generated for a single machine instruction at a specific address. The control flow through these p-code operations is followed to determine if control falls through, or if there are jumps or calls. A work list of new instruction addresses is kept and is continually revisited until there are no new instructions. After the control flow is traced, additional changes may be made to the p-code.</p>
<ol type="1">
<li>PIC constructions are checked for, now that the extent of the function is known. If a call is to a location that is still within the function, the call is changed to a jump.</li>
<li>Functions which are marked as inlined are filled in at this point, before basic blocks are generated. P-code for the inlined function is generated separately and control flow is carefully set up to link it in properly.</li>
</ol>
<h2><a class="anchor" id="step2"></a>
Generate Basic Blocks and the CFG</h2>
<p>Basic blocks are generated on the p-code instructions (<em>not</em> the machine instructions) and a control flow graph of these basic blocks is generated. Control flow is normalized so that there is always a unique start block with no other blocks falling into it. In the case of subroutines which have branches back to their very first machine instruction, this requires the creation of an empty placeholder start block that flows immediately into the block containing the p-code for the first instruction.</p>
<h2><a class="anchor" id="step3"></a>
Inspect Sub-functions</h2>
<ol type="1">
<li>Addresses of direct calls are looked up in the database and any parameter information is recovered.</li>
<li>If there is information about an indirect call, parameter information can be filled in and the indirect call can be changed to a direct call.</li>
<li>Any call for which no prototype is found has a default prototype set for it.</li>
<li>Any global or default prototype recovered at this point can be overridden locally.</li>
</ol>
<h2><a class="anchor" id="step4"></a>
Adjust/Annotate P-code</h2>
<ol type="1">
<li>The context database is searched for known values of memory locations coming into the function. These are implemented by inserting p-code <b>COPY</b> instructions that assign the correct value to the correct memory location at the beginning of the function.</li>
<li>The recovered prototypes may require that extra p-code is injected at the call site so that certain actions of the call are explicit to the analysis engine.</li>
<li>Other p-code may be inserted to indicate changes a call makes to the stack pointer. Its possible that the change to the stack pointer is unknown. In this case <b>INDIRECT</b> p-code instructions are inserted to indicate that the state of the stack pointer is unknown at that point, preparing for the extrapop action.</li>
<li>For each p-code call instruction, extra inputs are added to the instruction either corresponding to a known input for that call, or in preparation for the prototype recovery actions. If the (potential) function input is located on the stack, a temporary is defined for that input and a full p-code <b>LOAD</b> instruction, with accompanying offset calculation, is inserted before the call to link the input with the (currently unknown) stack offset. Similarly extra outputs are added to the call instructions either representing a known return value, or in preparation for parameter recovery actions.</li>
<li>Each p-code <b>RETURN</b> instruction for the current function is adjusted to hide the use of the return address and to add an input location for the return value. The return value is considered an input to the <b>RETURN</b> instruction.</li>
</ol>
<h2><a class="anchor" id="step5"></a>
The Main Simplification Loop</h2>
<h3><a class="anchor" id="step5a"></a>
Generate SSA Form</h3>
<p>This is very similar to forward engineering algorithms. It uses a fairly standard phi-node placement algorithm based on the control flow dominator tree and the so-called dominance frontier. A standard renaming algorithm is used for the final linking of variable defs and uses. The decompiler has to take into account partially overlapping variables and guard against various aliasing situations, which are generally more explicit to a compiler. The decompiler SSA algorithm also works incrementally. Many of the stack references in a function cannot be fully resolved until the main term rewriting pass has been performed on the register variables. Rather than leaving stack references as associated <b>LOAD</b> s and <b>STORE</b> s, when the references are finally discovered, they are promoted to full variables within the SSA tree. This allows full copy propagation and simplification to occur with these variables, but it often requires 1 or more additional passes to fully build the SSA tree. Local aliasing information and aliasing across subfunction calls can be annotated in the SSA structure via <b>INDIRECT</b> p-code operations, which holds the information that the output of the <b>INDIRECT</b> is derived from the input by some indirect (frequently unknown) effect.</p>
<h3><a class="anchor" id="step5b"></a>
Eliminate Dead Code</h3>
<p>Dead code elimination is essential to the decompiler because a large percentage of machine instructions have side-effects on machine state, such as the setting of flags, that are not relevant to the function at a particular point in the code. Dead code elimination is complicated by the fact that its not always clear what variables are temporary, locals, or globals. Also, compilers frequently map smaller (1-byte or 2-byte) variables into bigger (4-byte) registers, and manipulation of these registers may still carry around left over information in the upper bytes. The decompiler detects dead code down to the bit, in order to appropriately truncate variables in these situations.</p>
<h3><a class="anchor" id="step5c"></a>
Propagate Local Types</h3>
<p>The decompiler has to infer high-level type information about the variables it analyzes, as this kind of information is generally not present in the input binary. Some information can be gathered about a variable, based on the instructions it is used in (.i.e if it is used in a floating point instruction). Other information about type might be available from header files or from the user. Once this is gathered, the preliminary type information is allowed to propagate through the syntax trees so that related types of other variables can be determined.</p>
<h3><a class="anchor" id="step5d"></a>
Perform Term Rewriting</h3>
<p>The bulk of the interesting simplifications happen in this section. Following Formal Methods style term rewriting, a long list of rules are applied to the syntax tree. Each rule matches some potential configuration in a portion of the syntax tree, and after the rule matches, it specifies a sequence of edit operations on the syntax tree to transform it. Each rule can be applied repeatedly and in different parts of the tree if necessary. So even a small set of rules can cause a large transformation. The set of rules in the decompiler is extensive and is tailored to specific reverse engineering needs and compiler constructs. The goal of these transformations is not to optimize as a compiler would, but to simplify and normalize for easier understanding and recognition by human analysts (and follow on machine processing). Typical examples of transforms include, copy propagation, constant propagation, collecting terms, cancellation of operators and other algebraic simplifications, undoing multiplication and division optimizations, commuting operators, ....</p>
<h3><a class="anchor" id="step5e"></a>
Adjust Control Flow Graph</h3>
<p>The decompiler can recognize</p><ul>
<li>unreachable code</li>
<li>unused branches</li>
<li>empty basic blocks</li>
<li>redundant predicates</li>
<li>...</li>
</ul>
<p>It will remove branches or blocks in order to simplify the control flow.</p>
<h3><a class="anchor" id="step5f"></a>
Recover Control Flow Structure</h3>
<p>The decompiler recovers higher-level control flow objects like loops, <b>if/<b>else</b> blocks</b>, and <b>switch</b> statements. The entire control flow of the function is built up hierarchically with these objects, allowing it to be expressed naturally in the final output with the standard control flow constructs of the high-level language. The decompiler recognizes common high-level unstructured control flow idioms, like <em>break</em>, and can use node-splitting in some situations to undo compiler flow optimizations that prevent a structured representation.</p>
<h2><a class="anchor" id="step6"></a>
Perform Final P-code Transformations</h2>
<p>During the main simplification loop, many p-code operations are normalized in specific ways for the term rewriting process that aren't necessarily ideal for the final output. This phase does transforms designed to enhance readability of the final output. A simple example is that all subtractions (<b>INT_SUB</b>) are normalized to be an addition on the twos complement in the main loop. This phase would convert any remaining additions of this form back into a subtraction operation.</p>
<h2><a class="anchor" id="step7"></a>
Exit SSA Form and Merge Low-level Variables (phase 1)</h2>
<p>The static variables of the SSA form need to be merged into complete high-level variables. The first part of this is accomplished by formally exiting SSA form. The SSA phi-nodes and indirects are eliminated either by merging the input and output variables or inserting extra <b>COPY</b> operations. Merging must guard against a high-level variable holding different values (in different memory locations) at the same time. This is similar to register coloring in compiler design.</p>
<h2><a class="anchor" id="step8"></a>
Determine Expressions and Temporary Variables</h2>
<p>A final determination is made of what the final output expressions are going to be, by determining which variables in the syntax tree will be explicit and which represent temporary variables. Certain terms must automatically be explicit, such as constants, inputs, etc. Other variables are forced to be explicit because they are read too many times or because making it implicit would propagate another variable too far. Any variables remaining are marked implicit.</p>
<h2><a class="anchor" id="step9"></a>
Merge Low-level Variables (phase 2)</h2>
<p>Even after the initial merging of variables in phase 1, there are generally still too many for normal C code. So the decompiler, does additional, more speculative merging. It first tries to merge the inputs and outputs of copy operations, and then the inputs and outputs of more general operations. And finally, merging is attempted on variables of the same type. Each potential merge is subject to register coloring restrictions.</p>
<h2><a class="anchor" id="step10"></a>
Add Type Casts</h2>
<p>Type casts are added to the code so that the final output will be syntactically legal.</p>
<h2><a class="anchor" id="step11"></a>
Establish Function's Prototype</h2>
<p>The register/stack locations being used to pass parameters into the function are analyzed in terms of the parameter passing convention being used so that appropriate names can be selected and the prototype can be printed with the input variables in the correct order.</p>
<h2><a class="anchor" id="step12"></a>
Select Variable Names</h2>
<p>The high-level variables, which are now in their final form, have names assigned based on any information gathered from their low-level elements and the symbol table. If no name can be identified from the database, an appropriate name is generated automatically.</p>
<h2><a class="anchor" id="step13"></a>
Do Final Control Flow Structuring</h2>
<ol type="1">
<li>Order separate components</li>
<li>Order switch cases</li>
<li>Determine which unstructured jumps are breaks</li>
<li>Stick in labels for remaining unstructured jumps</li>
</ol>
<h2><a class="anchor" id="step14"></a>
Emit Final C Tokens</h2>
<p>Following the recovered function prototype, the recovered control flow structure, and the recovered expressions, the final C tokens are generated. Each token is annotated with its syntactic meaning, for later syntax highlighting. And most tokens are also annotated with the address of the machine instruction with which they are most closely associated. This is the basis for the machine/C code cross highlighting capability. The tokens are passed through a standard Oppen pretty-printing algorithm to determine the final line breaks and indenting. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
