<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>decompiler: Scope Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classScope-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Scope Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A collection of <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> objects within a single (namespace or functional) scope.  
 <a href="classScope.html#details">More...</a></p>

<p><code>#include &lt;database.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Scope:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classScope.png" usemap="#Scope_map" alt=""/>
  <map id="Scope_map" name="Scope_map">
<area href="classScopeGhidra.html" title="An implementation of the Scope interface by querying a Ghidra client for Symbol information." alt="ScopeGhidra" shape="rect" coords="0,56,152,80"/>
<area href="classScopeInternal.html" title="An in-memory implementation of the Scope interface." alt="ScopeInternal" shape="rect" coords="162,56,314,80"/>
<area href="classScopeGhidraNamespace.html" title="A global namespace Scope." alt="ScopeGhidraNamespace" shape="rect" coords="81,112,233,136"/>
<area href="classScopeLocal.html" title="A Symbol scope for local variables of a particular function." alt="ScopeLocal" shape="rect" coords="243,112,395,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a203cfd8813735894486ed2c57f378f1e"><td class="memItemLeft" align="right" valign="top"><a id="a203cfd8813735894486ed2c57f378f1e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a203cfd8813735894486ed2c57f378f1e">Scope</a> (const string &amp;nm, <a class="el" href="classArchitecture.html">Architecture</a> *g)</td></tr>
<tr class="memdesc:a203cfd8813735894486ed2c57f378f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty scope, given a name and <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a>. <br /></td></tr>
<tr class="separator:a203cfd8813735894486ed2c57f378f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571dad0bea947a7c5c1cfea083733963"><td class="memItemLeft" align="right" valign="top"><a id="a571dad0bea947a7c5c1cfea083733963"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a571dad0bea947a7c5c1cfea083733963">~Scope</a> (void)</td></tr>
<tr class="memdesc:a571dad0bea947a7c5c1cfea083733963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a571dad0bea947a7c5c1cfea083733963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054e7b7c470035be94e1e4229ff188d4"><td class="memItemLeft" align="right" valign="top"><a id="a054e7b7c470035be94e1e4229ff188d4"></a>
virtual <a class="el" href="classMapIterator.html">MapIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a054e7b7c470035be94e1e4229ff188d4">begin</a> (void) const =0</td></tr>
<tr class="memdesc:a054e7b7c470035be94e1e4229ff188d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beginning iterator to mapped SymbolEntrys. <br /></td></tr>
<tr class="separator:a054e7b7c470035be94e1e4229ff188d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186b8c11ebef0f2d3838bfe1e46b6db6"><td class="memItemLeft" align="right" valign="top"><a id="a186b8c11ebef0f2d3838bfe1e46b6db6"></a>
virtual <a class="el" href="classMapIterator.html">MapIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a186b8c11ebef0f2d3838bfe1e46b6db6">end</a> (void) const =0</td></tr>
<tr class="memdesc:a186b8c11ebef0f2d3838bfe1e46b6db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending iterator to mapped SymbolEntrys. <br /></td></tr>
<tr class="separator:a186b8c11ebef0f2d3838bfe1e46b6db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0f92c9d85a20b77b562e5a499b9e6d"><td class="memItemLeft" align="right" valign="top"><a id="aab0f92c9d85a20b77b562e5a499b9e6d"></a>
virtual list&lt; <a class="el" href="classSymbolEntry.html">SymbolEntry</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aab0f92c9d85a20b77b562e5a499b9e6d">beginDynamic</a> (void) const =0</td></tr>
<tr class="memdesc:aab0f92c9d85a20b77b562e5a499b9e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beginning iterator to dynamic SymbolEntrys. <br /></td></tr>
<tr class="separator:aab0f92c9d85a20b77b562e5a499b9e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add98c4a0c13d3497f82d0a5c2353b578"><td class="memItemLeft" align="right" valign="top"><a id="add98c4a0c13d3497f82d0a5c2353b578"></a>
virtual list&lt; <a class="el" href="classSymbolEntry.html">SymbolEntry</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#add98c4a0c13d3497f82d0a5c2353b578">endDynamic</a> (void) const =0</td></tr>
<tr class="memdesc:add98c4a0c13d3497f82d0a5c2353b578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending iterator to dynamic SymbolEntrys. <br /></td></tr>
<tr class="separator:add98c4a0c13d3497f82d0a5c2353b578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883ad2607f2c7859b49b45100c2c0011"><td class="memItemLeft" align="right" valign="top"><a id="a883ad2607f2c7859b49b45100c2c0011"></a>
virtual list&lt; <a class="el" href="classSymbolEntry.html">SymbolEntry</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a883ad2607f2c7859b49b45100c2c0011">beginDynamic</a> (void)=0</td></tr>
<tr class="memdesc:a883ad2607f2c7859b49b45100c2c0011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beginning iterator to dynamic SymbolEntrys. <br /></td></tr>
<tr class="separator:a883ad2607f2c7859b49b45100c2c0011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c892157b9de825a3b475581fbf4019"><td class="memItemLeft" align="right" valign="top"><a id="a37c892157b9de825a3b475581fbf4019"></a>
virtual list&lt; <a class="el" href="classSymbolEntry.html">SymbolEntry</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a37c892157b9de825a3b475581fbf4019">endDynamic</a> (void)=0</td></tr>
<tr class="memdesc:a37c892157b9de825a3b475581fbf4019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending iterator to dynamic SymbolEntrys. <br /></td></tr>
<tr class="separator:a37c892157b9de825a3b475581fbf4019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfa2b0a98ba3ceeafd5a1e7ad2e2c21"><td class="memItemLeft" align="right" valign="top"><a id="a9bfa2b0a98ba3ceeafd5a1e7ad2e2c21"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a9bfa2b0a98ba3ceeafd5a1e7ad2e2c21">clear</a> (void)=0</td></tr>
<tr class="memdesc:a9bfa2b0a98ba3ceeafd5a1e7ad2e2c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all symbols from <b>this</b> scope. <br /></td></tr>
<tr class="separator:a9bfa2b0a98ba3ceeafd5a1e7ad2e2c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c8275b6500a9cc620cc31f32ed267e"><td class="memItemLeft" align="right" valign="top"><a id="ab3c8275b6500a9cc620cc31f32ed267e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ab3c8275b6500a9cc620cc31f32ed267e">clearCategory</a> (int4 cat)=0</td></tr>
<tr class="memdesc:ab3c8275b6500a9cc620cc31f32ed267e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all symbols of the given category from <b>this</b> scope. <br /></td></tr>
<tr class="separator:ab3c8275b6500a9cc620cc31f32ed267e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d58385a87dca33d128300c666e5064"><td class="memItemLeft" align="right" valign="top"><a id="ac7d58385a87dca33d128300c666e5064"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ac7d58385a87dca33d128300c666e5064">clearUnlocked</a> (void)=0</td></tr>
<tr class="memdesc:ac7d58385a87dca33d128300c666e5064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all unlocked symbols from <b>this</b> scope. <br /></td></tr>
<tr class="separator:ac7d58385a87dca33d128300c666e5064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fc66a463ca11a4c533991cea0639c8"><td class="memItemLeft" align="right" valign="top"><a id="a15fc66a463ca11a4c533991cea0639c8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a15fc66a463ca11a4c533991cea0639c8">clearUnlockedCategory</a> (int4 cat)=0</td></tr>
<tr class="memdesc:a15fc66a463ca11a4c533991cea0639c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear unlocked symbols of the given category from <b>this</b> scope. <br /></td></tr>
<tr class="separator:a15fc66a463ca11a4c533991cea0639c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcaec6d7678dabe548680747d843a52"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a4fcaec6d7678dabe548680747d843a52">inScope</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const</td></tr>
<tr class="memdesc:a4fcaec6d7678dabe548680747d843a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if the given range is owned by <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScope.html#a4fcaec6d7678dabe548680747d843a52">More...</a><br /></td></tr>
<tr class="separator:a4fcaec6d7678dabe548680747d843a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f86985c8d27f20e444d2d36385617a"><td class="memItemLeft" align="right" valign="top"><a id="ad4f86985c8d27f20e444d2d36385617a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ad4f86985c8d27f20e444d2d36385617a">removeSymbolMappings</a> (<a class="el" href="classSymbol.html">Symbol</a> *symbol)=0</td></tr>
<tr class="memdesc:ad4f86985c8d27f20e444d2d36385617a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all SymbolEntrys from the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>. <br /></td></tr>
<tr class="separator:ad4f86985c8d27f20e444d2d36385617a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0172591847f6a1b338ad324f28732f7f"><td class="memItemLeft" align="right" valign="top"><a id="a0172591847f6a1b338ad324f28732f7f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a0172591847f6a1b338ad324f28732f7f">removeSymbol</a> (<a class="el" href="classSymbol.html">Symbol</a> *symbol)=0</td></tr>
<tr class="memdesc:a0172591847f6a1b338ad324f28732f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> from <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. <br /></td></tr>
<tr class="separator:a0172591847f6a1b338ad324f28732f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab576de2e768be9507ee03faa163c1ddf"><td class="memItemLeft" align="right" valign="top"><a id="ab576de2e768be9507ee03faa163c1ddf"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ab576de2e768be9507ee03faa163c1ddf">renameSymbol</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, const string &amp;newname)=0</td></tr>
<tr class="memdesc:ab576de2e768be9507ee03faa163c1ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. <br /></td></tr>
<tr class="separator:ab576de2e768be9507ee03faa163c1ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeef6a133b07fa176c08b67c44064e69"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#afeef6a133b07fa176c08b67c44064e69">retypeSymbol</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, <a class="el" href="classDatatype.html">Datatype</a> *ct)=0</td></tr>
<tr class="memdesc:afeef6a133b07fa176c08b67c44064e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the data-type of a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScope.html#afeef6a133b07fa176c08b67c44064e69">More...</a><br /></td></tr>
<tr class="separator:afeef6a133b07fa176c08b67c44064e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a49f329dcfe47129bf11acac543233e"><td class="memItemLeft" align="right" valign="top"><a id="a7a49f329dcfe47129bf11acac543233e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a7a49f329dcfe47129bf11acac543233e">setAttribute</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, uint4 attr)=0</td></tr>
<tr class="memdesc:a7a49f329dcfe47129bf11acac543233e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boolean <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> properties on a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>. <br /></td></tr>
<tr class="separator:a7a49f329dcfe47129bf11acac543233e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb57165fd0d3c182e18ea24e7231975d"><td class="memItemLeft" align="right" valign="top"><a id="afb57165fd0d3c182e18ea24e7231975d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#afb57165fd0d3c182e18ea24e7231975d">clearAttribute</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, uint4 attr)=0</td></tr>
<tr class="memdesc:afb57165fd0d3c182e18ea24e7231975d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear boolean <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> properties on a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>. <br /></td></tr>
<tr class="separator:afb57165fd0d3c182e18ea24e7231975d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae799cc3171536b9ee10497631aea8c5b"><td class="memItemLeft" align="right" valign="top"><a id="ae799cc3171536b9ee10497631aea8c5b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ae799cc3171536b9ee10497631aea8c5b">setDisplayFormat</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, uint4 attr)=0</td></tr>
<tr class="memdesc:ae799cc3171536b9ee10497631aea8c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the display format for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>. <br /></td></tr>
<tr class="separator:ae799cc3171536b9ee10497631aea8c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4ea61f9a55ddfc9defd8548654c8e5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aae4ea61f9a55ddfc9defd8548654c8e5">findAddr</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const =0</td></tr>
<tr class="memdesc:aae4ea61f9a55ddfc9defd8548654c8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> at a given address and <b>usepoint</b>.  <a href="classScope.html#aae4ea61f9a55ddfc9defd8548654c8e5">More...</a><br /></td></tr>
<tr class="separator:aae4ea61f9a55ddfc9defd8548654c8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609fc1ef47d047717da65827e025cfdd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a609fc1ef47d047717da65827e025cfdd">findContainer</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const =0</td></tr>
<tr class="memdesc:a609fc1ef47d047717da65827e025cfdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the smallest <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> containing the given memory range.  <a href="classScope.html#a609fc1ef47d047717da65827e025cfdd">More...</a><br /></td></tr>
<tr class="separator:a609fc1ef47d047717da65827e025cfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab679fe786be2fb949af78054cb2041a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ab679fe786be2fb949af78054cb2041a8">findClosestFit</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const =0</td></tr>
<tr class="memdesc:ab679fe786be2fb949af78054cb2041a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> which is the closest fit to the given memory range.  <a href="classScope.html#ab679fe786be2fb949af78054cb2041a8">More...</a><br /></td></tr>
<tr class="separator:ab679fe786be2fb949af78054cb2041a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c621196f6fdb4b8ce4ee1f3dc953107"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a2c621196f6fdb4b8ce4ee1f3dc953107">findFunction</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const =0</td></tr>
<tr class="memdesc:a2c621196f6fdb4b8ce4ee1f3dc953107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the function starting at the given address.  <a href="classScope.html#a2c621196f6fdb4b8ce4ee1f3dc953107">More...</a><br /></td></tr>
<tr class="separator:a2c621196f6fdb4b8ce4ee1f3dc953107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69e0f77b621a3ba6436f8a1c0010d1c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#af69e0f77b621a3ba6436f8a1c0010d1c">findExternalRef</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const =0</td></tr>
<tr class="memdesc:af69e0f77b621a3ba6436f8a1c0010d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an <em>external</em> <em>reference</em> at the given address.  <a href="classScope.html#af69e0f77b621a3ba6436f8a1c0010d1c">More...</a><br /></td></tr>
<tr class="separator:af69e0f77b621a3ba6436f8a1c0010d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bac52b9d64974b87432c0379cc38c6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLabSymbol.html">LabSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#af4bac52b9d64974b87432c0379cc38c6">findCodeLabel</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const =0</td></tr>
<tr class="memdesc:af4bac52b9d64974b87432c0379cc38c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a label <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> at the given address.  <a href="classScope.html#af4bac52b9d64974b87432c0379cc38c6">More...</a><br /></td></tr>
<tr class="separator:af4bac52b9d64974b87432c0379cc38c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3395b6194a59515caa1ede92fd6ac511"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a3395b6194a59515caa1ede92fd6ac511">findOverlap</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const =0</td></tr>
<tr class="memdesc:a3395b6194a59515caa1ede92fd6ac511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> overlapping the given memory range.  <a href="classScope.html#a3395b6194a59515caa1ede92fd6ac511">More...</a><br /></td></tr>
<tr class="separator:a3395b6194a59515caa1ede92fd6ac511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979222d28577e6e8d07e35f12d38bff7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a979222d28577e6e8d07e35f12d38bff7">findByName</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; &amp;res) const =0</td></tr>
<tr class="memdesc:a979222d28577e6e8d07e35f12d38bff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> by name within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScope.html#a979222d28577e6e8d07e35f12d38bff7">More...</a><br /></td></tr>
<tr class="separator:a979222d28577e6e8d07e35f12d38bff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eeda63eacff8611321ba44508ccef3e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a9eeda63eacff8611321ba44508ccef3e">isNameUsed</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>) const =0</td></tr>
<tr class="memdesc:a9eeda63eacff8611321ba44508ccef3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given name is used within <b>this</b> scope.  <a href="classScope.html#a9eeda63eacff8611321ba44508ccef3e">More...</a><br /></td></tr>
<tr class="separator:a9eeda63eacff8611321ba44508ccef3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c45025894f1996ef0f3556752cd997"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#af4c45025894f1996ef0f3556752cd997">resolveExternalRefFunction</a> (<a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> *sym) const =0</td></tr>
<tr class="memdesc:af4c45025894f1996ef0f3556752cd997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <em>external</em> <em>reference</em> to the referenced function.  <a href="classScope.html#af4c45025894f1996ef0f3556752cd997">More...</a><br /></td></tr>
<tr class="separator:af4c45025894f1996ef0f3556752cd997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925baecb33b6f0d9212e42c1b48a64ba"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a925baecb33b6f0d9212e42c1b48a64ba">buildVariableName</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;pc, <a class="el" href="classDatatype.html">Datatype</a> *ct, int4 &amp;index, uint4 flags) const =0</td></tr>
<tr class="memdesc:a925baecb33b6f0d9212e42c1b48a64ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an address and data-type, build a suitable generic symbol name.  <a href="classScope.html#a925baecb33b6f0d9212e42c1b48a64ba">More...</a><br /></td></tr>
<tr class="separator:a925baecb33b6f0d9212e42c1b48a64ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47d5c1c949be84a27a138be0febacb2"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ac47d5c1c949be84a27a138be0febacb2">buildUndefinedName</a> (void) const =0</td></tr>
<tr class="memdesc:ac47d5c1c949be84a27a138be0febacb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formal <b>undefined</b> name, used internally when a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is not given a name.  <a href="classScope.html#ac47d5c1c949be84a27a138be0febacb2">More...</a><br /></td></tr>
<tr class="separator:ac47d5c1c949be84a27a138be0febacb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0d945c44f4874743496b2814fbb631"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a2e0d945c44f4874743496b2814fbb631">makeNameUnique</a> (const string &amp;nm) const =0</td></tr>
<tr class="memdesc:a2e0d945c44f4874743496b2814fbb631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a version of the given symbol name that won't collide with other names in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScope.html#a2e0d945c44f4874743496b2814fbb631">More...</a><br /></td></tr>
<tr class="separator:a2e0d945c44f4874743496b2814fbb631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2583da1be37d68197dfbb0445fa1f3e0"><td class="memItemLeft" align="right" valign="top"><a id="a2583da1be37d68197dfbb0445fa1f3e0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a2583da1be37d68197dfbb0445fa1f3e0">saveXml</a> (ostream &amp;s) const =0</td></tr>
<tr class="memdesc:a2583da1be37d68197dfbb0445fa1f3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out <b>this</b> as a &lt;scope&gt; XML tag. <br /></td></tr>
<tr class="separator:a2583da1be37d68197dfbb0445fa1f3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad509027899b5f6af11f499f722d61f66"><td class="memItemLeft" align="right" valign="top"><a id="ad509027899b5f6af11f499f722d61f66"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ad509027899b5f6af11f499f722d61f66">restoreXml</a> (const <a class="el" href="classElement.html">Element</a> *el)=0</td></tr>
<tr class="memdesc:ad509027899b5f6af11f499f722d61f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> from a &lt;scope&gt; XML tag. <br /></td></tr>
<tr class="separator:ad509027899b5f6af11f499f722d61f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d67a1b9e60078023b508dd3cbe4447d"><td class="memItemLeft" align="right" valign="top"><a id="a7d67a1b9e60078023b508dd3cbe4447d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a7d67a1b9e60078023b508dd3cbe4447d">printEntries</a> (ostream &amp;s) const =0</td></tr>
<tr class="memdesc:a7d67a1b9e60078023b508dd3cbe4447d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a description of all <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> objects to a stream. <br /></td></tr>
<tr class="separator:a7d67a1b9e60078023b508dd3cbe4447d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909e15a7a96c9b402855b56b6bfdbd9f"><td class="memItemLeft" align="right" valign="top">virtual int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a909e15a7a96c9b402855b56b6bfdbd9f">getCategorySize</a> (int4 cat) const =0</td></tr>
<tr class="memdesc:a909e15a7a96c9b402855b56b6bfdbd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of Symbols in the given category.  <a href="classScope.html#a909e15a7a96c9b402855b56b6bfdbd9f">More...</a><br /></td></tr>
<tr class="separator:a909e15a7a96c9b402855b56b6bfdbd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491a168d7ea71f00da419dd864901ccb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a491a168d7ea71f00da419dd864901ccb">getCategorySymbol</a> (int4 cat, int4 ind) const =0</td></tr>
<tr class="memdesc:a491a168d7ea71f00da419dd864901ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> by index within a specific <em>category</em>.  <a href="classScope.html#a491a168d7ea71f00da419dd864901ccb">More...</a><br /></td></tr>
<tr class="separator:a491a168d7ea71f00da419dd864901ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac807e11df36854d2f7983bdd6779e83a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ac807e11df36854d2f7983bdd6779e83a">setCategory</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, int4 cat, int4 ind)=0</td></tr>
<tr class="memdesc:ac807e11df36854d2f7983bdd6779e83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <em>category</em> and index for the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>.  <a href="classScope.html#ac807e11df36854d2f7983bdd6779e83a">More...</a><br /></td></tr>
<tr class="separator:ac807e11df36854d2f7983bdd6779e83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c79f7f535ba4e819fcf95185896a019"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a7c79f7f535ba4e819fcf95185896a019">addSymbol</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, <a class="el" href="classDatatype.html">Datatype</a> *ct, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint)</td></tr>
<tr class="memdesc:a7c79f7f535ba4e819fcf95185896a019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> to <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>, given a name, data-type, and a single mapping.  <a href="classScope.html#a7c79f7f535ba4e819fcf95185896a019">More...</a><br /></td></tr>
<tr class="separator:a7c79f7f535ba4e819fcf95185896a019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d2e4eeed5fbc77e0477936f60cfde5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ae7d2e4eeed5fbc77e0477936f60cfde5">queryByName</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; &amp;res) const</td></tr>
<tr class="memdesc:ae7d2e4eeed5fbc77e0477936f60cfde5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up symbols by name.  <a href="classScope.html#ae7d2e4eeed5fbc77e0477936f60cfde5">More...</a><br /></td></tr>
<tr class="separator:ae7d2e4eeed5fbc77e0477936f60cfde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9b49c7da91626fcb1cfacda5236991"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a6f9b49c7da91626fcb1cfacda5236991">queryFunction</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>) const</td></tr>
<tr class="memdesc:a6f9b49c7da91626fcb1cfacda5236991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up a function by name.  <a href="classScope.html#a6f9b49c7da91626fcb1cfacda5236991">More...</a><br /></td></tr>
<tr class="separator:a6f9b49c7da91626fcb1cfacda5236991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc95566b073624a0d12231a8e70bc5ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#afc95566b073624a0d12231a8e70bc5ce">queryByAddr</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const</td></tr>
<tr class="memdesc:afc95566b073624a0d12231a8e70bc5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> with matching address.  <a href="classScope.html#afc95566b073624a0d12231a8e70bc5ce">More...</a><br /></td></tr>
<tr class="separator:afc95566b073624a0d12231a8e70bc5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50dcbdbad011571fc24398781a2bab2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#af50dcbdbad011571fc24398781a2bab2">queryContainer</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const</td></tr>
<tr class="memdesc:af50dcbdbad011571fc24398781a2bab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the smallest containing <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>.  <a href="classScope.html#af50dcbdbad011571fc24398781a2bab2">More...</a><br /></td></tr>
<tr class="separator:af50dcbdbad011571fc24398781a2bab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8c2c2302eba2666e319a4c18a67d51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a1b8c2c2302eba2666e319a4c18a67d51">queryProperties</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint, uint4 &amp;flags) const</td></tr>
<tr class="memdesc:a1b8c2c2302eba2666e319a4c18a67d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> or properties at the given address.  <a href="classScope.html#a1b8c2c2302eba2666e319a4c18a67d51">More...</a><br /></td></tr>
<tr class="separator:a1b8c2c2302eba2666e319a4c18a67d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6c56240bdb6df2d2670077cf5e08ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a5d6c56240bdb6df2d2670077cf5e08ca">queryFunction</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:a5d6c56240bdb6df2d2670077cf5e08ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up a function by address.  <a href="classScope.html#a5d6c56240bdb6df2d2670077cf5e08ca">More...</a><br /></td></tr>
<tr class="separator:a5d6c56240bdb6df2d2670077cf5e08ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7850e4fd00c5dcc9299e646d13aae3dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a7850e4fd00c5dcc9299e646d13aae3dc">queryExternalRefFunction</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:a7850e4fd00c5dcc9299e646d13aae3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up a function thru an <em>external</em> <em>reference</em>.  <a href="classScope.html#a7850e4fd00c5dcc9299e646d13aae3dc">More...</a><br /></td></tr>
<tr class="separator:a7850e4fd00c5dcc9299e646d13aae3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88982df383433525505723b19b8aaa13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLabSymbol.html">LabSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a88982df383433525505723b19b8aaa13">queryCodeLabel</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:a88982df383433525505723b19b8aaa13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up a code label by address.  <a href="classScope.html#a88982df383433525505723b19b8aaa13">More...</a><br /></td></tr>
<tr class="separator:a88982df383433525505723b19b8aaa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b252ca0ce3155c06fe0cee6eae9265b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a3b252ca0ce3155c06fe0cee6eae9265b">resolveScope</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>) const</td></tr>
<tr class="memdesc:a3b252ca0ce3155c06fe0cee6eae9265b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> of <b>this</b>.  <a href="classScope.html#a3b252ca0ce3155c06fe0cee6eae9265b">More...</a><br /></td></tr>
<tr class="separator:a3b252ca0ce3155c06fe0cee6eae9265b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef5f179b42a9696fd077dbc7144ecc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aaef5f179b42a9696fd077dbc7144ecc2">discoverScope</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 sz, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint)</td></tr>
<tr class="memdesc:aaef5f179b42a9696fd077dbc7144ecc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the owning <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> of a given memory range.  <a href="classScope.html#aaef5f179b42a9696fd077dbc7144ecc2">More...</a><br /></td></tr>
<tr class="separator:aaef5f179b42a9696fd077dbc7144ecc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c1f312cf9173871baa1b2fad29bb58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a68c1f312cf9173871baa1b2fad29bb58">saveXmlRecursive</a> (ostream &amp;s, bool onlyGlobal) const</td></tr>
<tr class="memdesc:a68c1f312cf9173871baa1b2fad29bb58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save all contained scopes as an XML stream.  <a href="classScope.html#a68c1f312cf9173871baa1b2fad29bb58">More...</a><br /></td></tr>
<tr class="separator:a68c1f312cf9173871baa1b2fad29bb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a05df4f8df1764859bec8372d64b1ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a0a05df4f8df1764859bec8372d64b1ee">overrideSizeLockType</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, <a class="el" href="classDatatype.html">Datatype</a> *ct)</td></tr>
<tr class="memdesc:a0a05df4f8df1764859bec8372d64b1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the data-type of a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> that is <em>sizelocked</em>.  <a href="classScope.html#a0a05df4f8df1764859bec8372d64b1ee">More...</a><br /></td></tr>
<tr class="separator:a0a05df4f8df1764859bec8372d64b1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af52229967e3a507a5367e14a298142"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a4af52229967e3a507a5367e14a298142">resetSizeLockType</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym)</td></tr>
<tr class="memdesc:a4af52229967e3a507a5367e14a298142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>'s <em>size-locked</em> data-type.  <a href="classScope.html#a4af52229967e3a507a5367e14a298142">More...</a><br /></td></tr>
<tr class="separator:a4af52229967e3a507a5367e14a298142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abf50d101c65af19281910dac990ca5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a1abf50d101c65af19281910dac990ca5">isSubScope</a> (const <a class="el" href="classScope.html">Scope</a> *scp) const</td></tr>
<tr class="memdesc:a1abf50d101c65af19281910dac990ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a sub-scope of the given <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScope.html#a1abf50d101c65af19281910dac990ca5">More...</a><br /></td></tr>
<tr class="separator:a1abf50d101c65af19281910dac990ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0c1eab94766936cb73686e39b2ab6d"><td class="memItemLeft" align="right" valign="top"><a id="a6e0c1eab94766936cb73686e39b2ab6d"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a6e0c1eab94766936cb73686e39b2ab6d">getFullName</a> (void) const</td></tr>
<tr class="memdesc:a6e0c1eab94766936cb73686e39b2ab6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the full name of <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. <br /></td></tr>
<tr class="separator:a6e0c1eab94766936cb73686e39b2ab6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0befa1009748f0af39a1e6b7704b7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a0d0befa1009748f0af39a1e6b7704b7b">getNameSegments</a> (vector&lt; string &gt; &amp;vec) const</td></tr>
<tr class="memdesc:a0d0befa1009748f0af39a1e6b7704b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fullname of <b>this</b> in segments.  <a href="classScope.html#a0d0befa1009748f0af39a1e6b7704b7b">More...</a><br /></td></tr>
<tr class="separator:a0d0befa1009748f0af39a1e6b7704b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea425f0c244ce263988024ec0eb537ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aea425f0c244ce263988024ec0eb537ae">getScopePath</a> (vector&lt; <a class="el" href="classScope.html">Scope</a> * &gt; &amp;vec) const</td></tr>
<tr class="memdesc:aea425f0c244ce263988024ec0eb537ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ordered list of parent scopes to <b>this</b>.  <a href="classScope.html#aea425f0c244ce263988024ec0eb537ae">More...</a><br /></td></tr>
<tr class="separator:aea425f0c244ce263988024ec0eb537ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84da27186e9a57fa4c8ae1f6ca02744"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ad84da27186e9a57fa4c8ae1f6ca02744">isNameUsed</a> (const string &amp;nm, const <a class="el" href="classScope.html">Scope</a> *op2) const</td></tr>
<tr class="memdesc:ad84da27186e9a57fa4c8ae1f6ca02744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given name in use within given scope path.  <a href="classScope.html#ad84da27186e9a57fa4c8ae1f6ca02744">More...</a><br /></td></tr>
<tr class="separator:ad84da27186e9a57fa4c8ae1f6ca02744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab269032369c349fe61278304791e0130"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ab269032369c349fe61278304791e0130">findDistinguishingScope</a> (const <a class="el" href="classScope.html">Scope</a> *op2) const</td></tr>
<tr class="memdesc:ab269032369c349fe61278304791e0130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first ancestor of <b>this</b> not shared by given scope.  <a href="classScope.html#ab269032369c349fe61278304791e0130">More...</a><br /></td></tr>
<tr class="separator:ab269032369c349fe61278304791e0130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e7adcd07f0dbd9cf1777e2b3be9fe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a96e7adcd07f0dbd9cf1777e2b3be9fe2">addSymbol</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, <a class="el" href="classDatatype.html">Datatype</a> *ct)</td></tr>
<tr class="memdesc:a96e7adcd07f0dbd9cf1777e2b3be9fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> <em>without</em> mapping it to an address.  <a href="classScope.html#a96e7adcd07f0dbd9cf1777e2b3be9fe2">More...</a><br /></td></tr>
<tr class="separator:a96e7adcd07f0dbd9cf1777e2b3be9fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a0309ce54c25e56871edbfdfe25675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a03a0309ce54c25e56871edbfdfe25675">addMapPoint</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint)</td></tr>
<tr class="memdesc:a03a0309ce54c25e56871edbfdfe25675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> to a specific address.  <a href="classScope.html#a03a0309ce54c25e56871edbfdfe25675">More...</a><br /></td></tr>
<tr class="separator:a03a0309ce54c25e56871edbfdfe25675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421f1b66be24bd5a20c77761e7a51268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a421f1b66be24bd5a20c77761e7a51268">addMapSym</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a421f1b66be24bd5a20c77761e7a51268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a mapped <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> from a &lt;mapsym&gt; XML tag.  <a href="classScope.html#a421f1b66be24bd5a20c77761e7a51268">More...</a><br /></td></tr>
<tr class="separator:a421f1b66be24bd5a20c77761e7a51268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7f8bc9f073a957d43298394cac0678"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFunctionSymbol.html">FunctionSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a8f7f8bc9f073a957d43298394cac0678">addFunction</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const string &amp;nm)</td></tr>
<tr class="memdesc:a8f7f8bc9f073a957d43298394cac0678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a function <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> at the given address in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScope.html#a8f7f8bc9f073a957d43298394cac0678">More...</a><br /></td></tr>
<tr class="separator:a8f7f8bc9f073a957d43298394cac0678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648715fd4a06419df21ecdc060ff2911"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a648715fd4a06419df21ecdc060ff2911">addExternalRef</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;refaddr, const string &amp;nm)</td></tr>
<tr class="separator:a648715fd4a06419df21ecdc060ff2911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcaf595e4437d91af6a243ef0d49640"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLabSymbol.html">LabSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a4dcaf595e4437d91af6a243ef0d49640">addCodeLabel</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const string &amp;nm)</td></tr>
<tr class="memdesc:a4dcaf595e4437d91af6a243ef0d49640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a code label at the given address in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScope.html#a4dcaf595e4437d91af6a243ef0d49640">More...</a><br /></td></tr>
<tr class="separator:a4dcaf595e4437d91af6a243ef0d49640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42668b79a23d2e4e67f54e2185a2b58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#af42668b79a23d2e4e67f54e2185a2b58">addDynamicSymbol</a> (const string &amp;nm, <a class="el" href="classDatatype.html">Datatype</a> *ct, const <a class="el" href="classAddress.html">Address</a> &amp;caddr, uint8 hash)</td></tr>
<tr class="memdesc:af42668b79a23d2e4e67f54e2185a2b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dynamically mapped <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> attached to a specific data-flow.  <a href="classScope.html#af42668b79a23d2e4e67f54e2185a2b58">More...</a><br /></td></tr>
<tr class="separator:af42668b79a23d2e4e67f54e2185a2b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7dbb309986d8622ec0721f7a80bda1"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a1b7dbb309986d8622ec0721f7a80bda1">buildDefaultName</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, int4 &amp;base, <a class="el" href="classVarnode.html">Varnode</a> *vn) const</td></tr>
<tr class="memdesc:a1b7dbb309986d8622ec0721f7a80bda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a default name for the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>.  <a href="classScope.html#a1b7dbb309986d8622ec0721f7a80bda1">More...</a><br /></td></tr>
<tr class="separator:a1b7dbb309986d8622ec0721f7a80bda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6645d4ce07bea82322ac366b8c6168"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a7b6645d4ce07bea82322ac366b8c6168">isReadOnly</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const</td></tr>
<tr class="memdesc:a7b6645d4ce07bea82322ac366b8c6168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given memory range marked as <em>read-only</em>.  <a href="classScope.html#a7b6645d4ce07bea82322ac366b8c6168">More...</a><br /></td></tr>
<tr class="separator:a7b6645d4ce07bea82322ac366b8c6168"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a21556c257fbea888f9004c654599dfe9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a21556c257fbea888f9004c654599dfe9">restrictScope</a> (<a class="el" href="classFuncdata.html">Funcdata</a> *f)</td></tr>
<tr class="memdesc:a21556c257fbea888f9004c654599dfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <b>this</b> to a local <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScope.html#a21556c257fbea888f9004c654599dfe9">More...</a><br /></td></tr>
<tr class="separator:a21556c257fbea888f9004c654599dfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33adf8d24b5e22aa420b840b817131e0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a33adf8d24b5e22aa420b840b817131e0">addRange</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, uintb first, uintb last)</td></tr>
<tr class="memdesc:a33adf8d24b5e22aa420b840b817131e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a memory range to the ownership of <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScope.html#a33adf8d24b5e22aa420b840b817131e0">More...</a><br /></td></tr>
<tr class="separator:a33adf8d24b5e22aa420b840b817131e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b4a9faa5d12ef3b0be55810dac6d35"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ad1b4a9faa5d12ef3b0be55810dac6d35">removeRange</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, uintb first, uintb last)</td></tr>
<tr class="memdesc:ad1b4a9faa5d12ef3b0be55810dac6d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a memory range from the ownership of <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScope.html#ad1b4a9faa5d12ef3b0be55810dac6d35">More...</a><br /></td></tr>
<tr class="separator:ad1b4a9faa5d12ef3b0be55810dac6d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d3198f4bd28cf9e8a2a6bc00d065d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a66d3198f4bd28cf9e8a2a6bc00d065d8">addSymbolInternal</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym)=0</td></tr>
<tr class="memdesc:a66d3198f4bd28cf9e8a2a6bc00d065d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> into the name map.  <a href="classScope.html#a66d3198f4bd28cf9e8a2a6bc00d065d8">More...</a><br /></td></tr>
<tr class="separator:a66d3198f4bd28cf9e8a2a6bc00d065d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0451f131ea214a174e00a434be36e9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aec0451f131ea214a174e00a434be36e9">addMapInternal</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, uint4 exfl, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 off, int4 sz, const <a class="el" href="classRangeList.html">RangeList</a> &amp;uselim)=0</td></tr>
<tr class="memdesc:aec0451f131ea214a174e00a434be36e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> given a memory range.  <a href="classScope.html#aec0451f131ea214a174e00a434be36e9">More...</a><br /></td></tr>
<tr class="separator:aec0451f131ea214a174e00a434be36e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3b5f792b07b023d43309472cd6f4d9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a5d3b5f792b07b023d43309472cd6f4d9">addDynamicMapInternal</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, uint4 exfl, uint8 hash, int4 off, int4 sz, const <a class="el" href="classRangeList.html">RangeList</a> &amp;uselim)=0</td></tr>
<tr class="memdesc:a5d3b5f792b07b023d43309472cd6f4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> given a dynamic hash.  <a href="classScope.html#a5d3b5f792b07b023d43309472cd6f4d9">More...</a><br /></td></tr>
<tr class="separator:a5d3b5f792b07b023d43309472cd6f4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93f6dfecb978ac52b56f967896ca758"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ab93f6dfecb978ac52b56f967896ca758">addMap</a> (const <a class="el" href="classSymbolEntry.html">SymbolEntry</a> &amp;entry)</td></tr>
<tr class="memdesc:ab93f6dfecb978ac52b56f967896ca758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate a <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> into the range maps.  <a href="classScope.html#ab93f6dfecb978ac52b56f967896ca758">More...</a><br /></td></tr>
<tr class="separator:ab93f6dfecb978ac52b56f967896ca758"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a598536926659c304d35346aba6d79fa2"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a598536926659c304d35346aba6d79fa2">stackAddr</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint, <a class="el" href="classSymbolEntry.html">SymbolEntry</a> **addrmatch)</td></tr>
<tr class="memdesc:a598536926659c304d35346aba6d79fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query for Symbols starting at a given address, which match a given <b>usepoint</b>.  <a href="classScope.html#a598536926659c304d35346aba6d79fa2">More...</a><br /></td></tr>
<tr class="separator:a598536926659c304d35346aba6d79fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e00dad81427a8595cf7bf13d8e1e0d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a63e00dad81427a8595cf7bf13d8e1e0d">stackContainer</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint, <a class="el" href="classSymbolEntry.html">SymbolEntry</a> **addrmatch)</td></tr>
<tr class="separator:a63e00dad81427a8595cf7bf13d8e1e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de9b51d8c57e33e9394512489539664"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a4de9b51d8c57e33e9394512489539664">stackClosestFit</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint, <a class="el" href="classSymbolEntry.html">SymbolEntry</a> **addrmatch)</td></tr>
<tr class="separator:a4de9b51d8c57e33e9394512489539664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0d2e90ee5d4bc7e3dc761390be5e47"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a1e0d2e90ee5d4bc7e3dc761390be5e47">stackFunction</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, <a class="el" href="classFuncdata.html">Funcdata</a> **addrmatch)</td></tr>
<tr class="separator:a1e0d2e90ee5d4bc7e3dc761390be5e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44898a2294de74a77dd21583ca6254e2"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a44898a2294de74a77dd21583ca6254e2">stackExternalRef</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, <a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> **addrmatch)</td></tr>
<tr class="separator:a44898a2294de74a77dd21583ca6254e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26992d3bf69e5c2c02e57943b1355f0d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a26992d3bf69e5c2c02e57943b1355f0d">stackCodeLabel</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, <a class="el" href="classLabSymbol.html">LabSymbol</a> **addrmatch)</td></tr>
<tr class="separator:a26992d3bf69e5c2c02e57943b1355f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa5939cb5690f2f2b4f52a88ae561622d"><td class="memItemLeft" align="right" valign="top"><a id="aa5939cb5690f2f2b4f52a88ae561622d"></a>
<a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">glb</a></td></tr>
<tr class="memdesc:aa5939cb5690f2f2b4f52a88ae561622d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a> of <b>this</b> scope. <br /></td></tr>
<tr class="separator:aa5939cb5690f2f2b4f52a88ae561622d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4900f6409e8a82c1b1cea827e4e2c5"><td class="memItemLeft" align="right" valign="top"><a id="abb4900f6409e8a82c1b1cea827e4e2c5"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a></td></tr>
<tr class="memdesc:abb4900f6409e8a82c1b1cea827e4e2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of <b>this</b> scope. <br /></td></tr>
<tr class="separator:abb4900f6409e8a82c1b1cea827e4e2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f6c31e73c46216482a6902d22b3330"><td class="memItemLeft" align="right" valign="top"><a id="a72f6c31e73c46216482a6902d22b3330"></a>
<a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a72f6c31e73c46216482a6902d22b3330">fd</a></td></tr>
<tr class="memdesc:a72f6c31e73c46216482a6902d22b3330"><td class="mdescLeft">&#160;</td><td class="mdescRight">(If non-null) the function which <b>this</b> is the local <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> for <br /></td></tr>
<tr class="separator:a72f6c31e73c46216482a6902d22b3330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67040159cc1bea1399308eda8aa0f22"><td class="memItemLeft" align="right" valign="top"><a id="ad67040159cc1bea1399308eda8aa0f22"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ad67040159cc1bea1399308eda8aa0f22">uniqueId</a></td></tr>
<tr class="memdesc:ad67040159cc1bea1399308eda8aa0f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique id for the scope, for deduping scope names, assigning symbol ids. <br /></td></tr>
<tr class="separator:ad67040159cc1bea1399308eda8aa0f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a267c957503a77a651230beedbc9f27ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a267c957503a77a651230beedbc9f27ec">attachScope</a> (<a class="el" href="classScope.html">Scope</a> *child)</td></tr>
<tr class="memdesc:a267c957503a77a651230beedbc9f27ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a new child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> to <b>this</b>.  <a href="classScope.html#a267c957503a77a651230beedbc9f27ec">More...</a><br /></td></tr>
<tr class="separator:a267c957503a77a651230beedbc9f27ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0b94bbfa2b7a8391f8be410547cc67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a4a0b94bbfa2b7a8391f8be410547cc67">detachScope</a> (ScopeMap::iterator iter)</td></tr>
<tr class="memdesc:a4a0b94bbfa2b7a8391f8be410547cc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> from <b>this</b>.  <a href="classScope.html#a4a0b94bbfa2b7a8391f8be410547cc67">More...</a><br /></td></tr>
<tr class="separator:a4a0b94bbfa2b7a8391f8be410547cc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a588172ad2f5c11ee6e9f793c2e599071"><td class="memItemLeft" align="right" valign="top"><a id="a588172ad2f5c11ee6e9f793c2e599071"></a>
<a class="el" href="classRangeList.html">RangeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a588172ad2f5c11ee6e9f793c2e599071">rangetree</a></td></tr>
<tr class="memdesc:a588172ad2f5c11ee6e9f793c2e599071"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRange.html" title="A contiguous range of bytes in some address space.">Range</a> of data addresses <em>owned</em> by <b>this</b> scope. <br /></td></tr>
<tr class="separator:a588172ad2f5c11ee6e9f793c2e599071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df68cab954d40b15c9e45bca324fcbc"><td class="memItemLeft" align="right" valign="top"><a id="a2df68cab954d40b15c9e45bca324fcbc"></a>
<a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a2df68cab954d40b15c9e45bca324fcbc">parent</a></td></tr>
<tr class="memdesc:a2df68cab954d40b15c9e45bca324fcbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent scope. <br /></td></tr>
<tr class="separator:a2df68cab954d40b15c9e45bca324fcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a6abc6a7c8631a1309d74ce9aa85e8"><td class="memItemLeft" align="right" valign="top"><a id="a10a6abc6a7c8631a1309d74ce9aa85e8"></a>
<a class="el" href="database_8hh.html#a471f91376cdded8bf673b01d6e85f700">ScopeMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a10a6abc6a7c8631a1309d74ce9aa85e8">children</a></td></tr>
<tr class="memdesc:a10a6abc6a7c8631a1309d74ce9aa85e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorted list of child scopes. <br /></td></tr>
<tr class="separator:a10a6abc6a7c8631a1309d74ce9aa85e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6efef52d7a939622bbc934ff6b90ffe0"><td class="memItemLeft" align="right" valign="top"><a id="a6efef52d7a939622bbc934ff6b90ffe0"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Database</b></td></tr>
<tr class="separator:a6efef52d7a939622bbc934ff6b90ffe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec804b298dc727f18acb363664fb4f5"><td class="memItemLeft" align="right" valign="top"><a id="a7ec804b298dc727f18acb363664fb4f5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ScopeCompare</b></td></tr>
<tr class="separator:a7ec804b298dc727f18acb363664fb4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A collection of <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> objects within a single (namespace or functional) scope. </p>
<p>This acts as a traditional <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> container, allowing them to be accessed by name, but it also keeps track of how a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is mapped into memory. It allows a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> to be looked up by its location in memory, which is sensitive to the address of the code accessing the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>.</p>
<p>Capabilities include:</p><ul>
<li>Search for Symbols<ul>
<li>By name</li>
<li>By storage address</li>
<li>By type of <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a></li>
<li>Containing a range</li>
<li>Overlapping a range</li>
</ul>
</li>
<li>Insert or remove a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a></li>
<li>Add or remove <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> objects which associate Symbols with storage and the code that accesses it</li>
<li>Modify properties of a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a></li>
</ul>
<p>A scope also supports the idea of <b>ownership</b> of memory. In theory, for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> in the scope, at the code locations where the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> storage is valid, the scope <em>owns</em> the storage memory. In practice, a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> object knows about memory ranges where a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> might be <em>discovered</em>. For instance, the global <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> usually owns all memory in the <em>ram</em> address space. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a4dcaf595e4437d91af6a243ef0d49640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcaf595e4437d91af6a243ef0d49640">&#9670;&nbsp;</a></span>addCodeLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLabSymbol.html">LabSymbol</a> * Scope::addCodeLabel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a code label at the given address in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<p>A <a class="el" href="classLabSymbol.html" title="A Symbol that labels code internal to a function.">LabSymbol</a> is created and mapped to the given address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address to map to </td></tr>
    <tr><td class="paramname">nm</td><td>is the name of the symbol/label </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classLabSymbol.html" title="A Symbol that labels code internal to a function.">LabSymbol</a> </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#a03a0309ce54c25e56871edbfdfe25675">addMapPoint()</a>, <a class="el" href="classScope.html#a66d3198f4bd28cf9e8a2a6bc00d065d8">addSymbolInternal()</a>, <a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">glb</a>, <a class="el" href="classArchitecture.html#a69348906c7601efa002f1f1365decda9">Architecture::printMessage()</a>, and <a class="el" href="classScope.html#af50dcbdbad011571fc24398781a2bab2">queryContainer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeGhidra.html#a81328af0bc4954612d1e107e592a246a">ScopeGhidra::findCodeLabel()</a>.</p>

</div>
</div>
<a id="a5d3b5f792b07b023d43309472cd6f4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3b5f792b07b023d43309472cd6f4d9">&#9670;&nbsp;</a></span>addDynamicMapInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a>* Scope::addDynamicMapInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>exfl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRangeList.html">RangeList</a> &amp;&#160;</td>
          <td class="paramname"><em>uselim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> given a dynamic hash. </p>
<p>The <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> is specified in terms of a <b>hash</b> and <b>usepoint</b>, which describe how to find the temporary <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> holding the symbol value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> being mapped </td></tr>
    <tr><td class="paramname">exfl</td><td>are any boolean <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> properties </td></tr>
    <tr><td class="paramname">hash</td><td>is the given dynamic hash </td></tr>
    <tr><td class="paramname">off</td><td>is the byte offset of the new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> (relative to the whole <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>) </td></tr>
    <tr><td class="paramname">sz</td><td>is the number of bytes occupied by the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </td></tr>
    <tr><td class="paramname">uselim</td><td>is the given <b>usepoint</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#abd7bd6f565efa0e9eb5a7415fab0fca5">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a1344895b80746ac226f1b86029c17e05">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#af42668b79a23d2e4e67f54e2185a2b58">addDynamicSymbol()</a>, and <a class="el" href="classScope.html#ab93f6dfecb978ac52b56f967896ca758">addMap()</a>.</p>

</div>
</div>
<a id="af42668b79a23d2e4e67f54e2185a2b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42668b79a23d2e4e67f54e2185a2b58">&#9670;&nbsp;</a></span>addDynamicSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * Scope::addDynamicSymbol </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>caddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a dynamically mapped <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> attached to a specific data-flow. </p>
<p>The <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is created and mapped to a dynamic <em>hash</em> and a code address where the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is being used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the name of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
    <tr><td class="paramname">ct</td><td>is the data-type of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
    <tr><td class="paramname">caddr</td><td>is the code address where the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is being used </td></tr>
    <tr><td class="paramname">hash</td><td>is the dynamic hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#a5d3b5f792b07b023d43309472cd6f4d9">addDynamicMapInternal()</a>, <a class="el" href="classScope.html#a66d3198f4bd28cf9e8a2a6bc00d065d8">addSymbolInternal()</a>, <a class="el" href="classAddress.html#a208ce07ecf27e5c148d8395913831c2a">Address::getOffset()</a>, <a class="el" href="classAddress.html#a2e1cbf153126eebf5ba92f52c5dbc6a8">Address::getSpace()</a>, <a class="el" href="classRangeList.html#ab0ab4e29f9f3b6b096e985d99daac763">RangeList::insertRange()</a>, <a class="el" href="classAddress.html#a90ea7ea47a048afa95a14709e704d876">Address::isInvalid()</a>, and <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca6512f0039b21ce7e6586f14d3b1bd9a2">Varnode::mapped</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncdata.html#aa15db3d569027578de69c065fc607c63">Funcdata::buildDynamicSymbol()</a>.</p>

</div>
</div>
<a id="a648715fd4a06419df21ecdc060ff2911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648715fd4a06419df21ecdc060ff2911">&#9670;&nbsp;</a></span>addExternalRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> * Scope::addExternalRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>refaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <em>external</em> <em>reference</em> at the given address in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a></p>
<p>An <a class="el" href="classExternRefSymbol.html" title="A function Symbol referring to an external location.">ExternRefSymbol</a> is created and mapped to the given address and stores a reference address to the actual function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address to map the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> to </td></tr>
    <tr><td class="paramname">refaddr</td><td>is the reference address </td></tr>
    <tr><td class="paramname">nm</td><td>is the name of the symbol/function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classExternRefSymbol.html" title="A function Symbol referring to an external location.">ExternRefSymbol</a> </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#a03a0309ce54c25e56871edbfdfe25675">addMapPoint()</a>, <a class="el" href="classScope.html#a66d3198f4bd28cf9e8a2a6bc00d065d8">addSymbolInternal()</a>, <a class="el" href="classSymbol.html#ae27fc3f664b0edbd5cedf859acfb0707">Symbol::flags</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca0d7f659884b50f2fa71a3d700a729258">Varnode::readonly</a>, and <a class="el" href="classSymbolEntry.html#ab23a87a324831b27ff4d5030175a08c7">SymbolEntry::symbol</a>.</p>

</div>
</div>
<a id="a8f7f8bc9f073a957d43298394cac0678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7f8bc9f073a957d43298394cac0678">&#9670;&nbsp;</a></span>addFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctionSymbol.html">FunctionSymbol</a> * Scope::addFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a function <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> at the given address in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<p>The <a class="el" href="classFunctionSymbol.html" title="A Symbol representing an executable function.">FunctionSymbol</a> is created and mapped to the given address. A <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function.">Funcdata</a> object is only created once <a class="el" href="classFunctionSymbol.html#ab54ed780e0dd1abdc9447c2e772114fb" title="Get the underlying Funcdata object.">FunctionSymbol::getFunction()</a> is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the entry address of the function </td></tr>
    <tr><td class="paramname">nm</td><td>is the name of the function, within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classFunctionSymbol.html" title="A Symbol representing an executable function.">FunctionSymbol</a> object </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#a03a0309ce54c25e56871edbfdfe25675">addMapPoint()</a>, <a class="el" href="classScope.html#a66d3198f4bd28cf9e8a2a6bc00d065d8">addSymbolInternal()</a>, <a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">glb</a>, <a class="el" href="classArchitecture.html#aa5c79b6eca1b3c98884bb53c90bf417d">Architecture::min_funcsymbol_size</a>, <a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, <a class="el" href="classArchitecture.html#a69348906c7601efa002f1f1365decda9">Architecture::printMessage()</a>, and <a class="el" href="classScope.html#af50dcbdbad011571fc24398781a2bab2">queryContainer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#ac6c95a933f8a42d6d1d46d8663a793a2">Architecture::readLoaderSymbols()</a>.</p>

</div>
</div>
<a id="ab93f6dfecb978ac52b56f967896ca758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93f6dfecb978ac52b56f967896ca758">&#9670;&nbsp;</a></span>addMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> * Scope::addMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymbolEntry.html">SymbolEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate a <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> into the range maps. </p>
<p>The mapping is given as an unintegrated <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> object. Memory may be specified in terms of join addresses, which this method must unravel. The <b>offset</b>, <b>size</b>, and <b>extraflags</b> fields of the <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> are not used. In particular, the <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> is assumed to map the entire <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>is the given <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> which has been fully integrated </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#a5d3b5f792b07b023d43309472cd6f4d9">addDynamicMapInternal()</a>, <a class="el" href="classScope.html#aec0451f131ea214a174e00a434be36e9">addMapInternal()</a>, <a class="el" href="classSymbolEntry.html#aa07b2446b764db960d44aa352405154d">SymbolEntry::addr</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca7d4bde53093050741edab33ff1b80b0a">Varnode::addrtied</a>, <a class="el" href="classAddrSpaceManager.html#adff0f9e662ebffdf724dca82b6b544bb">AddrSpaceManager::findJoin()</a>, <a class="el" href="classSymbol.html#ae27fc3f664b0edbd5cedf859acfb0707">Symbol::flags</a>, <a class="el" href="structVarnodeData.html#a815490509cf832fbb9dc45214dd33c8e">VarnodeData::getAddr()</a>, <a class="el" href="classSymbol.html#a2140bc57fb92842c2d1cc8526ef08cf1">Symbol::getBytesConsumed()</a>, <a class="el" href="classAddress.html#a208ce07ecf27e5c148d8395913831c2a">Address::getOffset()</a>, <a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">glb</a>, <a class="el" href="classSymbolEntry.html#ae4b71d5e19b9cdf9466a44141a80b9b5">SymbolEntry::hash</a>, <a class="el" href="classAddress.html#aec0c5e9a64d45b7e913e61eb064bcc2d">Address::isBigEndian()</a>, <a class="el" href="classAddress.html#a90ea7ea47a048afa95a14709e704d876">Address::isInvalid()</a>, <a class="el" href="classAddress.html#ae0e5cdee35b24c75adcbfc444e6e5be6">Address::isJoin()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca6512f0039b21ce7e6586f14d3b1bd9a2">Varnode::mapped</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca952005b91ba1b04e4d431eecb1309112">Varnode::persist</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8caeb173e0f2c992f3b7a15fbede0805629">Varnode::precishi</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca2e26b7277dd6b11db8498c07974935d1">Varnode::precislo</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, <a class="el" href="classSymbolEntry.html#ab23a87a324831b27ff4d5030175a08c7">SymbolEntry::symbol</a>, <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">Architecture::symboltab</a>, and <a class="el" href="classSymbolEntry.html#a1d0818cc564a52f4a06cd49042f1ebd0">SymbolEntry::uselimit</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#a03a0309ce54c25e56871edbfdfe25675">addMapPoint()</a>, and <a class="el" href="classScope.html#a421f1b66be24bd5a20c77761e7a51268">addMapSym()</a>.</p>

</div>
</div>
<a id="aec0451f131ea214a174e00a434be36e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0451f131ea214a174e00a434be36e9">&#9670;&nbsp;</a></span>addMapInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a>* Scope::addMapInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>exfl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRangeList.html">RangeList</a> &amp;&#160;</td>
          <td class="paramname"><em>uselim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> given a memory range. </p>
<p>The <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> is specified in terms of a memory range and <b>usepoint</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> being mapped </td></tr>
    <tr><td class="paramname">exfl</td><td>are any boolean <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> properties specific to the memory range </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the given memory range </td></tr>
    <tr><td class="paramname">off</td><td>is the byte offset of the new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> (relative to the whole <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>) </td></tr>
    <tr><td class="paramname">sz</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">uselim</td><td>is the given <b>usepoint</b> (which may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a3b6e20fcb0624056020f2fc20d0a06ee">ScopeInternal</a>, <a class="el" href="classScopeGhidraNamespace.html#aa172c9a51885ac46f20967d68ca2a24c">ScopeGhidraNamespace</a>, and <a class="el" href="classScopeGhidra.html#addc5b238357161e4661c8616312cef12">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#ab93f6dfecb978ac52b56f967896ca758">addMap()</a>.</p>

</div>
</div>
<a id="a03a0309ce54c25e56871edbfdfe25675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a0309ce54c25e56871edbfdfe25675">&#9670;&nbsp;</a></span>addMapPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> * Scope::addMapPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> to a specific address. </p>
<p>Create a new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> that maps the whole <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> to the given address </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
    <tr><td class="paramname">addr</td><td>is the given address to map to </td></tr>
    <tr><td class="paramname">usepoint</td><td>is a point at which the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is accessed at that address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> representing the new mapping </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#ab93f6dfecb978ac52b56f967896ca758">addMap()</a>, <a class="el" href="classSymbolEntry.html#aa07b2446b764db960d44aa352405154d">SymbolEntry::addr</a>, <a class="el" href="classAddress.html#a208ce07ecf27e5c148d8395913831c2a">Address::getOffset()</a>, <a class="el" href="classAddress.html#a2e1cbf153126eebf5ba92f52c5dbc6a8">Address::getSpace()</a>, <a class="el" href="classRangeList.html#ab0ab4e29f9f3b6b096e985d99daac763">RangeList::insertRange()</a>, <a class="el" href="classAddress.html#a90ea7ea47a048afa95a14709e704d876">Address::isInvalid()</a>, and <a class="el" href="classSymbolEntry.html#a1d0818cc564a52f4a06cd49042f1ebd0">SymbolEntry::uselimit</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#a4dcaf595e4437d91af6a243ef0d49640">addCodeLabel()</a>, <a class="el" href="classScope.html#a648715fd4a06419df21ecdc060ff2911">addExternalRef()</a>, <a class="el" href="classScope.html#a8f7f8bc9f073a957d43298394cac0678">addFunction()</a>, <a class="el" href="classScope.html#a7c79f7f535ba4e819fcf95185896a019">addSymbol()</a>, and <a class="el" href="classScopeInternal.html#a9711a8084e1ac5c4417a4452c96a36b7">ScopeInternal::retypeSymbol()</a>.</p>

</div>
</div>
<a id="a421f1b66be24bd5a20c77761e7a51268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421f1b66be24bd5a20c77761e7a51268">&#9670;&nbsp;</a></span>addMapSym()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * Scope::addMapSym </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a mapped <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> from a &lt;mapsym&gt; XML tag. </p>
<p>A tag describing the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is parsed first, followed by sequences of &lt;addr&gt; or &lt;hash&gt; and &lt;rangelist&gt; which define 1 or more mappings of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> The new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> and <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> mappings are integrated into <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the &lt;mapsym&gt; XML element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#ab93f6dfecb978ac52b56f967896ca758">addMap()</a>, <a class="el" href="classScope.html#a66d3198f4bd28cf9e8a2a6bc00d065d8">addSymbolInternal()</a>, <a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">glb</a>, <a class="el" href="classArchitecture.html#aa5c79b6eca1b3c98884bb53c90bf417d">Architecture::min_funcsymbol_size</a>, <a class="el" href="classArchitecture.html#a69348906c7601efa002f1f1365decda9">Architecture::printMessage()</a>, <a class="el" href="classScope.html#a0172591847f6a1b338ad324f28732f7f">removeSymbol()</a>, <a class="el" href="classSymbolEntry.html#a6117b39bc8d1a12e3cba724dab6dff3f">SymbolEntry::restoreXml()</a>, and <a class="el" href="classSymbol.html#a3266a5752c208bdfa5a28e792de67604">Symbol::restoreXml()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeGhidra.html#a3f1694263c1bbb543c387b4c182872b0">ScopeGhidra::dump2Cache()</a>, and <a class="el" href="classScopeInternal.html#ad79bd78299b2bea6c0f4221682e81b07">ScopeInternal::restoreXml()</a>.</p>

</div>
</div>
<a id="a33adf8d24b5e22aa420b840b817131e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33adf8d24b5e22aa420b840b817131e0">&#9670;&nbsp;</a></span>addRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::addRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a memory range to the ownership of <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the address space of the range </td></tr>
    <tr><td class="paramname">first</td><td>is the offset of the first byte in the range </td></tr>
    <tr><td class="paramname">last</td><td>is the offset of the last byte in the range </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classScopeGhidra.html#ac5fb1f31ee095f0bb37b5181ab3af192">ScopeGhidra</a>.</p>

<p class="reference">References <a class="el" href="classRangeList.html#ab0ab4e29f9f3b6b096e985d99daac763">RangeList::insertRange()</a>, and <a class="el" href="classScope.html#a588172ad2f5c11ee6e9f793c2e599071">rangetree</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeGhidra.html#ac5fb1f31ee095f0bb37b5181ab3af192">ScopeGhidra::addRange()</a>, and <a class="el" href="classDatabase.html#a3ad165aa6ec64f417376669625d31c69">Database::addRange()</a>.</p>

</div>
</div>
<a id="a96e7adcd07f0dbd9cf1777e2b3be9fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e7adcd07f0dbd9cf1777e2b3be9fe2">&#9670;&nbsp;</a></span>addSymbol() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * Scope::addSymbol </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> <em>without</em> mapping it to an address. </p>
<p>The <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is created and added to any name map, but no <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> objects are created for it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the name of the new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
    <tr><td class="paramname">ct</td><td>is a data-type to assign to the new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> object </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#a66d3198f4bd28cf9e8a2a6bc00d065d8">addSymbolInternal()</a>, and <a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>.</p>

</div>
</div>
<a id="a7c79f7f535ba4e819fcf95185896a019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c79f7f535ba4e819fcf95185896a019">&#9670;&nbsp;</a></span>addSymbol() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> * Scope::addSymbol </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> to <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>, given a name, data-type, and a single mapping. </p>
<p>The <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> object will be created with the given name and data-type. A single mapping (<a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a>) will be created for the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> based on a given storage address for the symbol and an address for code that accesses the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> at that storage location. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the new name of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
    <tr><td class="paramname">ct</td><td>is the data-type of the new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> storage </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point accessing that storage (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> matching the new mapping </dd></dl>

<p>Reimplemented in <a class="el" href="classScopeGhidra.html#abb80f5f1b2391d5865f3c75ec1e03644">ScopeGhidra</a>.</p>

<p class="reference">References <a class="el" href="classScope.html#a03a0309ce54c25e56871edbfdfe25675">addMapPoint()</a>, <a class="el" href="classScope.html#a66d3198f4bd28cf9e8a2a6bc00d065d8">addSymbolInternal()</a>, and <a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeGhidra.html#abb80f5f1b2391d5865f3c75ec1e03644">ScopeGhidra::addSymbol()</a>, <a class="el" href="classScopeLocal.html#a9776a5769d4422c1e9b9d2dd7c6dfd06">ScopeLocal::createEntry()</a>, <a class="el" href="classScopeLocal.html#adf7560cd37bccfb315c6a54a78506c46">ScopeLocal::fakeInputSymbols()</a>, <a class="el" href="classFuncdata.html#afbb3bc5ac9e2c09eda544db34b8f5879">Funcdata::linkSymbol()</a>, <a class="el" href="classFuncdata.html#aed6aefa7321e887e3b759de94e4d3d4f">Funcdata::mapGlobals()</a>, and <a class="el" href="classProtoStoreSymbol.html#af9e24d39271ea90fc074010e4b24a2b1">ProtoStoreSymbol::setInput()</a>.</p>

</div>
</div>
<a id="a66d3198f4bd28cf9e8a2a6bc00d065d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d3198f4bd28cf9e8a2a6bc00d065d8">&#9670;&nbsp;</a></span>addSymbolInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scope::addSymbolInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> into the name map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the preconstructed <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#af252bcb614abeea3af1750442087304a">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#add7a72e8defe6b25f13fc4ab81781a36">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#a4dcaf595e4437d91af6a243ef0d49640">addCodeLabel()</a>, <a class="el" href="classScope.html#af42668b79a23d2e4e67f54e2185a2b58">addDynamicSymbol()</a>, <a class="el" href="classScope.html#a648715fd4a06419df21ecdc060ff2911">addExternalRef()</a>, <a class="el" href="classScope.html#a8f7f8bc9f073a957d43298394cac0678">addFunction()</a>, <a class="el" href="classScope.html#a421f1b66be24bd5a20c77761e7a51268">addMapSym()</a>, and <a class="el" href="classScope.html#a96e7adcd07f0dbd9cf1777e2b3be9fe2">addSymbol()</a>.</p>

</div>
</div>
<a id="a267c957503a77a651230beedbc9f27ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267c957503a77a651230beedbc9f27ec">&#9670;&nbsp;</a></span>attachScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::attachScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach a new child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> to <b>this</b>. </p>
<p>Attach the child as an immediate sub-scope of <b>this</b>. Take responsibility of the child's memory: the child will be freed when this is freed. May throw <a class="el" href="structRecovError.html" title="A generic recoverable error.">RecovError</a> if there is a duplicate name issue </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>is the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> to make a child </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classScope.html#a10a6abc6a7c8631a1309d74ce9aa85e8">children</a>, <a class="el" href="classScope.html#a6e0c1eab94766936cb73686e39b2ab6d">getFullName()</a>, <a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, <a class="el" href="classScope.html#a2df68cab954d40b15c9e45bca324fcbc">parent</a>, and <a class="el" href="classScope.html#ad67040159cc1bea1399308eda8aa0f22">uniqueId</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDatabase.html#a1bc096166a8cfde3d77229c9e38bfabf">Database::attachScope()</a>.</p>

</div>
</div>
<a id="a1b7dbb309986d8622ec0721f7a80bda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7dbb309986d8622ec0721f7a80bda1">&#9670;&nbsp;</a></span>buildDefaultName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Scope::buildDefaultName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4 &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a default name for the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>. </p>
<p>Create default name given information in the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> and possibly a representative <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a>. This method extracts the crucial properties and then uses the buildVariableName method to construct the actual name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> to name </td></tr>
    <tr><td class="paramname">base</td><td>is an index (which may get updated) used to uniquify the name </td></tr>
    <tr><td class="paramname">vn</td><td>is an optional (may be null) <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> representative of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the default name </dd></dl>

<p class="reference">References <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca7d4bde53093050741edab33ff1b80b0a">Varnode::addrtied</a>, <a class="el" href="classScope.html#a925baecb33b6f0d9212e42c1b48a64ba">buildVariableName()</a>, <a class="el" href="classScope.html#a72f6c31e73c46216482a6902d22b3330">fd</a>, <a class="el" href="classSymbolEntry.html#a856e7005f430c40b54c97ee886476e8a">SymbolEntry::getFirstUseAddress()</a>, <a class="el" href="classVarnode.html#a99192dea44cf05e3c619f65cbde949c7">Varnode::getHigh()</a>, <a class="el" href="classSymbol.html#a0f86b85ac74fc36f1df80b48b658af1c">Symbol::getMapEntry()</a>, <a class="el" href="classVarnode.html#a9eab83050278fb3bd44d6179154e38de">Varnode::getUsePoint()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca9c9363556459d8828a5ab58c370ccd2e">Varnode::input</a>, <a class="el" href="classVarnode.html#a61fd3ac206edbb80a9c42f3b69755b61">Varnode::isAddrTied()</a>, and <a class="el" href="classAddress.html#a90ea7ea47a048afa95a14709e704d876">Address::isInvalid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classActionNameVars.html#aac0b5f8eea942d73f9fcdb4fca44f1bd">ActionNameVars::apply()</a>, and <a class="el" href="classScopeInternal.html#ab78d1338500ed2ef280cdf4580e8f7dc">ScopeInternal::assignDefaultNames()</a>.</p>

</div>
</div>
<a id="ac47d5c1c949be84a27a138be0febacb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47d5c1c949be84a27a138be0febacb2">&#9670;&nbsp;</a></span>buildUndefinedName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string Scope::buildUndefinedName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a formal <b>undefined</b> name, used internally when a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is not given a name. </p>
<dl class="section return"><dt>Returns</dt><dd>a special internal name that won't collide with other names in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a17225ae39210e0dbf1efb1a3ee847d72">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a25f55a3495b08a4caafaaeb5c1cf8bed">ScopeGhidra</a>.</p>

</div>
</div>
<a id="a925baecb33b6f0d9212e42c1b48a64ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925baecb33b6f0d9212e42c1b48a64ba">&#9670;&nbsp;</a></span>buildVariableName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string Scope::buildVariableName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4 &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an address and data-type, build a suitable generic symbol name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
    <tr><td class="paramname">pc</td><td>is the address at which the name is getting used </td></tr>
    <tr><td class="paramname">ct</td><td>is a data-type used to inform the name </td></tr>
    <tr><td class="paramname">index</td><td>is a reference to an index used to make the name unique, which will be updated </td></tr>
    <tr><td class="paramname">flags</td><td>are boolean properties of the variable we need the name for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new variable name </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a6009aeaf0d3973344438fb412adccd00">ScopeInternal</a>, <a class="el" href="classScopeLocal.html#a7c86528490f519a64d44ae6dc8438393">ScopeLocal</a>, and <a class="el" href="classScopeGhidra.html#a4a8ab1c82c0d5101e7e2f5cdd5cc8268">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#a1b7dbb309986d8622ec0721f7a80bda1">buildDefaultName()</a>, and <a class="el" href="classFuncdata.html#aed6aefa7321e887e3b759de94e4d3d4f">Funcdata::mapGlobals()</a>.</p>

</div>
</div>
<a id="a4a0b94bbfa2b7a8391f8be410547cc67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0b94bbfa2b7a8391f8be410547cc67">&#9670;&nbsp;</a></span>detachScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::detachScope </td>
          <td>(</td>
          <td class="paramtype">ScopeMap::iterator&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detach a child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> from <b>this</b>. </p>
<p>The indicated child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> is deleted </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>points to the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> to delete </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classScope.html#a10a6abc6a7c8631a1309d74ce9aa85e8">children</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDatabase.html#aa7b4011d64dc04148fbf342819f38da5">Database::deleteScope()</a>, and <a class="el" href="classDatabase.html#a7fcfc328de0a3f2d4ec8abdd6428213a">Database::deleteSubScopes()</a>.</p>

</div>
</div>
<a id="aaef5f179b42a9696fd077dbc7144ecc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef5f179b42a9696fd077dbc7144ecc2">&#9670;&nbsp;</a></span>discoverScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classScope.html">Scope</a> * Scope::discoverScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the owning <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> of a given memory range. </p>
<p>Discover a sub-scope or containing <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> of <b>this</b>, that <em>owns</em> the given memory range at a specific <b>usepoint</b>. Note that ownership does not necessarily mean there is a known symbol there. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the memory range </td></tr>
    <tr><td class="paramname">sz</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is a point at which the memory is getting accesses </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">glb</a>, <a class="el" href="classScope.html#a4fcaec6d7678dabe548680747d843a52">inScope()</a>, <a class="el" href="classAddress.html#a8ef20a60dfb144bb91c466432e377eb5">Address::isConstant()</a>, <a class="el" href="classDatabase.html#ab3840564f424238dd3a498fdb1a02644">Database::mapScope()</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">Architecture::symboltab</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncdata.html#aed6aefa7321e887e3b759de94e4d3d4f">Funcdata::mapGlobals()</a>, and <a class="el" href="classProtoStoreSymbol.html#af9e24d39271ea90fc074010e4b24a2b1">ProtoStoreSymbol::setInput()</a>.</p>

</div>
</div>
<a id="aae4ea61f9a55ddfc9defd8548654c8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4ea61f9a55ddfc9defd8548654c8e5">&#9670;&nbsp;</a></span>findAddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a>* Scope::findAddr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> at a given address and <b>usepoint</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point at which the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is accessed (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> or NULL </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#ac256d087718065edb1c3a96fbfdf7a33">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a444989f8c48787af5df27c2a8b234fd3">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#a598536926659c304d35346aba6d79fa2">stackAddr()</a>.</p>

</div>
</div>
<a id="a979222d28577e6e8d07e35f12d38bff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979222d28577e6e8d07e35f12d38bff7">&#9670;&nbsp;</a></span>findByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scope::findByName </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> by name within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<p>If there are multiple Symbols with the same name, all are passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the name to search for </td></tr>
    <tr><td class="paramname">res</td><td>will contain any matching Symbols </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a06599bc2d7c1ccfd18f0e91a5ee956ca">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a26072ceb4215a022050d12b9487e3e87">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#ae7d2e4eeed5fbc77e0477936f60cfde5">queryByName()</a>.</p>

</div>
</div>
<a id="ab679fe786be2fb949af78054cb2041a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab679fe786be2fb949af78054cb2041a8">&#9670;&nbsp;</a></span>findClosestFit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a>* Scope::findClosestFit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> which is the closest fit to the given memory range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given memory range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point at which the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is accessed (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> or NULL </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a27135ecccccc6784b292a354d6801289">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#ace9d46c27a627260abfe9cce2724267b">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#a4de9b51d8c57e33e9394512489539664">stackClosestFit()</a>.</p>

</div>
</div>
<a id="af4bac52b9d64974b87432c0379cc38c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4bac52b9d64974b87432c0379cc38c6">&#9670;&nbsp;</a></span>findCodeLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLabSymbol.html">LabSymbol</a>* Scope::findCodeLabel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a label <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> at the given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classLabSymbol.html" title="A Symbol that labels code internal to a function.">LabSymbol</a> or NULL </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a602029280a3bc0dac8aac016ec934d5b">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a81328af0bc4954612d1e107e592a246a">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#a26992d3bf69e5c2c02e57943b1355f0d">stackCodeLabel()</a>.</p>

</div>
</div>
<a id="a609fc1ef47d047717da65827e025cfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609fc1ef47d047717da65827e025cfdd">&#9670;&nbsp;</a></span>findContainer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a>* Scope::findContainer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the smallest <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> containing the given memory range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given memory range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point at which the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is accessed (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> or NULL </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#ae1eedf2f27fd8b0a7431568c4e4e2994">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a6b5b1b303d3d6adf93822224aa7bd19f">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#a63e00dad81427a8595cf7bf13d8e1e0d">stackContainer()</a>.</p>

</div>
</div>
<a id="ab269032369c349fe61278304791e0130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab269032369c349fe61278304791e0130">&#9670;&nbsp;</a></span>findDistinguishingScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classScope.html">Scope</a> * Scope::findDistinguishingScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find first ancestor of <b>this</b> not shared by given scope. </p>
<p>Any two scopes share at least the <em>global</em> scope as a common ancestor. We find the first scope that is <em>not</em> in common. The scope returned will always be an ancestor of <b>this</b>. If <b>this</b> is an ancestor of the other given scope, then null is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op2</td><td>is the other given <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first ancestor <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> that is not in common or null </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#aea425f0c244ce263988024ec0eb537ae">getScopePath()</a>, and <a class="el" href="classScope.html#a2df68cab954d40b15c9e45bca324fcbc">parent</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSymbol.html#ac41dd1d2365557f0e8d66bdb992a0d45">Symbol::getResolutionDepth()</a>.</p>

</div>
</div>
<a id="af69e0f77b621a3ba6436f8a1c0010d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69e0f77b621a3ba6436f8a1c0010d1c">&#9670;&nbsp;</a></span>findExternalRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a>* Scope::findExternalRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an <em>external</em> <em>reference</em> at the given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classExternRefSymbol.html" title="A function Symbol referring to an external location.">ExternRefSymbol</a> or NULL </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a7e440965cfb5642bcc751a622e5ec58d">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a0de8e7d9e97f48516f8bb7b5edd4dfcd">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#a44898a2294de74a77dd21583ca6254e2">stackExternalRef()</a>.</p>

</div>
</div>
<a id="a2c621196f6fdb4b8ce4ee1f3dc953107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c621196f6fdb4b8ce4ee1f3dc953107">&#9670;&nbsp;</a></span>findFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFuncdata.html">Funcdata</a>* Scope::findFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the function starting at the given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given starting address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function.">Funcdata</a> object or NULL </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a03a52c629c51ad660eec8d10cf7f92aa">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a8bc17a80d5b2bd69f7900be5b55a382a">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#a1e0d2e90ee5d4bc7e3dc761390be5e47">stackFunction()</a>.</p>

</div>
</div>
<a id="a3395b6194a59515caa1ede92fd6ac511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3395b6194a59515caa1ede92fd6ac511">&#9670;&nbsp;</a></span>findOverlap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a>* Scope::findOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find first <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> overlapping the given memory range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an overlapping <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> or NULL if none exists </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a3c241113085be88a74f73d2431de72f3">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#afb59d45c8fa404fe023e054b255d5a3d">ScopeGhidra</a>.</p>

</div>
</div>
<a id="a909e15a7a96c9b402855b56b6bfdbd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909e15a7a96c9b402855b56b6bfdbd9f">&#9670;&nbsp;</a></span>getCategorySize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int4 Scope::getCategorySize </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>cat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of Symbols in the given category. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cat</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> <em>category</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number in that <em>category</em> </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a4ccbbc37afa4eee7c6cce98dbd3a5bff">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a4c6c26ca7dd639659313e8fe86d798c8">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classProtoStoreSymbol.html#aa36f84c14205c90e18708858a3ae4ae5">ProtoStoreSymbol::clearInput()</a>, and <a class="el" href="classProtoStoreSymbol.html#a26d8910259e3965c4491048935c277ec">ProtoStoreSymbol::getNumInputs()</a>.</p>

</div>
</div>
<a id="a491a168d7ea71f00da419dd864901ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491a168d7ea71f00da419dd864901ccb">&#9670;&nbsp;</a></span>getCategorySymbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbol.html">Symbol</a>* Scope::getCategorySymbol </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>cat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> by index within a specific <em>category</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cat</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> <em>category</em> </td></tr>
    <tr><td class="paramname">ind</td><td>is the index (within the category) of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the indicated <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> or NULL if no <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> with that index exists </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#af0414fde624b56947bfa25863ea1a01e">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#aa3b3e331ed319e74af4a5927f7e70660">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classProtoStoreSymbol.html#aa36f84c14205c90e18708858a3ae4ae5">ProtoStoreSymbol::clearInput()</a>, <a class="el" href="classProtoStoreSymbol.html#a55788c21f1b3699731f1956d75ef1d45">ProtoStoreSymbol::getInput()</a>, and <a class="el" href="classProtoStoreSymbol.html#af9e24d39271ea90fc074010e4b24a2b1">ProtoStoreSymbol::setInput()</a>.</p>

</div>
</div>
<a id="a0d0befa1009748f0af39a1e6b7704b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0befa1009748f0af39a1e6b7704b7b">&#9670;&nbsp;</a></span>getNameSegments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::getNameSegments </td>
          <td>(</td>
          <td class="paramtype">vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the fullname of <b>this</b> in segments. </p>
<p>Put the names of <b>this</b> and all its parent Scopes into an array in order. The name of the first entry will generally be the name of the global <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>is the array in which to store the names </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, and <a class="el" href="classScope.html#a2df68cab954d40b15c9e45bca324fcbc">parent</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeInternal.html#af73cb738b4a29cf9aa076ce382ff110f">ScopeInternal::saveXml()</a>.</p>

</div>
</div>
<a id="aea425f0c244ce263988024ec0eb537ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea425f0c244ce263988024ec0eb537ae">&#9670;&nbsp;</a></span>getScopePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::getScopePath </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classScope.html">Scope</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ordered list of parent scopes to <b>this</b>. </p>
<p>Put the parent scopes of <b>this</b> into an array in order, starting with the global scope. This scope itself will not be in the array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>is storage for the array of scopes </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classScope.html#a2df68cab954d40b15c9e45bca324fcbc">parent</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#ab269032369c349fe61278304791e0130">findDistinguishingScope()</a>.</p>

</div>
</div>
<a id="a4fcaec6d7678dabe548680747d843a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcaec6d7678dabe548680747d843a52">&#9670;&nbsp;</a></span>inScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Scope::inScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query if the given range is owned by <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<p>All bytes in the range must be owned, and ownership can be informed by particular code that is accessing the range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the code address at which the given range is being accessed (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> owns the memory range </dd></dl>

<p class="reference">References <a class="el" href="classRangeList.html#a61b4034c6930b45dd8d365c382c73b86">RangeList::inRange()</a>, and <a class="el" href="classScope.html#a588172ad2f5c11ee6e9f793c2e599071">rangetree</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#aaef5f179b42a9696fd077dbc7144ecc2">discoverScope()</a>, <a class="el" href="classScope.html#a598536926659c304d35346aba6d79fa2">stackAddr()</a>, <a class="el" href="classScope.html#a4de9b51d8c57e33e9394512489539664">stackClosestFit()</a>, <a class="el" href="classScope.html#a26992d3bf69e5c2c02e57943b1355f0d">stackCodeLabel()</a>, <a class="el" href="classScope.html#a63e00dad81427a8595cf7bf13d8e1e0d">stackContainer()</a>, <a class="el" href="classScope.html#a1e0d2e90ee5d4bc7e3dc761390be5e47">stackFunction()</a>, and <a class="el" href="classFuncdata.html#aca583e76acc0a61bc30bd32461d25aee">Funcdata::syncVarnodesWithSymbols()</a>.</p>

</div>
</div>
<a id="a9eeda63eacff8611321ba44508ccef3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eeda63eacff8611321ba44508ccef3e">&#9670;&nbsp;</a></span>isNameUsed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Scope::isNameUsed </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given name is used within <b>this</b> scope. </p>
<p>Only <b>this</b> scope is checked. If one or more symbols exist with the given name, <b>true</b> is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the given name to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the name is used within <b>this</b> scope </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a196c644b8f12e6bfe8ff1ea2f467fc8b">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a0f59b75cfddbd3537c4e2087ce0f22aa">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classSymbol.html#ac41dd1d2365557f0e8d66bdb992a0d45">Symbol::getResolutionDepth()</a>, and <a class="el" href="classScope.html#ad84da27186e9a57fa4c8ae1f6ca02744">isNameUsed()</a>.</p>

</div>
</div>
<a id="ad84da27186e9a57fa4c8ae1f6ca02744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84da27186e9a57fa4c8ae1f6ca02744">&#9670;&nbsp;</a></span>isNameUsed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Scope::isNameUsed </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the given name in use within given scope path. </p>
<p>Test for the presence of a symbol with the given name in either <b>this</b> scope or an ancestor scope up to but not including the given terminating scope. If the name is used <b>true</b> is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the given name to test </td></tr>
    <tr><td class="paramname">op2</td><td>is the terminating ancestor scope (or null) </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classScope.html#a9eeda63eacff8611321ba44508ccef3e">isNameUsed()</a>, <a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, and <a class="el" href="classScope.html#a2df68cab954d40b15c9e45bca324fcbc">parent</a>.</p>

</div>
</div>
<a id="a7b6645d4ce07bea82322ac366b8c6168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6645d4ce07bea82322ac366b8c6168">&#9670;&nbsp;</a></span>isReadOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Scope::isReadOnly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the given memory range marked as <em>read-only</em>. </p>
<p>Check for Symbols relative to <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> that are marked as <em>read-only</em>, and look-up properties of the memory in general. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given memory range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is a point where the range is getting accessed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the memory is marked as <em>read-only</em> </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#a1b8c2c2302eba2666e319a4c18a67d51">queryProperties()</a>, and <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca0d7f659884b50f2fa71a3d700a729258">Varnode::readonly</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRulePtrsubCharConstant.html#ab5a326704b8090e54f8afc9db135fd79">RulePtrsubCharConstant::applyOp()</a>.</p>

</div>
</div>
<a id="a1abf50d101c65af19281910dac990ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abf50d101c65af19281910dac990ca5">&#9670;&nbsp;</a></span>isSubScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Scope::isSubScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this a sub-scope of the given <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<p>Does the given <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> contain <b>this</b> as a sub-scope. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scp</td><td>is the given <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if <b>this</b> is a sub-scope </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#a2df68cab954d40b15c9e45bca324fcbc">parent</a>.</p>

</div>
</div>
<a id="a2e0d945c44f4874743496b2814fbb631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0d945c44f4874743496b2814fbb631">&#9670;&nbsp;</a></span>makeNameUnique()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string Scope::makeNameUnique </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce a version of the given symbol name that won't collide with other names in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the given name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return a unique version of the name </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a193e6fb792e7cad6e451c8ecf2f7e589">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a458977d1e0a9826d5cf7bca487ecf327">ScopeGhidra</a>.</p>

</div>
</div>
<a id="a0a05df4f8df1764859bec8372d64b1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a05df4f8df1764859bec8372d64b1ee">&#9670;&nbsp;</a></span>overrideSizeLockType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::overrideSizeLockType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the data-type of a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> that is <em>sizelocked</em>. </p>
<p>Change (override) the data-type of a <em>sizelocked</em> <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>, while preserving the lock. An exception is thrown if the new data-type doesn't fit the size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the locked <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
    <tr><td class="paramname">ct</td><td>is the data-type to change the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> to </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classSymbol.html#ab760cde69e8bb98988ba37871cb6fd63">Symbol::type</a>.</p>

</div>
</div>
<a id="afc95566b073624a0d12231a8e70bc5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc95566b073624a0d12231a8e70bc5ce">&#9670;&nbsp;</a></span>queryByAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> * Scope::queryByAddr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> with matching address. </p>
<p>Within a sub-scope or containing <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> of <b>this</b>, find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> that is mapped to the given address, where the mapping is valid at a specific <b>usepoint</b>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point at which code accesses that address (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">glb</a>, <a class="el" href="classDatabase.html#ab3840564f424238dd3a498fdb1a02644">Database::mapScope()</a>, <a class="el" href="classScope.html#a598536926659c304d35346aba6d79fa2">stackAddr()</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">Architecture::symboltab</a>.</p>

</div>
</div>
<a id="ae7d2e4eeed5fbc77e0477936f60cfde5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d2e4eeed5fbc77e0477936f60cfde5">&#9670;&nbsp;</a></span>queryByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::queryByName </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look-up symbols by name. </p>
<p>Starting from <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>, look for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> with the given name. If there are no Symbols in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>, recurse into the parent <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. If there are 1 (or more) Symbols matching in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>, add them to the result list </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the name to search for </td></tr>
    <tr><td class="paramname">res</td><td>is the result list </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classScope.html#a979222d28577e6e8d07e35f12d38bff7">findByName()</a>, <a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, <a class="el" href="classScope.html#a2df68cab954d40b15c9e45bca324fcbc">parent</a>, and <a class="el" href="classScope.html#ae7d2e4eeed5fbc77e0477936f60cfde5">queryByName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeGhidra.html#a3f1694263c1bbb543c387b4c182872b0">ScopeGhidra::dump2Cache()</a>, <a class="el" href="classFuncdata.html#aa34c7b2d0d5f4cb28e0a2602d3cba033">Funcdata::findHigh()</a>, <a class="el" href="classScope.html#ae7d2e4eeed5fbc77e0477936f60cfde5">queryByName()</a>, and <a class="el" href="classScope.html#a6f9b49c7da91626fcb1cfacda5236991">queryFunction()</a>.</p>

</div>
</div>
<a id="a88982df383433525505723b19b8aaa13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88982df383433525505723b19b8aaa13">&#9670;&nbsp;</a></span>queryCodeLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLabSymbol.html">LabSymbol</a> * Scope::queryCodeLabel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look-up a code label by address. </p>
<p>Within a sub-scope or containing <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> of <b>this</b>, find a label <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> at the given address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classLabSymbol.html" title="A Symbol that labels code internal to a function.">LabSymbol</a> object, or NULL if it doesn't exist </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">glb</a>, <a class="el" href="classDatabase.html#ab3840564f424238dd3a498fdb1a02644">Database::mapScope()</a>, <a class="el" href="classScope.html#a26992d3bf69e5c2c02e57943b1355f0d">stackCodeLabel()</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">Architecture::symboltab</a>.</p>

</div>
</div>
<a id="af50dcbdbad011571fc24398781a2bab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50dcbdbad011571fc24398781a2bab2">&#9670;&nbsp;</a></span>queryContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> * Scope::queryContainer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the smallest containing <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>. </p>
<p>Within a sub-scope or containing <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> of <b>this</b>, find the smallest <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> that contains a given memory range and can be accessed at a given <b>usepoint</b>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given starting address of the memory range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is a point at which the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is accessed (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> or NULL </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">glb</a>, <a class="el" href="classDatabase.html#ab3840564f424238dd3a498fdb1a02644">Database::mapScope()</a>, <a class="el" href="classScope.html#a63e00dad81427a8595cf7bf13d8e1e0d">stackContainer()</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">Architecture::symboltab</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#a4dcaf595e4437d91af6a243ef0d49640">addCodeLabel()</a>, <a class="el" href="classScope.html#a8f7f8bc9f073a957d43298394cac0678">addFunction()</a>, and <a class="el" href="classFuncdata.html#a736351e8eb6c044fe00deb0cf7e6b5c5">Funcdata::linkSymbolReference()</a>.</p>

</div>
</div>
<a id="a7850e4fd00c5dcc9299e646d13aae3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7850e4fd00c5dcc9299e646d13aae3dc">&#9670;&nbsp;</a></span>queryExternalRefFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFuncdata.html">Funcdata</a> * Scope::queryExternalRefFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look-up a function thru an <em>external</em> <em>reference</em>. </p>
<p>Given an address, search for an <em>external</em> <em>reference</em>. If no <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is found and <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> does not own the address, recurse searching in the parent <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. If an <em>external</em> <em>reference</em> is found, try to resolve the function it refers to and return it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address where an <em>external</em> <em>reference</em> might be </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the referred to <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function.">Funcdata</a> object or NULL if not found </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">glb</a>, <a class="el" href="classDatabase.html#ab3840564f424238dd3a498fdb1a02644">Database::mapScope()</a>, <a class="el" href="classScope.html#af4c45025894f1996ef0f3556752cd997">resolveExternalRefFunction()</a>, <a class="el" href="classScope.html#a44898a2294de74a77dd21583ca6254e2">stackExternalRef()</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">Architecture::symboltab</a>.</p>

</div>
</div>
<a id="a5d6c56240bdb6df2d2670077cf5e08ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6c56240bdb6df2d2670077cf5e08ca">&#9670;&nbsp;</a></span>queryFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFuncdata.html">Funcdata</a> * Scope::queryFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look-up a function by address. </p>
<p>Within a sub-scope or containing <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> of <b>this</b>, find a function starting at the given address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function.">Funcdata</a> object of the matching function, or NULL if it doesn't exist </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">glb</a>, <a class="el" href="classDatabase.html#ab3840564f424238dd3a498fdb1a02644">Database::mapScope()</a>, <a class="el" href="classScope.html#a1e0d2e90ee5d4bc7e3dc761390be5e47">stackFunction()</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">Architecture::symboltab</a>.</p>

</div>
</div>
<a id="a6f9b49c7da91626fcb1cfacda5236991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9b49c7da91626fcb1cfacda5236991">&#9670;&nbsp;</a></span>queryFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFuncdata.html">Funcdata</a> * Scope::queryFunction </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look-up a function by name. </p>
<p>Starting with <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>, find a function with the given name. If there are no Symbols with that name in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> at all, recurse into the parent <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>if the name to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function.">Funcdata</a> object of the matching function, or NULL if it doesn't exist </dd></dl>

<p class="reference">References <a class="el" href="classFunctionSymbol.html#ab54ed780e0dd1abdc9447c2e772114fb">FunctionSymbol::getFunction()</a>, <a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, and <a class="el" href="classScope.html#ae7d2e4eeed5fbc77e0477936f60cfde5">queryByName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeInternal.html#acf54c42b2ce7edfa37f9bf1223bc2840">ScopeInternal::resolveExternalRefFunction()</a>.</p>

</div>
</div>
<a id="a1b8c2c2302eba2666e319a4c18a67d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8c2c2302eba2666e319a4c18a67d51">&#9670;&nbsp;</a></span>queryProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> * Scope::queryProperties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 &amp;&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> or properties at the given address. </p>
<p>Similarly to <a class="el" href="classScope.html#af50dcbdbad011571fc24398781a2bab2" title="Find the smallest containing Symbol.">queryContainer()</a>, this searches for the smallest containing <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>, but whether a known <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is found or not, boolean properties associated with the memory range are also search for and passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is a point at which the memory range is accessed (may be <em>invalid</em>) </td></tr>
    <tr><td class="paramname">flags</td><td>is a reference used to pass back the boolean properties of the memory range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the smallest <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> containing the range, or NULL </dd></dl>

<p class="reference">References <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca7d4bde53093050741edab33ff1b80b0a">Varnode::addrtied</a>, <a class="el" href="classSymbolEntry.html#a2a9a19cc7c6bfa573fd244bcc061a4a4">SymbolEntry::getAllFlags()</a>, <a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">glb</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca6512f0039b21ce7e6586f14d3b1bd9a2">Varnode::mapped</a>, <a class="el" href="classDatabase.html#ab3840564f424238dd3a498fdb1a02644">Database::mapScope()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca952005b91ba1b04e4d431eecb1309112">Varnode::persist</a>, <a class="el" href="classScope.html#a63e00dad81427a8595cf7bf13d8e1e0d">stackContainer()</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">Architecture::symboltab</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeLocal.html#adf7560cd37bccfb315c6a54a78506c46">ScopeLocal::fakeInputSymbols()</a>, <a class="el" href="classScope.html#a7b6645d4ce07bea82322ac366b8c6168">isReadOnly()</a>, <a class="el" href="classFuncdata.html#afbb3bc5ac9e2c09eda544db34b8f5879">Funcdata::linkSymbol()</a>, <a class="el" href="classFuncdata.html#aed6aefa7321e887e3b759de94e4d3d4f">Funcdata::mapGlobals()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">Funcdata::newVarnode()</a>, <a class="el" href="classFuncdata.html#a100e6704e4c245e076170268d31b47ec">Funcdata::newVarnodeOut()</a>, and <a class="el" href="classFuncdata.html#a4982d533e8bed6200e2b35a153774553">Funcdata::setVarnodeProperties()</a>.</p>

</div>
</div>
<a id="ad1b4a9faa5d12ef3b0be55810dac6d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b4a9faa5d12ef3b0be55810dac6d35">&#9670;&nbsp;</a></span>removeRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::removeRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a memory range from the ownership of <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the address space of the range </td></tr>
    <tr><td class="paramname">first</td><td>is the offset of the first byte in the range </td></tr>
    <tr><td class="paramname">last</td><td>is the offset of the last byte in the range </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classScopeGhidra.html#a6a418b9b4ee25fbda17df511c61bebb8">ScopeGhidra</a>.</p>

<p class="reference">References <a class="el" href="classScope.html#a588172ad2f5c11ee6e9f793c2e599071">rangetree</a>, and <a class="el" href="classRangeList.html#a25b0feea38aa56d2502426d117dccb31">RangeList::removeRange()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDatabase.html#a4db50bb44cfc56d4102f102c0ddbf423">Database::removeRange()</a>.</p>

</div>
</div>
<a id="a4af52229967e3a507a5367e14a298142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af52229967e3a507a5367e14a298142">&#9670;&nbsp;</a></span>resetSizeLockType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::resetSizeLockType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>'s <em>size-locked</em> data-type. </p>
<p>Replace any overriding data-type type with the locked UNKNOWN type of the correct size. The data-type is <em>cleared</em>, but the lock is preserved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> to clear </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">TypeFactory::getBase()</a>, <a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">glb</a>, <a class="el" href="classSymbol.html#ab760cde69e8bb98988ba37871cb6fd63">Symbol::type</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, and <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeInternal.html#ab95e3712f0b536e014bfb3c8d3d2287a">ScopeInternal::clearUnlocked()</a>, and <a class="el" href="classScopeInternal.html#ac73cc9a432d1e7a383c9758486ffe58d">ScopeInternal::clearUnlockedCategory()</a>.</p>

</div>
</div>
<a id="af4c45025894f1996ef0f3556752cd997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c45025894f1996ef0f3556752cd997">&#9670;&nbsp;</a></span>resolveExternalRefFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFuncdata.html">Funcdata</a>* Scope::resolveExternalRefFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an <em>external</em> <em>reference</em> to the referenced function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> marking the external reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the underlying <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function.">Funcdata</a> object or NULL if none exists </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#acf54c42b2ce7edfa37f9bf1223bc2840">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#afdb2e6de63033bb78e6c4168c8e25227">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#a7850e4fd00c5dcc9299e646d13aae3dc">queryExternalRefFunction()</a>.</p>

</div>
</div>
<a id="a3b252ca0ce3155c06fe0cee6eae9265b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b252ca0ce3155c06fe0cee6eae9265b">&#9670;&nbsp;</a></span>resolveScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classScope.html">Scope</a> * Scope::resolveScope </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> of <b>this</b>. </p>
<p>Look for the (last) immediate child of <b>this</b> with a given name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the child's name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> or NULL if there is no child with that name </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#a10a6abc6a7c8631a1309d74ce9aa85e8">children</a>, and <a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeGhidra.html#a7a78e5e6659762cae118d3601d3a372d">ScopeGhidra::reresolveScope()</a>, <a class="el" href="classDatabase.html#a452ac8a13c82d53b20606b18202475ae">Database::resolveScope()</a>, <a class="el" href="classDatabase.html#abb1a4058854788e2847653526a458414">Database::resolveScopeSymbolName()</a>, and <a class="el" href="classDatabase.html#ad216578696aaa7c956be9cfe752edf57">Database::restoreXml()</a>.</p>

</div>
</div>
<a id="a21556c257fbea888f9004c654599dfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21556c257fbea888f9004c654599dfe9">&#9670;&nbsp;</a></span>restrictScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::restrictScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <b>this</b> to a local <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<p>Attach <b>this</b> to the given function, which makes <b>this</b> the local scope for the function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>is the given function to attach to </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classScopeGhidra.html#a0de93cdd506ae1490d939b957738f656">ScopeGhidra</a>.</p>

<p class="reference">References <a class="el" href="classScope.html#a72f6c31e73c46216482a6902d22b3330">fd</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeLocal.html#ac254c3908b456ecd7f2f50ca5a7d3f4d">ScopeLocal::ScopeLocal()</a>.</p>

</div>
</div>
<a id="afeef6a133b07fa176c08b67c44064e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeef6a133b07fa176c08b67c44064e69">&#9670;&nbsp;</a></span>retypeSymbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scope::retypeSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the data-type of a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<p>If the size of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> changes, any mapping (<a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a>) is adjusted </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
    <tr><td class="paramname">ct</td><td>is the new data-type </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a9711a8084e1ac5c4417a4452c96a36b7">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a086054a08a1916c410fa10b3e8afca76">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classProtoStoreSymbol.html#af9e24d39271ea90fc074010e4b24a2b1">ProtoStoreSymbol::setInput()</a>.</p>

</div>
</div>
<a id="a68c1f312cf9173871baa1b2fad29bb58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c1f312cf9173871baa1b2fad29bb58">&#9670;&nbsp;</a></span>saveXmlRecursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::saveXmlRecursive </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyGlobal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save all contained scopes as an XML stream. </p>
<p>This <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> and all of its sub-scopes are saved as a sequence of &lt;scope&gt; tags in post order. For each <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>, the <a class="el" href="classScope.html#a2583da1be37d68197dfbb0445fa1f3e0" title="Write out this as a &lt;scope&gt; XML tag.">saveXml()</a> method is invoked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
    <tr><td class="paramname">onlyGlobal</td><td>is <b>true</b> if only non-local Scopes should be saved </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classScope.html#a10a6abc6a7c8631a1309d74ce9aa85e8">children</a>, and <a class="el" href="classScope.html#a2583da1be37d68197dfbb0445fa1f3e0">saveXml()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncdata.html#ac8e7664bd70368066f7ad70a8922795e">Funcdata::saveXml()</a>, and <a class="el" href="classDatabase.html#ae44b2d77910ea8fd574443e5d7da55e9">Database::saveXml()</a>.</p>

</div>
</div>
<a id="ac807e11df36854d2f7983bdd6779e83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac807e11df36854d2f7983bdd6779e83a">&#9670;&nbsp;</a></span>setCategory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scope::setCategory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>cat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the <em>category</em> and index for the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
    <tr><td class="paramname">cat</td><td>is the <em>category</em> to set for the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
    <tr><td class="paramname">ind</td><td>is the index position to set (within the category) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#aee7ec7a7253a5cdcfa61b88f01e9918d">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#aafecf1b8615812bdbd8efeca910594a2">ScopeGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classProtoStoreSymbol.html#aa36f84c14205c90e18708858a3ae4ae5">ProtoStoreSymbol::clearInput()</a>, and <a class="el" href="classProtoStoreSymbol.html#af9e24d39271ea90fc074010e4b24a2b1">ProtoStoreSymbol::setInput()</a>.</p>

</div>
</div>
<a id="a598536926659c304d35346aba6d79fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598536926659c304d35346aba6d79fa2">&#9670;&nbsp;</a></span>stackAddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classScope.html">Scope</a> * Scope::stackAddr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> **&#160;</td>
          <td class="paramname"><em>addrmatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query for Symbols starting at a given address, which match a given <b>usepoint</b>. </p>
<p>Searching starts at a first scope, continuing thru parents up to a second scope, which is not queried. If a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> <em>controls</em> the memory at that address, the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> object is returned. Additionally, if a symbol matching the criterion is found, the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> is passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope1</td><td>is the first <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> where searching starts </td></tr>
    <tr><td class="paramname">scope2</td><td>is the second <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> where searching ends </td></tr>
    <tr><td class="paramname">addr</td><td>is the given address to search for </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the given point at which the memory is being accessed (can be an invalid address) </td></tr>
    <tr><td class="paramname">addrmatch</td><td>is used to pass-back any matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> owning the address or NULL if none found </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#aae4ea61f9a55ddfc9defd8548654c8e5">findAddr()</a>, <a class="el" href="classScope.html#a4fcaec6d7678dabe548680747d843a52">inScope()</a>, and <a class="el" href="classAddress.html#a8ef20a60dfb144bb91c466432e377eb5">Address::isConstant()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#afc95566b073624a0d12231a8e70bc5ce">queryByAddr()</a>.</p>

</div>
</div>
<a id="a4de9b51d8c57e33e9394512489539664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de9b51d8c57e33e9394512489539664">&#9670;&nbsp;</a></span>stackClosestFit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classScope.html">Scope</a> * Scope::stackClosestFit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> **&#160;</td>
          <td class="paramname"><em>addrmatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> which most closely matches a given range and <b>usepoint</b> </p>
<p>Searching starts at a first scope, continuing thru parents up to a second scope, which is not queried. If a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> <em>controls</em> the memory in the given range, the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> object is returned. Among symbols that overlap the given range, the <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> which most closely matches the starting address and size is passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope1</td><td>is the first <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> where searching starts </td></tr>
    <tr><td class="paramname">scope2</td><td>is the second <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> where searching ends </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the given range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point at which the memory is being accessed (can be an invalid address) </td></tr>
    <tr><td class="paramname">addrmatch</td><td>is used to pass-back any matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> owning the address or NULL if none found </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#ab679fe786be2fb949af78054cb2041a8">findClosestFit()</a>, <a class="el" href="classScope.html#a4fcaec6d7678dabe548680747d843a52">inScope()</a>, and <a class="el" href="classAddress.html#a8ef20a60dfb144bb91c466432e377eb5">Address::isConstant()</a>.</p>

</div>
</div>
<a id="a26992d3bf69e5c2c02e57943b1355f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26992d3bf69e5c2c02e57943b1355f0d">&#9670;&nbsp;</a></span>stackCodeLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classScope.html">Scope</a> * Scope::stackCodeLabel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLabSymbol.html">LabSymbol</a> **&#160;</td>
          <td class="paramname"><em>addrmatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query for a label <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> for a given address.</p>
<p>Searching starts at a first scope, continuing thru parents up to a second scope, which is not queried. If a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> <em>controls</em> the memory in the given range, the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> object is returned. If there is a label at that address, pass back the corresponding <a class="el" href="classLabSymbol.html" title="A Symbol that labels code internal to a function.">LabSymbol</a> object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope1</td><td>is the first <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> where searching starts </td></tr>
    <tr><td class="paramname">scope2</td><td>is the second <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> where searching ends </td></tr>
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
    <tr><td class="paramname">addrmatch</td><td>is used to pass-back any matching <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> owning the address or NULL if none found </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#af4bac52b9d64974b87432c0379cc38c6">findCodeLabel()</a>, <a class="el" href="classScope.html#a4fcaec6d7678dabe548680747d843a52">inScope()</a>, and <a class="el" href="classAddress.html#a8ef20a60dfb144bb91c466432e377eb5">Address::isConstant()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#a88982df383433525505723b19b8aaa13">queryCodeLabel()</a>.</p>

</div>
</div>
<a id="a63e00dad81427a8595cf7bf13d8e1e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e00dad81427a8595cf7bf13d8e1e0d">&#9670;&nbsp;</a></span>stackContainer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classScope.html">Scope</a> * Scope::stackContainer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> **&#160;</td>
          <td class="paramname"><em>addrmatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> containing a given range which is accessed at a given <b>usepoint</b> </p>
<p>Searching starts at a first scope, continuing thru parents up to a second scope, which is not queried. If a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> <em>controls</em> the memory in the given range, the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> object is returned. If a known <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> contains the range, the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> is passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope1</td><td>is the first <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> where searching starts </td></tr>
    <tr><td class="paramname">scope2</td><td>is the second <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> where searching ends </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the given range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point at which the memory is being accessed (can be an invalid address) </td></tr>
    <tr><td class="paramname">addrmatch</td><td>is used to pass-back any matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> owning the address or NULL if none found </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#a609fc1ef47d047717da65827e025cfdd">findContainer()</a>, <a class="el" href="classScope.html#a4fcaec6d7678dabe548680747d843a52">inScope()</a>, and <a class="el" href="classAddress.html#a8ef20a60dfb144bb91c466432e377eb5">Address::isConstant()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#af50dcbdbad011571fc24398781a2bab2">queryContainer()</a>, and <a class="el" href="classScope.html#a1b8c2c2302eba2666e319a4c18a67d51">queryProperties()</a>.</p>

</div>
</div>
<a id="a44898a2294de74a77dd21583ca6254e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44898a2294de74a77dd21583ca6254e2">&#9670;&nbsp;</a></span>stackExternalRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classScope.html">Scope</a> * Scope::stackExternalRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> **&#160;</td>
          <td class="paramname"><em>addrmatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query for an <em>external</em> <em>reference</em> <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> starting at the given address</p>
<p>Searching starts at a first scope, continuing thru parents up to a second scope, which is not queried. If a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> <em>controls</em> the memory in the given range, the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> object is returned. If an <em>external</em> <em>reference</em> is found at the address, pass back the matching <a class="el" href="classExternRefSymbol.html" title="A function Symbol referring to an external location.">ExternRefSymbol</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope1</td><td>is the first <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> where searching starts </td></tr>
    <tr><td class="paramname">scope2</td><td>is the second <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> where searching ends </td></tr>
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
    <tr><td class="paramname">addrmatch</td><td>is used to pass-back any matching <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> owning the address or NULL if none found </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#af69e0f77b621a3ba6436f8a1c0010d1c">findExternalRef()</a>, and <a class="el" href="classAddress.html#a8ef20a60dfb144bb91c466432e377eb5">Address::isConstant()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#a7850e4fd00c5dcc9299e646d13aae3dc">queryExternalRefFunction()</a>.</p>

</div>
</div>
<a id="a1e0d2e90ee5d4bc7e3dc761390be5e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0d2e90ee5d4bc7e3dc761390be5e47">&#9670;&nbsp;</a></span>stackFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classScope.html">Scope</a> * Scope::stackFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> **&#160;</td>
          <td class="paramname"><em>addrmatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query for a function <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> starting at the given address</p>
<p>Searching starts at a first scope, continuing thru parents up to a second scope, which is not queried. If a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> <em>controls</em> the memory in the given range, the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> object is returned. If a <a class="el" href="classFunctionSymbol.html" title="A Symbol representing an executable function.">FunctionSymbol</a> is found at the given address, the corresponding <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function.">Funcdata</a> object is passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope1</td><td>is the first <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> where searching starts </td></tr>
    <tr><td class="paramname">scope2</td><td>is the second <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> where searching ends </td></tr>
    <tr><td class="paramname">addr</td><td>is the given address where the function should start </td></tr>
    <tr><td class="paramname">addrmatch</td><td>is used to pass-back any matching function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> owning the address or NULL if none found </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#a72f6c31e73c46216482a6902d22b3330">fd</a>, <a class="el" href="classScope.html#a2c621196f6fdb4b8ce4ee1f3dc953107">findFunction()</a>, <a class="el" href="classScope.html#a4fcaec6d7678dabe548680747d843a52">inScope()</a>, and <a class="el" href="classAddress.html#a8ef20a60dfb144bb91c466432e377eb5">Address::isConstant()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#a5d6c56240bdb6df2d2670077cf5e08ca">queryFunction()</a>, and <a class="el" href="classScopeGhidra.html#afdb2e6de63033bb78e6c4168c8e25227">ScopeGhidra::resolveExternalRefFunction()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="database_8hh.html">database.hh</a></li>
<li>database.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
