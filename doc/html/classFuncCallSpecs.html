<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>decompiler: FuncCallSpecs Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFuncCallSpecs-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FuncCallSpecs Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for analyzing parameters to a sub-function call.  
 <a href="classFuncCallSpecs.html#details">More...</a></p>

<p><code>#include &lt;fspec.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FuncCallSpecs:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classFuncCallSpecs.png" usemap="#FuncCallSpecs_map" alt=""/>
  <map id="FuncCallSpecs_map" name="FuncCallSpecs_map">
<area href="classFuncProto.html" title="A function prototype." alt="FuncProto" shape="rect" coords="0,0,98,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acde16da75fc45aa08355abeebefa528b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classFuncCallSpecs.html#acde16da75fc45aa08355abeebefa528ba584ec7401809588c22798803bff5b796">offset_unknown</a> = 0xBADBEEF
 }</td></tr>
<tr class="separator:acde16da75fc45aa08355abeebefa528b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a96cbd6a1b0311883aeb840f47e4a0ec7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a96cbd6a1b0311883aeb840f47e4a0ec7">FuncCallSpecs</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *call_op)</td></tr>
<tr class="memdesc:a96cbd6a1b0311883aeb840f47e4a0ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct based on CALL or CALLIND.  <a href="classFuncCallSpecs.html#a96cbd6a1b0311883aeb840f47e4a0ec7">More...</a><br /></td></tr>
<tr class="separator:a96cbd6a1b0311883aeb840f47e4a0ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f63fcf31daa5cc5663df227a813f0a"><td class="memItemLeft" align="right" valign="top"><a id="ae2f63fcf31daa5cc5663df227a813f0a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ae2f63fcf31daa5cc5663df227a813f0a">setFuncdata</a> (<a class="el" href="classFuncdata.html">Funcdata</a> *f)</td></tr>
<tr class="memdesc:ae2f63fcf31daa5cc5663df227a813f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function.">Funcdata</a> object associated with the called function. <br /></td></tr>
<tr class="separator:ae2f63fcf31daa5cc5663df227a813f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac649b58eb85cf052096ac32e5ced8607"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ac649b58eb85cf052096ac32e5ced8607">clone</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *newop) const</td></tr>
<tr class="memdesc:ac649b58eb85cf052096ac32e5ced8607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone <b>this</b> given the mirrored p-code CALL.  <a href="classFuncCallSpecs.html#ac649b58eb85cf052096ac32e5ced8607">More...</a><br /></td></tr>
<tr class="separator:ac649b58eb85cf052096ac32e5ced8607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b481b6be0cc41e4f1b35089fc5f192b"><td class="memItemLeft" align="right" valign="top"><a id="a0b481b6be0cc41e4f1b35089fc5f192b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a0b481b6be0cc41e4f1b35089fc5f192b">initActiveInput</a> (void)</td></tr>
<tr class="memdesc:a0b481b6be0cc41e4f1b35089fc5f192b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on analysis recovering input parameters. <br /></td></tr>
<tr class="separator:a0b481b6be0cc41e4f1b35089fc5f192b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808f3d0c962701b6c98bca1792e86908"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a808f3d0c962701b6c98bca1792e86908">checkInputJoin</a> (int4 slot1, bool ishislot, <a class="el" href="classVarnode.html">Varnode</a> *vn1, <a class="el" href="classVarnode.html">Varnode</a> *vn2) const</td></tr>
<tr class="memdesc:a808f3d0c962701b6c98bca1792e86908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if adjacent parameter trials can be combined into a single logical parameter.  <a href="classFuncCallSpecs.html#a808f3d0c962701b6c98bca1792e86908">More...</a><br /></td></tr>
<tr class="separator:a808f3d0c962701b6c98bca1792e86908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489441d9d77d08bdf87eff937e8ef5b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a489441d9d77d08bdf87eff937e8ef5b8">doInputJoin</a> (int4 slot1, bool ishislot)</td></tr>
<tr class="memdesc:a489441d9d77d08bdf87eff937e8ef5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join two parameter trials.  <a href="classFuncCallSpecs.html#a489441d9d77d08bdf87eff937e8ef5b8">More...</a><br /></td></tr>
<tr class="separator:a489441d9d77d08bdf87eff937e8ef5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55b52b70e4def9167d06709746635e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ab55b52b70e4def9167d06709746635e9">lateRestriction</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;restrictedProto, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;newinput, <a class="el" href="classVarnode.html">Varnode</a> *&amp;newoutput)</td></tr>
<tr class="memdesc:ab55b52b70e4def9167d06709746635e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update <b>this</b> prototype to match a given (more specialized) prototype.  <a href="classFuncCallSpecs.html#ab55b52b70e4def9167d06709746635e9">More...</a><br /></td></tr>
<tr class="separator:ab55b52b70e4def9167d06709746635e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad64d557811baf4602afcefb2746f7be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aad64d557811baf4602afcefb2746f7be">deindirect</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, <a class="el" href="classFuncdata.html">Funcdata</a> *newfd)</td></tr>
<tr class="memdesc:aad64d557811baf4602afcefb2746f7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <b>this</b> call site from an indirect to a direct function call.  <a href="classFuncCallSpecs.html#aad64d557811baf4602afcefb2746f7be">More...</a><br /></td></tr>
<tr class="separator:aad64d557811baf4602afcefb2746f7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc0ef657c876530f21a6ae60458eb35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a8bc0ef657c876530f21a6ae60458eb35">forceSet</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;fp)</td></tr>
<tr class="memdesc:a8bc0ef657c876530f21a6ae60458eb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a more restrictive prototype on <b>this</b> call site.  <a href="classFuncCallSpecs.html#a8bc0ef657c876530f21a6ae60458eb35">More...</a><br /></td></tr>
<tr class="separator:a8bc0ef657c876530f21a6ae60458eb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6a890aaa82deca59ec7c57c92629aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aae6a890aaa82deca59ec7c57c92629aa">insertPcode</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data)</td></tr>
<tr class="memdesc:aae6a890aaa82deca59ec7c57c92629aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject any <em>upon-return</em> p-code at <b>this</b> call site.  <a href="classFuncCallSpecs.html#aae6a890aaa82deca59ec7c57c92629aa">More...</a><br /></td></tr>
<tr class="separator:aae6a890aaa82deca59ec7c57c92629aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad2a3f374049dec6fdf0f9d20295305"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a5ad2a3f374049dec6fdf0f9d20295305">resolveSpacebaseRelative</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, <a class="el" href="classVarnode.html">Varnode</a> *phvn)</td></tr>
<tr class="memdesc:a5ad2a3f374049dec6fdf0f9d20295305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the stack offset of <b>this</b> call site.  <a href="classFuncCallSpecs.html#a5ad2a3f374049dec6fdf0f9d20295305">More...</a><br /></td></tr>
<tr class="separator:a5ad2a3f374049dec6fdf0f9d20295305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c3231b5c523e491d65f31ddb688cc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ad3c3231b5c523e491d65f31ddb688cc1">abortSpacebaseRelative</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data)</td></tr>
<tr class="memdesc:ad3c3231b5c523e491d65f31ddb688cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the attempt to recover the relative stack offset for <b>this</b> function.  <a href="classFuncCallSpecs.html#ad3c3231b5c523e491d65f31ddb688cc1">More...</a><br /></td></tr>
<tr class="separator:ad3c3231b5c523e491d65f31ddb688cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48998cb808c1feedcad257f0984317ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a48998cb808c1feedcad257f0984317ed">finalInputCheck</a> (void)</td></tr>
<tr class="memdesc:a48998cb808c1feedcad257f0984317ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make final activity check on trials that might have been affected by conditional execution.  <a href="classFuncCallSpecs.html#a48998cb808c1feedcad257f0984317ed">More...</a><br /></td></tr>
<tr class="separator:a48998cb808c1feedcad257f0984317ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49917128896eb002c816e361f875943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ab49917128896eb002c816e361f875943">checkInputTrialUse</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, <a class="el" href="classAliasChecker.html">AliasChecker</a> &amp;aliascheck)</td></tr>
<tr class="memdesc:ab49917128896eb002c816e361f875943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark if input trials are being actively used.  <a href="classFuncCallSpecs.html#ab49917128896eb002c816e361f875943">More...</a><br /></td></tr>
<tr class="separator:ab49917128896eb002c816e361f875943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c50f8299ce305411880fc61b8b1907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a82c50f8299ce305411880fc61b8b1907">checkOutputTrialUse</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;trialvn)</td></tr>
<tr class="memdesc:a82c50f8299ce305411880fc61b8b1907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark if output trials are being actively used.  <a href="classFuncCallSpecs.html#a82c50f8299ce305411880fc61b8b1907">More...</a><br /></td></tr>
<tr class="separator:a82c50f8299ce305411880fc61b8b1907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb49b65cf036e8bc8b398e549b26a9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a1bb49b65cf036e8bc8b398e549b26a9c">buildInputFromTrials</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data)</td></tr>
<tr class="memdesc:a1bb49b65cf036e8bc8b398e549b26a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the final input Varnodes to <b>this</b> CALL based on <a class="el" href="classParamActive.html" title="Container class for ParamTrial objects.">ParamActive</a> analysis.  <a href="classFuncCallSpecs.html#a1bb49b65cf036e8bc8b398e549b26a9c">More...</a><br /></td></tr>
<tr class="separator:a1bb49b65cf036e8bc8b398e549b26a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f172165e29fbabfbb02be245ee1c98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a15f172165e29fbabfbb02be245ee1c98">buildOutputFromTrials</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;trialvn)</td></tr>
<tr class="memdesc:a15f172165e29fbabfbb02be245ee1c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the final output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> of <b>this</b> CALL based on <a class="el" href="classParamActive.html" title="Container class for ParamTrial objects.">ParamActive</a> analysis of trials.  <a href="classFuncCallSpecs.html#a15f172165e29fbabfbb02be245ee1c98">More...</a><br /></td></tr>
<tr class="separator:a15f172165e29fbabfbb02be245ee1c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15bd3498c19455047bf9b6b5af3df5b"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ad15bd3498c19455047bf9b6b5af3df5b">getInputBytesConsumed</a> (int4 slot) const</td></tr>
<tr class="memdesc:ad15bd3498c19455047bf9b6b5af3df5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the estimated number of bytes within the given parameter that are consumed.  <a href="classFuncCallSpecs.html#ad15bd3498c19455047bf9b6b5af3df5b">More...</a><br /></td></tr>
<tr class="separator:ad15bd3498c19455047bf9b6b5af3df5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb672e7f2a55179e16d4270143580093"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#acb672e7f2a55179e16d4270143580093">setInputBytesConsumed</a> (int4 slot, int4 val) const</td></tr>
<tr class="memdesc:acb672e7f2a55179e16d4270143580093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the estimated number of bytes within the given parameter that are consumed.  <a href="classFuncCallSpecs.html#acb672e7f2a55179e16d4270143580093">More...</a><br /></td></tr>
<tr class="separator:acb672e7f2a55179e16d4270143580093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7bcd5ea5ed14adbe74b4ca4c7e0814"><td class="memItemLeft" align="right" valign="top"><a id="aac7bcd5ea5ed14adbe74b4ca4c7e0814"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aac7bcd5ea5ed14adbe74b4ca4c7e0814">paramshiftModifyStart</a> (void)</td></tr>
<tr class="memdesc:aac7bcd5ea5ed14adbe74b4ca4c7e0814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend any extra parameters if a paramshift is required. <br /></td></tr>
<tr class="separator:aac7bcd5ea5ed14adbe74b4ca4c7e0814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e16ebebb71bdc63fb884c8d0e3b7e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a01e16ebebb71bdc63fb884c8d0e3b7e3">paramshiftModifyStop</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data)</td></tr>
<tr class="memdesc:a01e16ebebb71bdc63fb884c8d0e3b7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw out any paramshift parameters.  <a href="classFuncCallSpecs.html#a01e16ebebb71bdc63fb884c8d0e3b7e3">More...</a><br /></td></tr>
<tr class="separator:a01e16ebebb71bdc63fb884c8d0e3b7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a11cd8c631ed5b643eaf259b2ae49b"><td class="memItemLeft" align="right" valign="top">uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a37a11cd8c631ed5b643eaf259b2ae49b">hasEffectTranslate</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const</td></tr>
<tr class="memdesc:a37a11cd8c631ed5b643eaf259b2ae49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate type of side-effect for a given storage location (with caller translation)  <a href="classFuncCallSpecs.html#a37a11cd8c631ed5b643eaf259b2ae49b">More...</a><br /></td></tr>
<tr class="separator:a37a11cd8c631ed5b643eaf259b2ae49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classFuncProto"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classFuncProto')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classFuncProto.html">FuncProto</a></td></tr>
<tr class="memitem:a9c7db7dec63a18a9de97b0ba9f6f42bd inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a9c7db7dec63a18a9de97b0ba9f6f42bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a9c7db7dec63a18a9de97b0ba9f6f42bd">FuncProto</a> (void)</td></tr>
<tr class="memdesc:a9c7db7dec63a18a9de97b0ba9f6f42bd inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a9c7db7dec63a18a9de97b0ba9f6f42bd inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142706f5f3c9086635f812501521f3b4 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a142706f5f3c9086635f812501521f3b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a142706f5f3c9086635f812501521f3b4">~FuncProto</a> (void)</td></tr>
<tr class="memdesc:a142706f5f3c9086635f812501521f3b4 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a142706f5f3c9086635f812501521f3b4 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd4f3bc764b11b57f4e71b9d19df27d inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a9bd4f3bc764b11b57f4e71b9d19df27d">copy</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;op2)</td></tr>
<tr class="memdesc:a9bd4f3bc764b11b57f4e71b9d19df27d inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy another function prototype.  <a href="classFuncProto.html#a9bd4f3bc764b11b57f4e71b9d19df27d">More...</a><br /></td></tr>
<tr class="separator:a9bd4f3bc764b11b57f4e71b9d19df27d inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace26c345cdf567de704b24cd99e8a254 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="ace26c345cdf567de704b24cd99e8a254"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ace26c345cdf567de704b24cd99e8a254">copyFlowEffects</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;op2)</td></tr>
<tr class="memdesc:ace26c345cdf567de704b24cd99e8a254 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy properties that affect data-flow. <br /></td></tr>
<tr class="separator:ace26c345cdf567de704b24cd99e8a254 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b220dc769358d73110df5c60744566b inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a1b220dc769358d73110df5c60744566b">getPieces</a> (<a class="el" href="structPrototypePieces.html">PrototypePieces</a> &amp;pieces) const</td></tr>
<tr class="memdesc:a1b220dc769358d73110df5c60744566b inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw pieces of the prototype.  <a href="classFuncProto.html#a1b220dc769358d73110df5c60744566b">More...</a><br /></td></tr>
<tr class="separator:a1b220dc769358d73110df5c60744566b inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6f53c7733c8aa58d9138a8f3add2ce inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a8e6f53c7733c8aa58d9138a8f3add2ce">setPieces</a> (const <a class="el" href="structPrototypePieces.html">PrototypePieces</a> &amp;pieces)</td></tr>
<tr class="memdesc:a8e6f53c7733c8aa58d9138a8f3add2ce inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <b>this</b> prototype based on raw pieces.  <a href="classFuncProto.html#a8e6f53c7733c8aa58d9138a8f3add2ce">More...</a><br /></td></tr>
<tr class="separator:a8e6f53c7733c8aa58d9138a8f3add2ce inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc83eddece4cb123d198ad288dfa89bd inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#adc83eddece4cb123d198ad288dfa89bd">setScope</a> (<a class="el" href="classScope.html">Scope</a> *s, const <a class="el" href="classAddress.html">Address</a> &amp;startpoint)</td></tr>
<tr class="memdesc:adc83eddece4cb123d198ad288dfa89bd inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a backing symbol <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> for <b>this</b>.  <a href="classFuncProto.html#adc83eddece4cb123d198ad288dfa89bd">More...</a><br /></td></tr>
<tr class="separator:adc83eddece4cb123d198ad288dfa89bd inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69f89b0b3c5165e521d33b658599699 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af69f89b0b3c5165e521d33b658599699">setInternal</a> (<a class="el" href="classProtoModel.html">ProtoModel</a> *m, <a class="el" href="classDatatype.html">Datatype</a> *vt)</td></tr>
<tr class="memdesc:af69f89b0b3c5165e521d33b658599699 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set internal backing storage for <b>this</b>.  <a href="classFuncProto.html#af69f89b0b3c5165e521d33b658599699">More...</a><br /></td></tr>
<tr class="separator:af69f89b0b3c5165e521d33b658599699 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c14d15c7296c47deae3433687b1b15 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ae8c14d15c7296c47deae3433687b1b15">setModel</a> (<a class="el" href="classProtoModel.html">ProtoModel</a> *m)</td></tr>
<tr class="memdesc:ae8c14d15c7296c47deae3433687b1b15 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the prototype model for <b>this</b>.  <a href="classFuncProto.html#ae8c14d15c7296c47deae3433687b1b15">More...</a><br /></td></tr>
<tr class="separator:ae8c14d15c7296c47deae3433687b1b15 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab52f093617d8bd8a67f011ba5a0d324 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="aab52f093617d8bd8a67f011ba5a0d324"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aab52f093617d8bd8a67f011ba5a0d324">isInputLocked</a> (void) const</td></tr>
<tr class="memdesc:aab52f093617d8bd8a67f011ba5a0d324 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are input data-types locked. <br /></td></tr>
<tr class="separator:aab52f093617d8bd8a67f011ba5a0d324 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afe216709633a3b075111d6f1b7148f inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a4afe216709633a3b075111d6f1b7148f">setInputLock</a> (bool val)</td></tr>
<tr class="memdesc:a4afe216709633a3b075111d6f1b7148f inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the data-type lock on input parameters.  <a href="classFuncProto.html#a4afe216709633a3b075111d6f1b7148f">More...</a><br /></td></tr>
<tr class="separator:a4afe216709633a3b075111d6f1b7148f inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7593a0880a632bce714a376244ef4f9a inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a7593a0880a632bce714a376244ef4f9a">setOutputLock</a> (bool val)</td></tr>
<tr class="memdesc:a7593a0880a632bce714a376244ef4f9a inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the data-type lock on the return value.  <a href="classFuncProto.html#a7593a0880a632bce714a376244ef4f9a">More...</a><br /></td></tr>
<tr class="separator:a7593a0880a632bce714a376244ef4f9a inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc303c449c418dd875319c6f6cd9436f inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#acc303c449c418dd875319c6f6cd9436f">setModelLock</a> (bool val)</td></tr>
<tr class="memdesc:acc303c449c418dd875319c6f6cd9436f inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the lock on the prototype model for <b>this</b>.  <a href="classFuncProto.html#acc303c449c418dd875319c6f6cd9436f">More...</a><br /></td></tr>
<tr class="separator:acc303c449c418dd875319c6f6cd9436f inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843bc3ca11536028c5cb00ce5479182d inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a843bc3ca11536028c5cb00ce5479182d">setInline</a> (bool val)</td></tr>
<tr class="memdesc:a843bc3ca11536028c5cb00ce5479182d inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the <em>in-line</em> setting for functions with <b>this</b> prototype.  <a href="classFuncProto.html#a843bc3ca11536028c5cb00ce5479182d">More...</a><br /></td></tr>
<tr class="separator:a843bc3ca11536028c5cb00ce5479182d inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88af8e37c1ddb25fd9d6d8322ec436c6 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a88af8e37c1ddb25fd9d6d8322ec436c6">getInjectId</a> (void) const</td></tr>
<tr class="memdesc:a88af8e37c1ddb25fd9d6d8322ec436c6 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the injection id associated with <b>this</b>.  <a href="classFuncProto.html#a88af8e37c1ddb25fd9d6d8322ec436c6">More...</a><br /></td></tr>
<tr class="separator:a88af8e37c1ddb25fd9d6d8322ec436c6 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a764c6b7aa6f4718a38df9881666df inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a93a764c6b7aa6f4718a38df9881666df">getReturnBytesConsumed</a> (void) const</td></tr>
<tr class="memdesc:a93a764c6b7aa6f4718a38df9881666df inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an estimate of the number of bytes consumed by callers of <b>this</b> prototype.  <a href="classFuncProto.html#a93a764c6b7aa6f4718a38df9881666df">More...</a><br /></td></tr>
<tr class="separator:a93a764c6b7aa6f4718a38df9881666df inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd05102695a39cdad0170eeb92884b3a inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#abd05102695a39cdad0170eeb92884b3a">setReturnBytesConsumed</a> (int4 val)</td></tr>
<tr class="memdesc:abd05102695a39cdad0170eeb92884b3a inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of bytes consumed by callers of <b>this</b>.  <a href="classFuncProto.html#abd05102695a39cdad0170eeb92884b3a">More...</a><br /></td></tr>
<tr class="separator:abd05102695a39cdad0170eeb92884b3a inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1510914c66b2201248a6a06d282948 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a2f1510914c66b2201248a6a06d282948"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a2f1510914c66b2201248a6a06d282948">isNoReturn</a> (void) const</td></tr>
<tr class="memdesc:a2f1510914c66b2201248a6a06d282948 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a function with <b>this</b> prototype never return. <br /></td></tr>
<tr class="separator:a2f1510914c66b2201248a6a06d282948 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaf0bda9b424dfd5c6a28d3a45fb100 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aacaf0bda9b424dfd5c6a28d3a45fb100">setNoReturn</a> (bool val)</td></tr>
<tr class="memdesc:aacaf0bda9b424dfd5c6a28d3a45fb100 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the <em>no-return</em> setting for functions with <b>this</b> prototype.  <a href="classFuncProto.html#aacaf0bda9b424dfd5c6a28d3a45fb100">More...</a><br /></td></tr>
<tr class="separator:aacaf0bda9b424dfd5c6a28d3a45fb100 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a274b3ff58e50e73e4eaa82cb08bae3 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a2a274b3ff58e50e73e4eaa82cb08bae3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a2a274b3ff58e50e73e4eaa82cb08bae3">hasThisPointer</a> (void) const</td></tr>
<tr class="memdesc:a2a274b3ff58e50e73e4eaa82cb08bae3 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> a prototype for a class method, taking a <em>this</em> pointer. <br /></td></tr>
<tr class="separator:a2a274b3ff58e50e73e4eaa82cb08bae3 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4b02b22968723dcdb23ba51955e96e inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a4b4b02b22968723dcdb23ba51955e96e">setThisPointer</a> (bool val)</td></tr>
<tr class="memdesc:a4b4b02b22968723dcdb23ba51955e96e inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the <em>this-call</em> setting for <b>this</b> prototype.  <a href="classFuncProto.html#a4b4b02b22968723dcdb23ba51955e96e">More...</a><br /></td></tr>
<tr class="separator:a4b4b02b22968723dcdb23ba51955e96e inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007c1b4a9c33831738e3ac9bc283c5a4 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a007c1b4a9c33831738e3ac9bc283c5a4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a007c1b4a9c33831738e3ac9bc283c5a4">isConstructor</a> (void) const</td></tr>
<tr class="memdesc:a007c1b4a9c33831738e3ac9bc283c5a4 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> prototype for a class constructor method. <br /></td></tr>
<tr class="separator:a007c1b4a9c33831738e3ac9bc283c5a4 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff2f80e5cf4043147ccd83a863ee83f inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a1ff2f80e5cf4043147ccd83a863ee83f">setConstructor</a> (bool val)</td></tr>
<tr class="memdesc:a1ff2f80e5cf4043147ccd83a863ee83f inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> prototype is a <em>constructor</em> method.  <a href="classFuncProto.html#a1ff2f80e5cf4043147ccd83a863ee83f">More...</a><br /></td></tr>
<tr class="separator:a1ff2f80e5cf4043147ccd83a863ee83f inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed492939de15e4ea60f9970f2ec685ac inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="aed492939de15e4ea60f9970f2ec685ac"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aed492939de15e4ea60f9970f2ec685ac">isDestructor</a> (void) const</td></tr>
<tr class="memdesc:aed492939de15e4ea60f9970f2ec685ac inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> prototype for a class destructor method. <br /></td></tr>
<tr class="separator:aed492939de15e4ea60f9970f2ec685ac inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa191f5c52ce98ba14ef14f63a763a7da inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aa191f5c52ce98ba14ef14f63a763a7da">setDestructor</a> (bool val)</td></tr>
<tr class="memdesc:aa191f5c52ce98ba14ef14f63a763a7da inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> prototype is a <em>destructor</em> method.  <a href="classFuncProto.html#aa191f5c52ce98ba14ef14f63a763a7da">More...</a><br /></td></tr>
<tr class="separator:aa191f5c52ce98ba14ef14f63a763a7da inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeba6c216afa6ad43160d69a10433fab inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="abeba6c216afa6ad43160d69a10433fab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#abeba6c216afa6ad43160d69a10433fab">hasInputErrors</a> (void) const</td></tr>
<tr class="memdesc:abeba6c216afa6ad43160d69a10433fab inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has <b>this</b> prototype been marked as having an incorrect input parameter descriptions. <br /></td></tr>
<tr class="separator:abeba6c216afa6ad43160d69a10433fab inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0306cd7ee2a040dd783bd5e7606370 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="ace0306cd7ee2a040dd783bd5e7606370"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ace0306cd7ee2a040dd783bd5e7606370">hasOutputErrors</a> (void) const</td></tr>
<tr class="memdesc:ace0306cd7ee2a040dd783bd5e7606370 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has <b>this</b> prototype been marked as having an incorrect return value description. <br /></td></tr>
<tr class="separator:ace0306cd7ee2a040dd783bd5e7606370 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f36aaa3e2d1d7cdc90d101065abbc0 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ad5f36aaa3e2d1d7cdc90d101065abbc0">setInputErrors</a> (bool val)</td></tr>
<tr class="memdesc:ad5f36aaa3e2d1d7cdc90d101065abbc0 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the input error setting for <b>this</b> prototype.  <a href="classFuncProto.html#ad5f36aaa3e2d1d7cdc90d101065abbc0">More...</a><br /></td></tr>
<tr class="separator:ad5f36aaa3e2d1d7cdc90d101065abbc0 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8eacd70fbc6e4cd5d694d2ae5b1ed64 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ac8eacd70fbc6e4cd5d694d2ae5b1ed64">setOutputErrors</a> (bool val)</td></tr>
<tr class="memdesc:ac8eacd70fbc6e4cd5d694d2ae5b1ed64 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the output error setting for <b>this</b> prototype.  <a href="classFuncProto.html#ac8eacd70fbc6e4cd5d694d2ae5b1ed64">More...</a><br /></td></tr>
<tr class="separator:ac8eacd70fbc6e4cd5d694d2ae5b1ed64 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22889d3a526dce245368b8de9c889529 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a22889d3a526dce245368b8de9c889529">resolveExtraPop</a> (void)</td></tr>
<tr class="memdesc:a22889d3a526dce245368b8de9c889529 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming <b>this</b> prototype is locked, calculate the <em>extrapop</em>.  <a href="classFuncProto.html#a22889d3a526dce245368b8de9c889529">More...</a><br /></td></tr>
<tr class="separator:a22889d3a526dce245368b8de9c889529 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91eb49088323b42bdb38b83586eea6f inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="ae91eb49088323b42bdb38b83586eea6f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ae91eb49088323b42bdb38b83586eea6f">clearUnlockedInput</a> (void)</td></tr>
<tr class="memdesc:ae91eb49088323b42bdb38b83586eea6f inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear input parameters that have not been locked. <br /></td></tr>
<tr class="separator:ae91eb49088323b42bdb38b83586eea6f inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7428f70c6c7e040b4d090f3efeee08 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a3c7428f70c6c7e040b4d090f3efeee08"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a3c7428f70c6c7e040b4d090f3efeee08">clearUnlockedOutput</a> (void)</td></tr>
<tr class="memdesc:a3c7428f70c6c7e040b4d090f3efeee08 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the return value if it has not been locked. <br /></td></tr>
<tr class="separator:a3c7428f70c6c7e040b4d090f3efeee08 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8059930e66577c8906ade2f36f65cce inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="af8059930e66577c8906ade2f36f65cce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af8059930e66577c8906ade2f36f65cce">clearInput</a> (void)</td></tr>
<tr class="memdesc:af8059930e66577c8906ade2f36f65cce inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all input parameters regardless of lock. <br /></td></tr>
<tr class="separator:af8059930e66577c8906ade2f36f65cce inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb585835251e43a5c9f644519e69dc0 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a0bb585835251e43a5c9f644519e69dc0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a0bb585835251e43a5c9f644519e69dc0">cancelInjectId</a> (void)</td></tr>
<tr class="memdesc:a0bb585835251e43a5c9f644519e69dc0 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn-off any in-lining for this function. <br /></td></tr>
<tr class="separator:a0bb585835251e43a5c9f644519e69dc0 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3b71963b55dd19755eeaccd016c4bf inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#afd3b71963b55dd19755eeaccd016c4bf">resolveModel</a> (<a class="el" href="classParamActive.html">ParamActive</a> *active)</td></tr>
<tr class="memdesc:afd3b71963b55dd19755eeaccd016c4bf inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <b>this</b> has a <em>merged</em> model, pick the most likely model (from the merged set)  <a href="classFuncProto.html#afd3b71963b55dd19755eeaccd016c4bf">More...</a><br /></td></tr>
<tr class="separator:afd3b71963b55dd19755eeaccd016c4bf inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ef0c088573715372df24ef978bd610 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a06ef0c088573715372df24ef978bd610">deriveInputMap</a> (<a class="el" href="classParamActive.html">ParamActive</a> *active) const</td></tr>
<tr class="memdesc:a06ef0c088573715372df24ef978bd610 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of input <em>trials</em>, derive the most likely inputs for <b>this</b> prototype.  <a href="classFuncProto.html#a06ef0c088573715372df24ef978bd610">More...</a><br /></td></tr>
<tr class="separator:a06ef0c088573715372df24ef978bd610 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750224dcda509d76d01e3f45a3d38117 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a750224dcda509d76d01e3f45a3d38117">deriveOutputMap</a> (<a class="el" href="classParamActive.html">ParamActive</a> *active) const</td></tr>
<tr class="memdesc:a750224dcda509d76d01e3f45a3d38117 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of output <em>trials</em>, derive the most likely return value for <b>this</b> prototype.  <a href="classFuncProto.html#a750224dcda509d76d01e3f45a3d38117">More...</a><br /></td></tr>
<tr class="separator:a750224dcda509d76d01e3f45a3d38117 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961837591bf1445a8db9d7604c1e5046 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a961837591bf1445a8db9d7604c1e5046">checkInputJoin</a> (const <a class="el" href="classAddress.html">Address</a> &amp;hiaddr, int4 hisz, const <a class="el" href="classAddress.html">Address</a> &amp;loaddr, int4 losz) const</td></tr>
<tr class="memdesc:a961837591bf1445a8db9d7604c1e5046 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given two input storage locations can represent a single logical parameter.  <a href="classFuncProto.html#a961837591bf1445a8db9d7604c1e5046">More...</a><br /></td></tr>
<tr class="separator:a961837591bf1445a8db9d7604c1e5046 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768d557c966fc2f59c8ae0f09777b4fe inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a768d557c966fc2f59c8ae0f09777b4fe">checkInputSplit</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size, int4 splitpoint) const</td></tr>
<tr class="memdesc:a768d557c966fc2f59c8ae0f09777b4fe inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if it makes sense to split a single storage location into two input parameters.  <a href="classFuncProto.html#a768d557c966fc2f59c8ae0f09777b4fe">More...</a><br /></td></tr>
<tr class="separator:a768d557c966fc2f59c8ae0f09777b4fe inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb98890f848bc9e267c62c30e58a7f5f inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#acb98890f848bc9e267c62c30e58a7f5f">updateInputTypes</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;triallist, <a class="el" href="classParamActive.html">ParamActive</a> *activeinput)</td></tr>
<tr class="memdesc:acb98890f848bc9e267c62c30e58a7f5f inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update input parameters based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> trials.  <a href="classFuncProto.html#acb98890f848bc9e267c62c30e58a7f5f">More...</a><br /></td></tr>
<tr class="separator:acb98890f848bc9e267c62c30e58a7f5f inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b6986a4cf61f042579472e394ad7f8 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ad2b6986a4cf61f042579472e394ad7f8">updateInputNoTypes</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;triallist, <a class="el" href="classParamActive.html">ParamActive</a> *activeinput, <a class="el" href="classTypeFactory.html">TypeFactory</a> *factory)</td></tr>
<tr class="memdesc:ad2b6986a4cf61f042579472e394ad7f8 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update input parameters based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> trials, but do not store the data-type.  <a href="classFuncProto.html#ad2b6986a4cf61f042579472e394ad7f8">More...</a><br /></td></tr>
<tr class="separator:ad2b6986a4cf61f042579472e394ad7f8 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cbde2e23cdcf41ddb870721e02be6b inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a56cbde2e23cdcf41ddb870721e02be6b">updateOutputTypes</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;triallist)</td></tr>
<tr class="memdesc:a56cbde2e23cdcf41ddb870721e02be6b inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the return value based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> trials.  <a href="classFuncProto.html#a56cbde2e23cdcf41ddb870721e02be6b">More...</a><br /></td></tr>
<tr class="separator:a56cbde2e23cdcf41ddb870721e02be6b inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882e34d08f3e4e44ba5aa25b87c84bfe inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a882e34d08f3e4e44ba5aa25b87c84bfe">updateOutputNoTypes</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;triallist, <a class="el" href="classTypeFactory.html">TypeFactory</a> *factory)</td></tr>
<tr class="memdesc:a882e34d08f3e4e44ba5aa25b87c84bfe inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the return value based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> trials, but don't store the data-type.  <a href="classFuncProto.html#a882e34d08f3e4e44ba5aa25b87c84bfe">More...</a><br /></td></tr>
<tr class="separator:a882e34d08f3e4e44ba5aa25b87c84bfe inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad6aba5f6731281a4c16fdfac76de2c inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a9ad6aba5f6731281a4c16fdfac76de2c">updateAllTypes</a> (const vector&lt; string &gt; &amp;namelist, const vector&lt; <a class="el" href="classDatatype.html">Datatype</a> * &gt; &amp;typelist, bool dtdtdt)</td></tr>
<tr class="memdesc:a9ad6aba5f6731281a4c16fdfac76de2c inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <b>this</b> entire function prototype based on a list of names and data-types.  <a href="classFuncProto.html#a9ad6aba5f6731281a4c16fdfac76de2c">More...</a><br /></td></tr>
<tr class="separator:a9ad6aba5f6731281a4c16fdfac76de2c inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906c0e176919bd0ced34e337445c2bf7 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a906c0e176919bd0ced34e337445c2bf7">hasEffect</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const</td></tr>
<tr class="memdesc:a906c0e176919bd0ced34e337445c2bf7 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the effect <b>this</b> has an a given storage location.  <a href="classFuncProto.html#a906c0e176919bd0ced34e337445c2bf7">More...</a><br /></td></tr>
<tr class="separator:a906c0e176919bd0ced34e337445c2bf7 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802de184a6ac675b8f4bb4c4cb47a194 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a802de184a6ac675b8f4bb4c4cb47a194"></a>
vector&lt; <a class="el" href="classEffectRecord.html">EffectRecord</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a802de184a6ac675b8f4bb4c4cb47a194">effectBegin</a> (void) const</td></tr>
<tr class="memdesc:a802de184a6ac675b8f4bb4c4cb47a194 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator to front of <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range.">EffectRecord</a> list. <br /></td></tr>
<tr class="separator:a802de184a6ac675b8f4bb4c4cb47a194 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75adeed5dd962662f85c69b6104a8d07 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a75adeed5dd962662f85c69b6104a8d07"></a>
vector&lt; <a class="el" href="classEffectRecord.html">EffectRecord</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a75adeed5dd962662f85c69b6104a8d07">effectEnd</a> (void) const</td></tr>
<tr class="memdesc:a75adeed5dd962662f85c69b6104a8d07 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator to end of <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range.">EffectRecord</a> list. <br /></td></tr>
<tr class="separator:a75adeed5dd962662f85c69b6104a8d07 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af903eb699778675e96f0d3376b505732 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af903eb699778675e96f0d3376b505732">numLikelyTrash</a> (void) const</td></tr>
<tr class="memdesc:af903eb699778675e96f0d3376b505732 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <em>likely-trash</em> locations.  <a href="classFuncProto.html#af903eb699778675e96f0d3376b505732">More...</a><br /></td></tr>
<tr class="separator:af903eb699778675e96f0d3376b505732 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078b7588849b80acc7c1d1ba13cda5f3 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a078b7588849b80acc7c1d1ba13cda5f3">getLikelyTrash</a> (int4 i) const</td></tr>
<tr class="memdesc:a078b7588849b80acc7c1d1ba13cda5f3 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the i-th <em>likely-trash</em> location.  <a href="classFuncProto.html#a078b7588849b80acc7c1d1ba13cda5f3">More...</a><br /></td></tr>
<tr class="separator:a078b7588849b80acc7c1d1ba13cda5f3 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3a9b7304fda4d72942f76ef64d725b inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#abb3a9b7304fda4d72942f76ef64d725b">characterizeAsInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const</td></tr>
<tr class="memdesc:abb3a9b7304fda4d72942f76ef64d725b inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether a given storage location could be, or could hold, an input parameter.  <a href="classFuncProto.html#abb3a9b7304fda4d72942f76ef64d725b">More...</a><br /></td></tr>
<tr class="separator:abb3a9b7304fda4d72942f76ef64d725b inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ed6ca81a4b601ae81f4080a5bf89fa inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a59ed6ca81a4b601ae81f4080a5bf89fa">possibleInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const</td></tr>
<tr class="memdesc:a59ed6ca81a4b601ae81f4080a5bf89fa inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether a given storage location could be an input parameter.  <a href="classFuncProto.html#a59ed6ca81a4b601ae81f4080a5bf89fa">More...</a><br /></td></tr>
<tr class="separator:a59ed6ca81a4b601ae81f4080a5bf89fa inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c37f6adddd70f3fd17500dcacd0c92 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a65c37f6adddd70f3fd17500dcacd0c92">possibleOutputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const</td></tr>
<tr class="memdesc:a65c37f6adddd70f3fd17500dcacd0c92 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether a given storage location could be a return value.  <a href="classFuncProto.html#a65c37f6adddd70f3fd17500dcacd0c92">More...</a><br /></td></tr>
<tr class="separator:a65c37f6adddd70f3fd17500dcacd0c92 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b4705cc5b9695e8c96e1e9294f0cfb inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a07b4705cc5b9695e8c96e1e9294f0cfb">getMaxInputDelay</a> (void) const</td></tr>
<tr class="memdesc:a07b4705cc5b9695e8c96e1e9294f0cfb inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum heritage delay across all possible input parameters.  <a href="classFuncProto.html#a07b4705cc5b9695e8c96e1e9294f0cfb">More...</a><br /></td></tr>
<tr class="separator:a07b4705cc5b9695e8c96e1e9294f0cfb inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cb1fac9b0d2d2c55d3ff4fa7db5c27 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a79cb1fac9b0d2d2c55d3ff4fa7db5c27">getMaxOutputDelay</a> (void) const</td></tr>
<tr class="memdesc:a79cb1fac9b0d2d2c55d3ff4fa7db5c27 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum heritage delay across all possible return values.  <a href="classFuncProto.html#a79cb1fac9b0d2d2c55d3ff4fa7db5c27">More...</a><br /></td></tr>
<tr class="separator:a79cb1fac9b0d2d2c55d3ff4fa7db5c27 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fe71f261f3593c98efe396973d5775 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af0fe71f261f3593c98efe396973d5775">unjustifiedInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const</td></tr>
<tr class="memdesc:af0fe71f261f3593c98efe396973d5775 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given storage location looks like an <em>unjustified</em> input parameter.  <a href="classFuncProto.html#af0fe71f261f3593c98efe396973d5775">More...</a><br /></td></tr>
<tr class="separator:af0fe71f261f3593c98efe396973d5775 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1a73b8df1756f6945df97319270508 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ace1a73b8df1756f6945df97319270508">assumedInputExtension</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const</td></tr>
<tr class="memdesc:ace1a73b8df1756f6945df97319270508 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of extension and containing input parameter for the given storage.  <a href="classFuncProto.html#ace1a73b8df1756f6945df97319270508">More...</a><br /></td></tr>
<tr class="separator:ace1a73b8df1756f6945df97319270508 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2550a272235e295512ee5eb7a2674638 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a2550a272235e295512ee5eb7a2674638">assumedOutputExtension</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const</td></tr>
<tr class="memdesc:a2550a272235e295512ee5eb7a2674638 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of extension and containing return value location for the given storage.  <a href="classFuncProto.html#a2550a272235e295512ee5eb7a2674638">More...</a><br /></td></tr>
<tr class="separator:a2550a272235e295512ee5eb7a2674638 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e92071dcc850f3dc74cd3e5ce85123 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ac2e92071dcc850f3dc74cd3e5ce85123">getBiggestContainedInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const</td></tr>
<tr class="memdesc:ac2e92071dcc850f3dc74cd3e5ce85123 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass-back the biggest potential input parameter contained within the given range.  <a href="classFuncProto.html#ac2e92071dcc850f3dc74cd3e5ce85123">More...</a><br /></td></tr>
<tr class="separator:ac2e92071dcc850f3dc74cd3e5ce85123 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ee60788e6d8b4de304e2c5955a393b inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aa5ee60788e6d8b4de304e2c5955a393b">isCompatible</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;op2) const</td></tr>
<tr class="memdesc:aa5ee60788e6d8b4de304e2c5955a393b inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide if <b>this</b> can be safely restricted to match another prototype.  <a href="classFuncProto.html#aa5ee60788e6d8b4de304e2c5955a393b">More...</a><br /></td></tr>
<tr class="separator:aa5ee60788e6d8b4de304e2c5955a393b inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8d609764a4fd6c38cb0c284f225180 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#acf8d609764a4fd6c38cb0c284f225180">printRaw</a> (const string &amp;funcname, ostream &amp;s) const</td></tr>
<tr class="memdesc:acf8d609764a4fd6c38cb0c284f225180 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print <b>this</b> prototype as a single line of text.  <a href="classFuncProto.html#acf8d609764a4fd6c38cb0c284f225180">More...</a><br /></td></tr>
<tr class="separator:acf8d609764a4fd6c38cb0c284f225180 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1c9aa013921f2738ad28dce59867e6 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aeb1c9aa013921f2738ad28dce59867e6">getComparableFlags</a> (void) const</td></tr>
<tr class="memdesc:aeb1c9aa013921f2738ad28dce59867e6 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the comparable properties of <b>this</b> prototype.  <a href="classFuncProto.html#aeb1c9aa013921f2738ad28dce59867e6">More...</a><br /></td></tr>
<tr class="separator:aeb1c9aa013921f2738ad28dce59867e6 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da5ce755480a4eded9bedff2c6e274f inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a4da5ce755480a4eded9bedff2c6e274f">saveXml</a> (ostream &amp;s) const</td></tr>
<tr class="memdesc:a4da5ce755480a4eded9bedff2c6e274f inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save <b>this</b> to an XML stream as a &lt;prototype&gt; tag.  <a href="classFuncProto.html#a4da5ce755480a4eded9bedff2c6e274f">More...</a><br /></td></tr>
<tr class="separator:a4da5ce755480a4eded9bedff2c6e274f inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4f9da74ee904e6abfa195bd843521e inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a4c4f9da74ee904e6abfa195bd843521e">restoreXml</a> (const <a class="el" href="classElement.html">Element</a> *el, <a class="el" href="classArchitecture.html">Architecture</a> *glb)</td></tr>
<tr class="memdesc:a4c4f9da74ee904e6abfa195bd843521e inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore <b>this</b> from an XML stream.  <a href="classFuncProto.html#a4c4f9da74ee904e6abfa195bd843521e">More...</a><br /></td></tr>
<tr class="separator:a4c4f9da74ee904e6abfa195bd843521e inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9a59b9321b66bc9f23e69d2ef729258c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a9a59b9321b66bc9f23e69d2ef729258c">findPreexistingWhole</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn1, <a class="el" href="classVarnode.html">Varnode</a> *vn2)</td></tr>
<tr class="memdesc:a9a59b9321b66bc9f23e69d2ef729258c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if given two Varnodes are merged into a whole.  <a href="classFuncCallSpecs.html#a9a59b9321b66bc9f23e69d2ef729258c">More...</a><br /></td></tr>
<tr class="separator:a9a59b9321b66bc9f23e69d2ef729258c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d084c81a9ae8656d7ef79c84398dc8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aa1d084c81a9ae8656d7ef79c84398dc8">getFspecFromConst</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr)</td></tr>
<tr class="memdesc:aa1d084c81a9ae8656d7ef79c84398dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <a class="el" href="classFspecSpace.html" title="A special space for encoding FuncCallSpecs.">FspecSpace</a> addresses to the underlying <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call.">FuncCallSpecs</a> object.  <a href="classFuncCallSpecs.html#aa1d084c81a9ae8656d7ef79c84398dc8">More...</a><br /></td></tr>
<tr class="separator:aa1d084c81a9ae8656d7ef79c84398dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f3844d92136d3ab6b67ea9ea316aa7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a57f3844d92136d3ab6b67ea9ea316aa7">compareByEntryAddress</a> (const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *a, const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *b)</td></tr>
<tr class="memdesc:a57f3844d92136d3ab6b67ea9ea316aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call.">FuncCallSpecs</a> by function entry address.  <a href="classFuncCallSpecs.html#a57f3844d92136d3ab6b67ea9ea316aa7">More...</a><br /></td></tr>
<tr class="separator:a57f3844d92136d3ab6b67ea9ea316aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6fc72a11289af288ec65f216d7a45b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aab6fc72a11289af288ec65f216d7a45b">countMatchingCalls</a> (const vector&lt; <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> * &gt; &amp;qlst)</td></tr>
<tr class="memdesc:aab6fc72a11289af288ec65f216d7a45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the number of times an individual sub-function is called.  <a href="classFuncCallSpecs.html#aab6fc72a11289af288ec65f216d7a45b">More...</a><br /></td></tr>
<tr class="separator:aab6fc72a11289af288ec65f216d7a45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afc88cbd3e19e0e1269680de99ee1521e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#afc88cbd3e19e0e1269680de99ee1521e">getSpacebaseRelative</a> (void) const</td></tr>
<tr class="memdesc:afc88cbd3e19e0e1269680de99ee1521e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the active stack-pointer <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> at <b>this</b> call site.  <a href="classFuncCallSpecs.html#afc88cbd3e19e0e1269680de99ee1521e">More...</a><br /></td></tr>
<tr class="separator:afc88cbd3e19e0e1269680de99ee1521e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf5f37e4556f80f027ae502a60092ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aadf5f37e4556f80f027ae502a60092ba">buildParam</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, <a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classProtoParameter.html">ProtoParameter</a> *param, <a class="el" href="classVarnode.html">Varnode</a> *stackref)</td></tr>
<tr class="memdesc:aadf5f37e4556f80f027ae502a60092ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> representing a specific parameter.  <a href="classFuncCallSpecs.html#aadf5f37e4556f80f027ae502a60092ba">More...</a><br /></td></tr>
<tr class="separator:aadf5f37e4556f80f027ae502a60092ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea6ae61949247b9e8c4643ce68860e3"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a3ea6ae61949247b9e8c4643ce68860e3">transferLockedInputParam</a> (<a class="el" href="classProtoParameter.html">ProtoParameter</a> *param)</td></tr>
<tr class="memdesc:a3ea6ae61949247b9e8c4643ce68860e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the CALL input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> that matches the given parameter.  <a href="classFuncCallSpecs.html#a3ea6ae61949247b9e8c4643ce68860e3">More...</a><br /></td></tr>
<tr class="separator:a3ea6ae61949247b9e8c4643ce68860e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077b8ed8181bb5523e1be06583d3d588"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a077b8ed8181bb5523e1be06583d3d588">transferLockedOutputParam</a> (<a class="el" href="classProtoParameter.html">ProtoParameter</a> *param)</td></tr>
<tr class="separator:a077b8ed8181bb5523e1be06583d3d588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c269dac5b3730ea0093d2bc6841b07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a51c269dac5b3730ea0093d2bc6841b07">transferLockedInput</a> (vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;newinput)</td></tr>
<tr class="memdesc:a51c269dac5b3730ea0093d2bc6841b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">List and/or create a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> for each input parameter of <b>this</b> prototype.  <a href="classFuncCallSpecs.html#a51c269dac5b3730ea0093d2bc6841b07">More...</a><br /></td></tr>
<tr class="separator:a51c269dac5b3730ea0093d2bc6841b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1cb380c5ca6bf3d02f441cf582c50e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aed1cb380c5ca6bf3d02f441cf582c50e">transferLockedOutput</a> (<a class="el" href="classVarnode.html">Varnode</a> *&amp;newoutput)</td></tr>
<tr class="memdesc:aed1cb380c5ca6bf3d02f441cf582c50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass back the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> needed to match the output parameter (return value)  <a href="classFuncCallSpecs.html#aed1cb380c5ca6bf3d02f441cf582c50e">More...</a><br /></td></tr>
<tr class="separator:aed1cb380c5ca6bf3d02f441cf582c50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98405e6447b4ada292a557920b828d67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a98405e6447b4ada292a557920b828d67">commitNewInputs</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;newinput)</td></tr>
<tr class="memdesc:a98405e6447b4ada292a557920b828d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update input Varnodes to <b>this</b> CALL to reflect the formal input parameters.  <a href="classFuncCallSpecs.html#a98405e6447b4ada292a557920b828d67">More...</a><br /></td></tr>
<tr class="separator:a98405e6447b4ada292a557920b828d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa357f1ecfa3c9bd2ab86d958bb0670b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">commitNewOutputs</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, <a class="el" href="classVarnode.html">Varnode</a> *newout)</td></tr>
<tr class="memdesc:aa357f1ecfa3c9bd2ab86d958bb0670b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> to <b>this</b> CALL to reflect the formal return value.  <a href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">More...</a><br /></td></tr>
<tr class="separator:aa357f1ecfa3c9bd2ab86d958bb0670b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad241f5566eb01acaa77327da464c7984"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ad241f5566eb01acaa77327da464c7984">collectOutputTrialVarnodes</a> (vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;trialvn)</td></tr>
<tr class="separator:ad241f5566eb01acaa77327da464c7984"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a42e16ea23d22a20d4c343f33a50307eb"><td class="memItemLeft" align="right" valign="top"><a id="a42e16ea23d22a20d4c343f33a50307eb"></a>
<a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a></td></tr>
<tr class="memdesc:a42e16ea23d22a20d4c343f33a50307eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to CALL or CALLIND instruction. <br /></td></tr>
<tr class="separator:a42e16ea23d22a20d4c343f33a50307eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4c4b25b4eba36052e847f41f110816"><td class="memItemLeft" align="right" valign="top"><a id="aee4c4b25b4eba36052e847f41f110816"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aee4c4b25b4eba36052e847f41f110816">name</a></td></tr>
<tr class="memdesc:aee4c4b25b4eba36052e847f41f110816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of function if present. <br /></td></tr>
<tr class="separator:aee4c4b25b4eba36052e847f41f110816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5d10d1b705fb05f1ce581b7a6eeed6"><td class="memItemLeft" align="right" valign="top"><a id="a1c5d10d1b705fb05f1ce581b7a6eeed6"></a>
<a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a1c5d10d1b705fb05f1ce581b7a6eeed6">entryaddress</a></td></tr>
<tr class="memdesc:a1c5d10d1b705fb05f1ce581b7a6eeed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">First executing address of function. <br /></td></tr>
<tr class="separator:a1c5d10d1b705fb05f1ce581b7a6eeed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade06e0fcf372e92f2b62ac1e188439be"><td class="memItemLeft" align="right" valign="top"><a id="ade06e0fcf372e92f2b62ac1e188439be"></a>
<a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ade06e0fcf372e92f2b62ac1e188439be">fd</a></td></tr>
<tr class="memdesc:ade06e0fcf372e92f2b62ac1e188439be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function.">Funcdata</a> object for the called functon (if known) <br /></td></tr>
<tr class="separator:ade06e0fcf372e92f2b62ac1e188439be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af7fe0e7b3d1486e41e528a1deec61f"><td class="memItemLeft" align="right" valign="top"><a id="a0af7fe0e7b3d1486e41e528a1deec61f"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a0af7fe0e7b3d1486e41e528a1deec61f">effective_extrapop</a></td></tr>
<tr class="memdesc:a0af7fe0e7b3d1486e41e528a1deec61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Working extrapop for the CALL. <br /></td></tr>
<tr class="separator:a0af7fe0e7b3d1486e41e528a1deec61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c685ecd38c4da586b8c7bddc2fd1983"><td class="memItemLeft" align="right" valign="top"><a id="a0c685ecd38c4da586b8c7bddc2fd1983"></a>
uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a0c685ecd38c4da586b8c7bddc2fd1983">stackoffset</a></td></tr>
<tr class="memdesc:a0c685ecd38c4da586b8c7bddc2fd1983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative offset of stack-pointer at time of this call. <br /></td></tr>
<tr class="separator:a0c685ecd38c4da586b8c7bddc2fd1983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af655410c6704377c0d260b06fd532e22"><td class="memItemLeft" align="right" valign="top"><a id="af655410c6704377c0d260b06fd532e22"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#af655410c6704377c0d260b06fd532e22">stackPlaceholderSlot</a></td></tr>
<tr class="memdesc:af655410c6704377c0d260b06fd532e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slot containing temporary stack tracing placeholder (-1 means unused) <br /></td></tr>
<tr class="separator:af655410c6704377c0d260b06fd532e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303b8605ffd3e4432fb7ca3c70759f2d"><td class="memItemLeft" align="right" valign="top"><a id="a303b8605ffd3e4432fb7ca3c70759f2d"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a303b8605ffd3e4432fb7ca3c70759f2d">paramshift</a></td></tr>
<tr class="memdesc:a303b8605ffd3e4432fb7ca3c70759f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of input parameters to ignore before prototype. <br /></td></tr>
<tr class="separator:a303b8605ffd3e4432fb7ca3c70759f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ee88ee6bc22078cb8f03dd71ea87d2"><td class="memItemLeft" align="right" valign="top"><a id="a33ee88ee6bc22078cb8f03dd71ea87d2"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a33ee88ee6bc22078cb8f03dd71ea87d2">matchCallCount</a></td></tr>
<tr class="memdesc:a33ee88ee6bc22078cb8f03dd71ea87d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of calls to this sub-function within the calling function. <br /></td></tr>
<tr class="separator:a33ee88ee6bc22078cb8f03dd71ea87d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae356496b5aa7f2c01cdbf0e929aba55d"><td class="memItemLeft" align="right" valign="top"><a id="ae356496b5aa7f2c01cdbf0e929aba55d"></a>
<a class="el" href="classParamActive.html">ParamActive</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ae356496b5aa7f2c01cdbf0e929aba55d">activeinput</a></td></tr>
<tr class="memdesc:ae356496b5aa7f2c01cdbf0e929aba55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Info for recovering input parameters. <br /></td></tr>
<tr class="separator:ae356496b5aa7f2c01cdbf0e929aba55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0d946a82d4f68de1e32333df36e1c5"><td class="memItemLeft" align="right" valign="top"><a id="a9b0d946a82d4f68de1e32333df36e1c5"></a>
<a class="el" href="classParamActive.html">ParamActive</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a9b0d946a82d4f68de1e32333df36e1c5">activeoutput</a></td></tr>
<tr class="memdesc:a9b0d946a82d4f68de1e32333df36e1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Info for recovering output parameters. <br /></td></tr>
<tr class="separator:a9b0d946a82d4f68de1e32333df36e1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0a35536be1d782a6ce613267b0400d"><td class="memItemLeft" align="right" valign="top"><a id="a9a0a35536be1d782a6ce613267b0400d"></a>
vector&lt; int4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a9a0a35536be1d782a6ce613267b0400d">inputConsume</a></td></tr>
<tr class="memdesc:a9a0a35536be1d782a6ce613267b0400d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes consumed by sub-function, for each input parameter. <br /></td></tr>
<tr class="separator:a9a0a35536be1d782a6ce613267b0400d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19a159dce6a7370b84dba2ff11637f7"><td class="memItemLeft" align="right" valign="top"><a id="ab19a159dce6a7370b84dba2ff11637f7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ab19a159dce6a7370b84dba2ff11637f7">isinputactive</a></td></tr>
<tr class="memdesc:ab19a159dce6a7370b84dba2ff11637f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we actively trying to recover input parameters. <br /></td></tr>
<tr class="separator:ab19a159dce6a7370b84dba2ff11637f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e150cc27ea477580875468dab13d5a"><td class="memItemLeft" align="right" valign="top"><a id="a08e150cc27ea477580875468dab13d5a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a08e150cc27ea477580875468dab13d5a">isoutputactive</a></td></tr>
<tr class="memdesc:a08e150cc27ea477580875468dab13d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we actively trying to recover output parameters. <br /></td></tr>
<tr class="separator:a08e150cc27ea477580875468dab13d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa7e05c56f2cad157d9e72095cb53bd"><td class="memItemLeft" align="right" valign="top"><a id="aaaa7e05c56f2cad157d9e72095cb53bd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aaaa7e05c56f2cad157d9e72095cb53bd">isbadjumptable</a></td></tr>
<tr class="memdesc:aaaa7e05c56f2cad157d9e72095cb53bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Was the call originally a jump-table we couldn't recover. <br /></td></tr>
<tr class="separator:aaaa7e05c56f2cad157d9e72095cb53bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classFuncProto"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classFuncProto')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classFuncProto.html">FuncProto</a></td></tr>
<tr class="memitem:a75f9569f65cd6472f80d3e85d8453ced inherit pro_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a75f9569f65cd6472f80d3e85d8453ced">paramShift</a> (int4 paramshift)</td></tr>
<tr class="memdesc:a75f9569f65cd6472f80d3e85d8453ced inherit pro_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add parameters to the front of the input parameter list.  <a href="classFuncProto.html#a75f9569f65cd6472f80d3e85d8453ced">More...</a><br /></td></tr>
<tr class="separator:a75f9569f65cd6472f80d3e85d8453ced inherit pro_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a494d8691b68a76a56495907ab9f6d inherit pro_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="ab1a494d8691b68a76a56495907ab9f6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ab1a494d8691b68a76a56495907ab9f6d">setParamshiftApplied</a> (bool val)</td></tr>
<tr class="memdesc:ab1a494d8691b68a76a56495907ab9f6d inherit pro_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether a parameter shift has been applied. <br /></td></tr>
<tr class="separator:ab1a494d8691b68a76a56495907ab9f6d inherit pro_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for analyzing parameters to a sub-function call. </p>
<p>This can be viewed as a function prototype that evolves over the course of analysis. It derives off of <a class="el" href="classFuncProto.html" title="A function prototype.">FuncProto</a> and includes facilities for analyzing data-flow for parameter information. This is the high-level object managing the examination of data-flow to recover a working prototype (<a class="el" href="classParamActive.html" title="Container class for ParamTrial objects.">ParamActive</a>), holding a stack-pointer placeholder to facilitate stack analysis, and deciding on the working <em>extrapop</em> for the CALL.</p>
<p>A <b>stack-pointer</b> <b>placeholder</b> is a temporary <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> in the input operands of the CALL or CALLIND that is defined by a LOAD from the stack-pointer. By examining the pointer, the exact value of the stack-pointer (relative to its incoming value) can be computed at the point of the CALL. The temporary can arise naturally if stack parameters are a possibility, otherwise a placeholder temporary is artificially inserted into the CALL input. At the time heritage of the stack space is computed, the placeholder is examined to read off the active stack-pointer offset for the CALL and the placeholder is removed. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="acde16da75fc45aa08355abeebefa528b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde16da75fc45aa08355abeebefa528b">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acde16da75fc45aa08355abeebefa528ba584ec7401809588c22798803bff5b796"></a>offset_unknown&#160;</td><td class="fielddoc"><p>"Magic" stack offset indicating the offset is unknown </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a96cbd6a1b0311883aeb840f47e4a0ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cbd6a1b0311883aeb840f47e4a0ec7">&#9670;&nbsp;</a></span>FuncCallSpecs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncCallSpecs::FuncCallSpecs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>call_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct based on CALL or CALLIND. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call_op</td><td>is the representative call site within the data-flow </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a50235a7bf50bada36dff73ff740c34d0">CPUI_CALL</a>, <a class="el" href="classFuncCallSpecs.html#a0af7fe0e7b3d1486e41e528a1deec61f">effective_extrapop</a>, <a class="el" href="classFuncCallSpecs.html#a1c5d10d1b705fb05f1ce581b7a6eeed6">entryaddress</a>, <a class="el" href="classProtoModel.html#af44a0c8ef473b9506605a5d3329dafceab0874d825448e7c731717fad59bbec92">ProtoModel::extrapop_unknown</a>, <a class="el" href="classFuncCallSpecs.html#ade06e0fcf372e92f2b62ac1e188439be">fd</a>, <a class="el" href="classFuncCallSpecs.html#aa1d084c81a9ae8656d7ef79c84398dc8">getFspecFromConst()</a>, <a class="el" href="classAddress.html#a2e1cbf153126eebf5ba92f52c5dbc6a8">Address::getSpace()</a>, <a class="el" href="classAddrSpace.html#ab548f4158529a29122d4d0a30d94ed98">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a01bf4d06e504bf92eabbfd633e5c74c0">IPTR_FSPEC</a>, <a class="el" href="classFuncCallSpecs.html#aaaa7e05c56f2cad157d9e72095cb53bd">isbadjumptable</a>, <a class="el" href="classFuncCallSpecs.html#ab19a159dce6a7370b84dba2ff11637f7">isinputactive</a>, <a class="el" href="classFuncCallSpecs.html#a08e150cc27ea477580875468dab13d5a">isoutputactive</a>, <a class="el" href="classFuncCallSpecs.html#acde16da75fc45aa08355abeebefa528ba584ec7401809588c22798803bff5b796">offset_unknown</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncCallSpecs.html#a303b8605ffd3e4432fb7ca3c70759f2d">paramshift</a>, <a class="el" href="classFuncCallSpecs.html#a0c685ecd38c4da586b8c7bddc2fd1983">stackoffset</a>, and <a class="el" href="classFuncCallSpecs.html#af655410c6704377c0d260b06fd532e22">stackPlaceholderSlot</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncCallSpecs.html#ac649b58eb85cf052096ac32e5ced8607">clone()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad3c3231b5c523e491d65f31ddb688cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c3231b5c523e491d65f31ddb688cc1">&#9670;&nbsp;</a></span>abortSpacebaseRelative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::abortSpacebaseRelative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort the attempt to recover the relative stack offset for <b>this</b> function. </p>
<p>Any stack-pointer <em>placeholder</em> is removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">Funcdata::opRemoveInput()</a>, and <a class="el" href="classFuncCallSpecs.html#af655410c6704377c0d260b06fd532e22">stackPlaceholderSlot</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHeritage.html#a8eee271623cb06fb85aa3d99fda9f653">Heritage::guardCalls()</a>.</p>

</div>
</div>
<a id="a1bb49b65cf036e8bc8b398e549b26a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb49b65cf036e8bc8b398e549b26a9c">&#9670;&nbsp;</a></span>buildInputFromTrials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::buildInputFromTrials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the final input Varnodes to <b>this</b> CALL based on <a class="el" href="classParamActive.html" title="Container class for ParamTrial objects.">ParamActive</a> analysis. </p>
<p>Varnodes that don't look like parameters are removed. Parameters that are unreferenced are filled in. Other <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> inputs may be truncated or extended. This prototype itself is unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#ae356496b5aa7f2c01cdbf0e929aba55d">activeinput</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classParamActive.html#a23ffb29ecb4569901e136929a50ac6b2">ParamActive::deleteUnusedTrials()</a>, <a class="el" href="classAddress.html#a208ce07ecf27e5c148d8395913831c2a">Address::getOffset()</a>, <a class="el" href="classAddress.html#a2e1cbf153126eebf5ba92f52c5dbc6a8">Address::getSpace()</a>, <a class="el" href="classAddrSpace.html#ab548f4158529a29122d4d0a30d94ed98">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">Funcdata::newOp()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">Funcdata::newVarnode()</a>, <a class="el" href="classFuncdata.html#a100e6704e4c245e076170268d31b47ec">Funcdata::newVarnodeOut()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">Funcdata::opInsertBefore()</a>, <a class="el" href="classFuncdata.html#adcad3bfd56955103a031fa6d0e78acec">Funcdata::opSetAllInput()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">Funcdata::opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">Funcdata::opSetOpcode()</a>, <a class="el" href="classFuncCallSpecs.html#a0c685ecd38c4da586b8c7bddc2fd1983">stackoffset</a>, and <a class="el" href="classAddrSpace.html#aaf923ed847e9804b55ffa12a51202712">AddrSpace::wrapOffset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classActionActiveParam.html#ab4bc14613f94c7114c1890d436c4d729">ActionActiveParam::apply()</a>.</p>

</div>
</div>
<a id="a15f172165e29fbabfbb02be245ee1c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f172165e29fbabfbb02be245ee1c98">&#9670;&nbsp;</a></span>buildOutputFromTrials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::buildOutputFromTrials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>trialvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the final output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> of <b>this</b> CALL based on <a class="el" href="classParamActive.html" title="Container class for ParamTrial objects.">ParamActive</a> analysis of trials. </p>
<p>If it exists, the active output trial is moved to be the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> of <b>this</b> CALL. If there are two active trials, they are merged as a single output of the CALL. Any INDIRECT ops that were holding the active trials are removed. This prototype itself is unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">trialvn</td><td>is the list of Varnodes associated with trials </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#a9b0d946a82d4f68de1e32333df36e1c5">activeoutput</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classParamActive.html#a23ffb29ecb4569901e136929a50ac6b2">ParamActive::deleteUnusedTrials()</a>, <a class="el" href="classFuncCallSpecs.html#a9a59b9321b66bc9f23e69d2ef729258c">findPreexistingWhole()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">Funcdata::newOp()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">Funcdata::newVarnode()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#a6976625d7b40efca0bc9941cb199ee44">Funcdata::opDestroy()</a>, <a class="el" href="classFuncdata.html#a3320ad92e11a48a06e21b8a55395a56b">Funcdata::opInsertAfter()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">Funcdata::opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">Funcdata::opSetOpcode()</a>, and <a class="el" href="classFuncdata.html#ab2bd3523c574c5b303728ef4d880ec3a">Funcdata::opSetOutput()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classActionActiveReturn.html#a69af2f49b35ac17b7e2cab3e6c0be11b">ActionActiveReturn::apply()</a>.</p>

</div>
</div>
<a id="aadf5f37e4556f80f027ae502a60092ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf5f37e4556f80f027ae502a60092ba">&#9670;&nbsp;</a></span>buildParam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * FuncCallSpecs::buildParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classProtoParameter.html">ProtoParameter</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>stackref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> representing a specific parameter. </p>
<p>If the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> holding the parameter directly as input to the CALL is available, it must be provided to this method. If it is not available, this assumes an (indirect) stack <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is needed and builds one. If the holding <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is the correct size it is returned, otherwise a truncated <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is constructed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">vn</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> holding the parameter (or NULL for a stack parameter) </td></tr>
    <tr><td class="paramname">param</td><td>is the actual parameter description </td></tr>
    <tr><td class="paramname">stackref</td><td>is the stack-pointer placeholder for <b>this</b> function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> that exactly matches the parameter </dd></dl>

<p class="reference">References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classAddress.html#a208ce07ecf27e5c148d8395913831c2a">Address::getOffset()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classAddress.html#a2e1cbf153126eebf5ba92f52c5dbc6a8">Address::getSpace()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">Funcdata::newOp()</a>, <a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">Funcdata::newUniqueOut()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">Funcdata::newVarnode()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">Funcdata::opInsertBefore()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">Funcdata::opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">Funcdata::opSetOpcode()</a>, and <a class="el" href="classFuncdata.html#a37b36505bab6f7c5676157288e65d5c6">Funcdata::opStackLoad()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncCallSpecs.html#a98405e6447b4ada292a557920b828d67">commitNewInputs()</a>.</p>

</div>
</div>
<a id="a808f3d0c962701b6c98bca1792e86908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808f3d0c962701b6c98bca1792e86908">&#9670;&nbsp;</a></span>checkInputJoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncCallSpecs::checkInputJoin </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ishislot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if adjacent parameter trials can be combined into a single logical parameter. </p>
<p>A slot must be provided indicating the trial and the only following it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot1</td><td>is the first trial slot </td></tr>
    <tr><td class="paramname">ishislot</td><td>is <b>true</b> if the first slot will be the most significant piece </td></tr>
    <tr><td class="paramname">vn1</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> corresponding to the first trial </td></tr>
    <tr><td class="paramname">vn2</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> corresponding to the second trial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the trials can be combined </dd></dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#ae356496b5aa7f2c01cdbf0e929aba55d">activeinput</a>, <a class="el" href="classFuncProto.html#a961837591bf1445a8db9d7604c1e5046">FuncProto::checkInputJoin()</a>, and <a class="el" href="classParamActive.html#a4ce9f8640c32eb48df409ff71a6e15eb">ParamActive::getTrialForInputVarnode()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classActionParamDouble.html#a8aad0e7534680ca4a79a20c196da103c">ActionParamDouble::apply()</a>.</p>

</div>
</div>
<a id="ab49917128896eb002c816e361f875943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49917128896eb002c816e361f875943">&#9670;&nbsp;</a></span>checkInputTrialUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::checkInputTrialUse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAliasChecker.html">AliasChecker</a> &amp;&#160;</td>
          <td class="paramname"><em>aliascheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark if input trials are being actively used. </p>
<p>Run through each input trial and try to make a determination if the trial is <em>active</em> or not, meaning basically that a write has occurred on the trial with no intervening reads between the write and the call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">aliascheck</td><td>holds local aliasing information about the function </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#ae356496b5aa7f2c01cdbf0e929aba55d">activeinput</a>, <a class="el" href="classFuncdata.html#adfa02a817ac34b428cac2a327d1891c0">Funcdata::ancestorOpUse()</a>, <a class="el" href="classAncestorRealistic.html#a5812787dc51e5f5238f8b595ed8cf084">AncestorRealistic::execute()</a>, <a class="el" href="classFuncProto.html#ad02f1ff6836640a55bba8055ed3b9349">FuncProto::extrapop</a>, <a class="el" href="classProtoModel.html#af44a0c8ef473b9506605a5d3329dafceab0874d825448e7c731717fad59bbec92">ProtoModel::extrapop_unknown</a>, <a class="el" href="classAliasChecker.html#a2bcaccaa3b0553741c68abf06115e113">AliasChecker::hasLocalAlias()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, and <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">Funcdata::opSetInput()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classActionActiveParam.html#ab4bc14613f94c7114c1890d436c4d729">ActionActiveParam::apply()</a>.</p>

</div>
</div>
<a id="a82c50f8299ce305411880fc61b8b1907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c50f8299ce305411880fc61b8b1907">&#9670;&nbsp;</a></span>checkOutputTrialUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::checkOutputTrialUse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>trialvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark if output trials are being actively used. </p>
<p>Run through each output trial and try to make a determination if the trial is <em>active</em> or not, meaning basically that the first occurrence of a trial after the call is a read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">trialvn</td><td>will hold Varnodes corresponding to the trials </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#a9b0d946a82d4f68de1e32333df36e1c5">activeoutput</a>, and <a class="el" href="classFuncCallSpecs.html#ad241f5566eb01acaa77327da464c7984">collectOutputTrialVarnodes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classActionActiveReturn.html#a69af2f49b35ac17b7e2cab3e6c0be11b">ActionActiveReturn::apply()</a>.</p>

</div>
</div>
<a id="ac649b58eb85cf052096ac32e5ced8607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac649b58eb85cf052096ac32e5ced8607">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> * FuncCallSpecs::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>newop</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone <b>this</b> given the mirrored p-code CALL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newop</td><td>replaces the CALL or CALLIND op in the clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cloned <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call.">FuncCallSpecs</a> </dd></dl>

<p class="reference">References <a class="el" href="classFuncProto.html#a9bd4f3bc764b11b57f4e71b9d19df27d">FuncProto::copy()</a>, <a class="el" href="classFuncCallSpecs.html#a0af7fe0e7b3d1486e41e528a1deec61f">effective_extrapop</a>, <a class="el" href="classFuncCallSpecs.html#ade06e0fcf372e92f2b62ac1e188439be">fd</a>, <a class="el" href="classFuncCallSpecs.html#a96cbd6a1b0311883aeb840f47e4a0ec7">FuncCallSpecs()</a>, <a class="el" href="classFuncCallSpecs.html#aaaa7e05c56f2cad157d9e72095cb53bd">isbadjumptable</a>, <a class="el" href="classFuncCallSpecs.html#a303b8605ffd3e4432fb7ca3c70759f2d">paramshift</a>, <a class="el" href="classFuncCallSpecs.html#ae2f63fcf31daa5cc5663df227a813f0a">setFuncdata()</a>, and <a class="el" href="classFuncCallSpecs.html#a0c685ecd38c4da586b8c7bddc2fd1983">stackoffset</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncdata.html#a122718ad87c13b714676c61050461388">Funcdata::truncatedFlow()</a>.</p>

</div>
</div>
<a id="ad241f5566eb01acaa77327da464c7984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad241f5566eb01acaa77327da464c7984">&#9670;&nbsp;</a></span>collectOutputTrialVarnodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::collectOutputTrialVarnodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>trialvn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collect <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> objects associated with each output trial</p>
<p>Varnodes can be attached to the CALL or CALLIND or one of the preceding INDIRECTs. They are passed back in a list matching the order of the trials. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trialvn</td><td>holds the resulting list of Varnodes </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#a9b0d946a82d4f68de1e32333df36e1c5">activeoutput</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classPcodeOp.html#a2d0518b850450346c635f9d04725be5e">PcodeOp::previousOp()</a>, and <a class="el" href="classParamActive.html#a94904915a57b3a27a68053e85d6d08e1">ParamActive::whichTrial()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncCallSpecs.html#a82c50f8299ce305411880fc61b8b1907">checkOutputTrialUse()</a>.</p>

</div>
</div>
<a id="a98405e6447b4ada292a557920b828d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98405e6447b4ada292a557920b828d67">&#9670;&nbsp;</a></span>commitNewInputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::commitNewInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>newinput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update input Varnodes to <b>this</b> CALL to reflect the formal input parameters. </p>
<p>The current input parameters must be locked and are presumably out of date with the current state of the CALL Varnodes. These existing input Varnodes must already be gathered in a list. Each <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is updated to reflect the parameters, which may involve truncating or extending. Any active trials and stack-pointer placeholder is updated, and the new Varnodes are set as the CALL input. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">newinput</td><td>holds old input Varnodes and will hold new input Varnodes </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#ae356496b5aa7f2c01cdbf0e929aba55d">activeinput</a>, <a class="el" href="classFuncCallSpecs.html#aadf5f37e4556f80f027ae502a60092ba">buildParam()</a>, <a class="el" href="classParamActive.html#afadcd4621258a53d5edd7f7d4430eb7b">ParamActive::clear()</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classAddress.html#a2e1cbf153126eebf5ba92f52c5dbc6a8">Address::getSpace()</a>, <a class="el" href="classFuncCallSpecs.html#afc88cbd3e19e0e1269680de99ee1521e">getSpacebaseRelative()</a>, <a class="el" href="classAddrSpace.html#ab548f4158529a29122d4d0a30d94ed98">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classFuncProto.html#aab52f093617d8bd8a67f011ba5a0d324">FuncProto::isInputLocked()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#adcad3bfd56955103a031fa6d0e78acec">Funcdata::opSetAllInput()</a>, <a class="el" href="classParamActive.html#a43a357162f55b3b8f7e13a013ad207b5">ParamActive::registerTrial()</a>, and <a class="el" href="classFuncCallSpecs.html#af655410c6704377c0d260b06fd532e22">stackPlaceholderSlot</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncCallSpecs.html#aad64d557811baf4602afcefb2746f7be">deindirect()</a>, and <a class="el" href="classFuncCallSpecs.html#a8bc0ef657c876530f21a6ae60458eb35">forceSet()</a>.</p>

</div>
</div>
<a id="aa357f1ecfa3c9bd2ab86d958bb0670b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa357f1ecfa3c9bd2ab86d958bb0670b4">&#9670;&nbsp;</a></span>commitNewOutputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::commitNewOutputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>newout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> to <b>this</b> CALL to reflect the formal return value. </p>
<p>The current return value must be locked and is presumably out of date with the current CALL output. Unless the return value is <em>void</em>, the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> must exist and must be provided. The <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is updated to reflect the return value, which may involve truncating or extending. Any active trials are updated, and the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is set as the CALL output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">newout</td><td>is the provided old output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> (or NULL) </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#a9b0d946a82d4f68de1e32333df36e1c5">activeoutput</a>, <a class="el" href="classFuncProto.html#a2550a272235e295512ee5eb7a2674638">FuncProto::assumedOutputExtension()</a>, <a class="el" href="classParamActive.html#afadcd4621258a53d5edd7f7d4430eb7b">ParamActive::clear()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a5fc7131a25cd3887d2ceabf181fa5b8a">CPUI_INT_SEXT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a778868cfa2191f9621f632672e596702">CPUI_INT_ZEXT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a69a387d1e0b510d027e69bdde8f03caa">CPUI_PIECE</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classProtoParameter.html#a05bfe5b4fe563c1e4e93bf2648239061">ProtoParameter::getType()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncdata.html#add1098b768d9a176cf59e4f4c9e27cb5">Funcdata::newIndirectCreation()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">Funcdata::newOp()</a>, <a class="el" href="classFuncdata.html#a100e6704e4c245e076170268d31b47ec">Funcdata::newVarnodeOut()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#a3320ad92e11a48a06e21b8a55395a56b">Funcdata::opInsertAfter()</a>, <a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">Funcdata::opRemoveInput()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">Funcdata::opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">Funcdata::opSetOpcode()</a>, <a class="el" href="classFuncdata.html#ab2bd3523c574c5b303728ef4d880ec3a">Funcdata::opSetOutput()</a>, <a class="el" href="classFuncdata.html#aacf0cf87976170d62df42411ffe1e10a">Funcdata::opUninsert()</a>, <a class="el" href="classFuncdata.html#a495ebac694bc98d041e29ce05eece6f9">Funcdata::opUnlink()</a>, <a class="el" href="classFuncdata.html#ab91b54da6501e12d4ad1e81ab5d0e5c4">Funcdata::opUnsetOutput()</a>, <a class="el" href="classParamActive.html#a43a357162f55b3b8f7e13a013ad207b5">ParamActive::registerTrial()</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa4fcd4421533bb21c827865bdbac4fef9">TYPE_INT</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncCallSpecs.html#aad64d557811baf4602afcefb2746f7be">deindirect()</a>, and <a class="el" href="classFuncCallSpecs.html#a8bc0ef657c876530f21a6ae60458eb35">forceSet()</a>.</p>

</div>
</div>
<a id="a57f3844d92136d3ab6b67ea9ea316aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f3844d92136d3ab6b67ea9ea316aa7">&#9670;&nbsp;</a></span>compareByEntryAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool FuncCallSpecs::compareByEntryAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call.">FuncCallSpecs</a> by function entry address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is the first <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call.">FuncCallSpecs</a> to compare </td></tr>
    <tr><td class="paramname">b</td><td>is the second to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the first should be ordered before the second </dd></dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#a1c5d10d1b705fb05f1ce581b7a6eeed6">entryaddress</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncCallSpecs.html#aab6fc72a11289af288ec65f216d7a45b">countMatchingCalls()</a>.</p>

</div>
</div>
<a id="aab6fc72a11289af288ec65f216d7a45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6fc72a11289af288ec65f216d7a45b">&#9670;&nbsp;</a></span>countMatchingCalls()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::countMatchingCalls </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>qlst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the number of times an individual sub-function is called. </p>
<p>Provided a list of all call sites for a calling function, tally the number of calls to the same sub-function. Update the <b>matchCallCount</b> field of each <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call.">FuncCallSpecs</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qlst</td><td>is the list of call sites (<a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call.">FuncCallSpecs</a>) for the calling function </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#a57f3844d92136d3ab6b67ea9ea316aa7">compareByEntryAddress()</a>, <a class="el" href="classFuncCallSpecs.html#a1c5d10d1b705fb05f1ce581b7a6eeed6">entryaddress</a>, <a class="el" href="classAddress.html#a90ea7ea47a048afa95a14709e704d876">Address::isInvalid()</a>, and <a class="el" href="classFuncCallSpecs.html#a33ee88ee6bc22078cb8f03dd71ea87d2">matchCallCount</a>.</p>

</div>
</div>
<a id="aad64d557811baf4602afcefb2746f7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad64d557811baf4602afcefb2746f7be">&#9670;&nbsp;</a></span>deindirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::deindirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td>
          <td class="paramname"><em>newfd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <b>this</b> call site from an indirect to a direct function call. </p>
<p>This call site must be a CALLIND, and the function that it is actually calling must be provided. The method makes a determination if the current state of data-flow allows converting to the prototype of the new function without dropping information due to inaccurate dead-code elimination. If conversion is safe, it is performed immediately. Otherwise a <em>restart</em> directive issued to force decompilation to restart from scratch (now with the direct function in hand) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">newfd</td><td>is the <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function.">Funcdata</a> object that we know is the destination of <b>this</b> CALLIND </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#a98405e6447b4ada292a557920b828d67">commitNewInputs()</a>, <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">commitNewOutputs()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a50235a7bf50bada36dff73ff740c34d0">CPUI_CALL</a>, <a class="el" href="classFuncCallSpecs.html#a1c5d10d1b705fb05f1ce581b7a6eeed6">entryaddress</a>, <a class="el" href="classFuncCallSpecs.html#ade06e0fcf372e92f2b62ac1e188439be">fd</a>, <a class="el" href="classFuncProto.html#a2f1510914c66b2201248a6a06d282948">FuncProto::isNoReturn()</a>, <a class="el" href="classFuncCallSpecs.html#ab55b52b70e4def9167d06709746635e9">lateRestriction()</a>, <a class="el" href="classFuncCallSpecs.html#aee4c4b25b4eba36052e847f41f110816">name</a>, <a class="el" href="classFuncdata.html#a13da637294b7cae252ffc6c9e2116da2">Funcdata::newVarnodeCallSpecs()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">Funcdata::opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">Funcdata::opSetOpcode()</a>, and <a class="el" href="classFuncdata.html#af21c852eb9f606c5cd19fb2456927ecd">Funcdata::setRestartPending()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classActionDeindirect.html#a4f54f89989ab5700bdac440960ed6fcf">ActionDeindirect::apply()</a>.</p>

</div>
</div>
<a id="a489441d9d77d08bdf87eff937e8ef5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489441d9d77d08bdf87eff937e8ef5b8">&#9670;&nbsp;</a></span>doInputJoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::doInputJoin </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ishislot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join two parameter trials. </p>
<p>We assume <a class="el" href="classFuncCallSpecs.html#a808f3d0c962701b6c98bca1792e86908" title="Check if adjacent parameter trials can be combined into a single logical parameter.">checkInputJoin()</a> has returned <b>true</b>. Perform the join, replacing the given adjacent trials with a single merged parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot1</td><td>is the trial slot of the first trial </td></tr>
    <tr><td class="paramname">ishislot</td><td>is <b>true</b> if the first slot will be the most significant piece </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#ae356496b5aa7f2c01cdbf0e929aba55d">activeinput</a>, <a class="el" href="classAddrSpaceManager.html#a1cfc5383270584be6e9b974114e65f13">AddrSpaceManager::constructJoinAddress()</a>, <a class="el" href="classParamActive.html#a4ce9f8640c32eb48df409ff71a6e15eb">ParamActive::getTrialForInputVarnode()</a>, <a class="el" href="classFuncProto.html#aab52f093617d8bd8a67f011ba5a0d324">FuncProto::isInputLocked()</a>, <a class="el" href="classParamActive.html#a593685d8f2f13f34e5c48f1f363c793d">ParamActive::joinTrial()</a>, and <a class="el" href="classArchitecture.html#a81f2db17fdc609a7d1cedbc0a2eb7753">Architecture::translate</a>.</p>

<p class="reference">Referenced by <a class="el" href="classActionParamDouble.html#a8aad0e7534680ca4a79a20c196da103c">ActionParamDouble::apply()</a>.</p>

</div>
</div>
<a id="a48998cb808c1feedcad257f0984317ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48998cb808c1feedcad257f0984317ed">&#9670;&nbsp;</a></span>finalInputCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::finalInputCheck </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make final activity check on trials that might have been affected by conditional execution. </p>
<p>The activity level a trial may change once conditional execution has been analyzed. This routine (re)checks trials that might be affected by this, which may then be converted to <em>not</em> <em>used</em>. </p>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#ae356496b5aa7f2c01cdbf0e929aba55d">activeinput</a>, <a class="el" href="classAncestorRealistic.html#a5812787dc51e5f5238f8b595ed8cf084">AncestorRealistic::execute()</a>, and <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>.</p>

<p class="reference">Referenced by <a class="el" href="classActionActiveParam.html#ab4bc14613f94c7114c1890d436c4d729">ActionActiveParam::apply()</a>.</p>

</div>
</div>
<a id="a9a59b9321b66bc9f23e69d2ef729258c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a59b9321b66bc9f23e69d2ef729258c">&#9670;&nbsp;</a></span>findPreexistingWhole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * FuncCallSpecs::findPreexistingWhole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if given two Varnodes are merged into a whole. </p>
<p>If the Varnodes are merged immediately into a common whole and aren't used for anything else, return the whole <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn1</td><td>is the first given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </td></tr>
    <tr><td class="paramname">vn2</td><td>is the second given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combined <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> or NULL </dd></dl>

<p class="reference">References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a69a387d1e0b510d027e69bdde8f03caa">CPUI_PIECE</a>, and <a class="el" href="classVarnode.html#a1899f1f493fed54c6dea1f445f146de6">Varnode::loneDescend()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncCallSpecs.html#a15f172165e29fbabfbb02be245ee1c98">buildOutputFromTrials()</a>.</p>

</div>
</div>
<a id="a8bc0ef657c876530f21a6ae60458eb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc0ef657c876530f21a6ae60458eb35">&#9670;&nbsp;</a></span>forceSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::forceSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force a more restrictive prototype on <b>this</b> call site. </p>
<p>A new prototype must be given, typically recovered from a function pointer data-type that has been propagated to <b>this</b> call site. The method makes a determination if the current state of data-flow allows converting to the new prototype without dropping information due to inaccurate dead-code elimination. If conversion is safe, it is performed immediately. Otherwise a <em>restart</em> directive issued to force decompilation to restart from scratch (now with the new prototype in hand) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">fp</td><td>is the new (more restrictive) function prototype </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#a98405e6447b4ada292a557920b828d67">commitNewInputs()</a>, <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">commitNewOutputs()</a>, <a class="el" href="classFuncProto.html#a9bd4f3bc764b11b57f4e71b9d19df27d">FuncProto::copy()</a>, <a class="el" href="classFuncProto.html#a9c7db7dec63a18a9de97b0ba9f6f42bd">FuncProto::FuncProto()</a>, <a class="el" href="classFuncProto.html#abeba6c216afa6ad43160d69a10433fab">FuncProto::hasInputErrors()</a>, <a class="el" href="classFuncProto.html#ace0306cd7ee2a040dd783bd5e7606370">FuncProto::hasOutputErrors()</a>, <a class="el" href="classFuncCallSpecs.html#ab55b52b70e4def9167d06709746635e9">lateRestriction()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncProto.html#ad5f36aaa3e2d1d7cdc90d101065abbc0">FuncProto::setInputErrors()</a>, <a class="el" href="classFuncProto.html#a4afe216709633a3b075111d6f1b7148f">FuncProto::setInputLock()</a>, <a class="el" href="classFuncProto.html#ac8eacd70fbc6e4cd5d694d2ae5b1ed64">FuncProto::setOutputErrors()</a>, and <a class="el" href="classFuncdata.html#af21c852eb9f606c5cd19fb2456927ecd">Funcdata::setRestartPending()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classActionDeindirect.html#a4f54f89989ab5700bdac440960ed6fcf">ActionDeindirect::apply()</a>.</p>

</div>
</div>
<a id="aa1d084c81a9ae8656d7ef79c84398dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d084c81a9ae8656d7ef79c84398dc8">&#9670;&nbsp;</a></span>getFspecFromConst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a>* FuncCallSpecs::getFspecFromConst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <a class="el" href="classFspecSpace.html" title="A special space for encoding FuncCallSpecs.">FspecSpace</a> addresses to the underlying <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call.">FuncCallSpecs</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given <em>fspec</em> address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call.">FuncCallSpecs</a> object </dd></dl>

<p class="reference">References <a class="el" href="classAddress.html#a208ce07ecf27e5c148d8395913831c2a">Address::getOffset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncCallSpecs.html#a96cbd6a1b0311883aeb840f47e4a0ec7">FuncCallSpecs()</a>, <a class="el" href="classFuncdata.html#a952f07a6db222c00cc243917767dcdc1">Funcdata::getCallSpecs()</a>, <a class="el" href="classTypeOpCall.html#ac92e69ea35780e349d3ca0cecef0a01e">TypeOpCall::getInputLocal()</a>, <a class="el" href="classTypeOpCall.html#a0900277daf94a76b57d96ba468514815">TypeOpCall::getOutputLocal()</a>, <a class="el" href="classFlowInfo.html#af91718ae694b4852c24f4af6cb0b07a0">FlowInfo::injectPcode()</a>, and <a class="el" href="classPrintC.html#aa03349d27cfe1d81e6e3854cd0eb9252">PrintC::opCall()</a>.</p>

</div>
</div>
<a id="ad15bd3498c19455047bf9b6b5af3df5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15bd3498c19455047bf9b6b5af3df5b">&#9670;&nbsp;</a></span>getInputBytesConsumed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int4 FuncCallSpecs::getInputBytesConsumed </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the estimated number of bytes within the given parameter that are consumed. </p>
<p>As a function is decompiled, there may hints about how many of the bytes, within the storage location used to pass the parameter, are used by <b>this</b> sub-function. A non-zero value means that that many least significant bytes of the storage location are used. A value of zero means all bytes are presumed used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>is the slot of the given input parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes used (or 0) </dd></dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#a9a0a35536be1d782a6ce613267b0400d">inputConsume</a>.</p>

<p class="reference">Referenced by <a class="el" href="classActionDeadCode.html#ab9d6ddd65fbafdded028b20e0df083fc">ActionDeadCode::markConsumedParameters()</a>.</p>

</div>
</div>
<a id="afc88cbd3e19e0e1269680de99ee1521e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc88cbd3e19e0e1269680de99ee1521e">&#9670;&nbsp;</a></span>getSpacebaseRelative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * FuncCallSpecs::getSpacebaseRelative </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the active stack-pointer <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> at <b>this</b> call site. </p>
<p>Find an instance of the stack-pointer (spacebase register) that is active at the point of <b>this</b> CALL, by examining the <em>stack-pointer</em> <em>placeholder</em> slot. </p><dl class="section return"><dt>Returns</dt><dd>the stack-pointer <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </dd></dl>

<p class="reference">References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ad76724dd2fcd9df1dca7e09e6427f10f">CPUI_LOAD</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, and <a class="el" href="classFuncCallSpecs.html#af655410c6704377c0d260b06fd532e22">stackPlaceholderSlot</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncCallSpecs.html#a98405e6447b4ada292a557920b828d67">commitNewInputs()</a>, and <a class="el" href="classFuncCallSpecs.html#a51c269dac5b3730ea0093d2bc6841b07">transferLockedInput()</a>.</p>

</div>
</div>
<a id="a37a11cd8c631ed5b643eaf259b2ae49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a11cd8c631ed5b643eaf259b2ae49b">&#9670;&nbsp;</a></span>hasEffectTranslate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint4 FuncCallSpecs::hasEffectTranslate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate type of side-effect for a given storage location (with caller translation) </p>
<p>Stack locations should be provided from the caller's perspective. They are automatically translated to the callee's perspective before making the underlying query. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the storage location </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the effect type </dd></dl>

<p class="reference">References <a class="el" href="classAddress.html#a208ce07ecf27e5c148d8395913831c2a">Address::getOffset()</a>, <a class="el" href="classAddress.html#a2e1cbf153126eebf5ba92f52c5dbc6a8">Address::getSpace()</a>, <a class="el" href="classAddrSpace.html#ab548f4158529a29122d4d0a30d94ed98">AddrSpace::getType()</a>, <a class="el" href="classFuncProto.html#a906c0e176919bd0ced34e337445c2bf7">FuncProto::hasEffect()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classFuncCallSpecs.html#acde16da75fc45aa08355abeebefa528ba584ec7401809588c22798803bff5b796">offset_unknown</a>, <a class="el" href="classFuncCallSpecs.html#a0c685ecd38c4da586b8c7bddc2fd1983">stackoffset</a>, <a class="el" href="classEffectRecord.html#a66f235e47631f3fdec63fd78957b6878a02697f294ad0f4b53317da792c577a10">EffectRecord::unknown_effect</a>, and <a class="el" href="classAddrSpace.html#aaf923ed847e9804b55ffa12a51202712">AddrSpace::wrapOffset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHeritage.html#a8c555ffb072004ece3cb61191127dab2">Heritage::callOpIndirectEffect()</a>, and <a class="el" href="classHeritage.html#a8eee271623cb06fb85aa3d99fda9f653">Heritage::guardCalls()</a>.</p>

</div>
</div>
<a id="aae6a890aaa82deca59ec7c57c92629aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6a890aaa82deca59ec7c57c92629aa">&#9670;&nbsp;</a></span>insertPcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::insertPcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject any <em>upon-return</em> p-code at <b>this</b> call site. </p>
<p>This function prototype may trigger injection of p-code immediately after the CALL or CALLIND to mimic a portion of the callee that decompilation of the caller otherwise wouldn't see. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classFuncdata.html#adb1dd79d78141f89d374e570de21d690">Funcdata::doLiveInject()</a>, <a class="el" href="classFuncProto.html#a0d6fe1d0e0e45e71b366020d00914319">FuncProto::injectid</a>, and <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>.</p>

<p class="reference">Referenced by <a class="el" href="classActionDefaultParams.html#a32f4c196d02d9f86c66749b9bf5d2247">ActionDefaultParams::apply()</a>.</p>

</div>
</div>
<a id="ab55b52b70e4def9167d06709746635e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55b52b70e4def9167d06709746635e9">&#9670;&nbsp;</a></span>lateRestriction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncCallSpecs::lateRestriction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;&#160;</td>
          <td class="paramname"><em>restrictedProto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>newinput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&amp;&#160;</td>
          <td class="paramname"><em>newoutput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update <b>this</b> prototype to match a given (more specialized) prototype. </p>
<p>This method assumes that <b>this</b> prototype is in some intermediate state during the parameter recovery process and that a new definitive (locked) prototype is discovered for <b>this</b> call site. This method checks to see if <b>this</b> can be updated to match the new prototype without missing any data-flow. If so, <b>this</b> is updated, and new input and output Varnodes for the CALL are passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">restrictedProto</td><td>is the new definitive function prototype </td></tr>
    <tr><td class="paramname">newinput</td><td>will hold the new list of input Varnodes for the CALL </td></tr>
    <tr><td class="paramname">newoutput</td><td>will hold the new output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if <b>this</b> can be fully converted </dd></dl>

<p class="reference">References <a class="el" href="classFuncProto.html#a9bd4f3bc764b11b57f4e71b9d19df27d">FuncProto::copy()</a>, <a class="el" href="classFuncProto.html#aa5ee60788e6d8b4de304e2c5955a393b">FuncProto::isCompatible()</a>, <a class="el" href="classFuncCallSpecs.html#ab19a159dce6a7370b84dba2ff11637f7">isinputactive</a>, <a class="el" href="classFuncProto.html#aab52f093617d8bd8a67f011ba5a0d324">FuncProto::isInputLocked()</a>, <a class="el" href="classFuncCallSpecs.html#a51c269dac5b3730ea0093d2bc6841b07">transferLockedInput()</a>, and <a class="el" href="classFuncCallSpecs.html#aed1cb380c5ca6bf3d02f441cf582c50e">transferLockedOutput()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncCallSpecs.html#aad64d557811baf4602afcefb2746f7be">deindirect()</a>, and <a class="el" href="classFuncCallSpecs.html#a8bc0ef657c876530f21a6ae60458eb35">forceSet()</a>.</p>

</div>
</div>
<a id="a01e16ebebb71bdc63fb884c8d0e3b7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e16ebebb71bdc63fb884c8d0e3b7e3">&#9670;&nbsp;</a></span>paramshiftModifyStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncCallSpecs::paramshiftModifyStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throw out any paramshift parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a change was made </dd></dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">Funcdata::opRemoveInput()</a>, <a class="el" href="classFuncCallSpecs.html#a303b8605ffd3e4432fb7ca3c70759f2d">paramshift</a>, and <a class="el" href="classFuncProto.html#ab1a494d8691b68a76a56495907ab9f6d">FuncProto::setParamshiftApplied()</a>.</p>

</div>
</div>
<a id="a5ad2a3f374049dec6fdf0f9d20295305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad2a3f374049dec6fdf0f9d20295305">&#9670;&nbsp;</a></span>resolveSpacebaseRelative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::resolveSpacebaseRelative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>phvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the stack offset of <b>this</b> call site. </p>
<p>The given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> must be the input to the CALL in the <em>placeholder</em> slot and must be defined by a COPY from a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> in the stack space. Calculate the offset of the stack-pointer at the point of <b>this</b> CALL, relative to the incoming stack-pointer value. This can be obtained either be looking at a stack parameter, or if there is no stack parameter, the stack-pointer <em>placeholder</em> can be used. If the <em>placeholder</em> has no other purpose, remove it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">phvn</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> in the <em>placeholder</em> slot for <b>this</b> CALL </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classAddress.html#a208ce07ecf27e5c148d8395913831c2a">Address::getOffset()</a>, <a class="el" href="classPcodeOp.html#a3bf80a4ef518e6a41cc0f0e8ae08e7b4">PcodeOp::getSlot()</a>, <a class="el" href="classAddress.html#a2e1cbf153126eebf5ba92f52c5dbc6a8">Address::getSpace()</a>, <a class="el" href="classAddrSpace.html#ab548f4158529a29122d4d0a30d94ed98">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classFuncProto.html#aab52f093617d8bd8a67f011ba5a0d324">FuncProto::isInputLocked()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">Funcdata::opRemoveInput()</a>, <a class="el" href="classFuncCallSpecs.html#a0c685ecd38c4da586b8c7bddc2fd1983">stackoffset</a>, <a class="el" href="classFuncCallSpecs.html#af655410c6704377c0d260b06fd532e22">stackPlaceholderSlot</a>, <a class="el" href="classFuncdata.html#a87967b12187406a7fdf311cc4b836118">Funcdata::warningHeader()</a>, and <a class="el" href="classAddrSpace.html#aaf923ed847e9804b55ffa12a51202712">AddrSpace::wrapOffset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRuleLoadVarnode.html#aba1b981179387a727272c5ba7b407777">RuleLoadVarnode::applyOp()</a>.</p>

</div>
</div>
<a id="acb672e7f2a55179e16d4270143580093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb672e7f2a55179e16d4270143580093">&#9670;&nbsp;</a></span>setInputBytesConsumed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncCallSpecs::setInputBytesConsumed </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the estimated number of bytes within the given parameter that are consumed. </p>
<p>This provides a hint to the dead code <em>consume</em> algorithm, while examining the calling function, about how the given parameter within the subfunction is used. A non-zero value means that that many least significant bytes of the storage location are used. A value of zero means all bytes are presumed used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>is the slot of the given input parameter </td></tr>
    <tr><td class="paramname">val</td><td>is the number of bytes consumed (or 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if there was a change in the estimate </dd></dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#a9a0a35536be1d782a6ce613267b0400d">inputConsume</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRulePiecePathology.html#a681659c18d630bbf9064fbf7191dd02d">RulePiecePathology::tracePathologyForward()</a>.</p>

</div>
</div>
<a id="a51c269dac5b3730ea0093d2bc6841b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c269dac5b3730ea0093d2bc6841b07">&#9670;&nbsp;</a></span>transferLockedInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncCallSpecs::transferLockedInput </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>newinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List and/or create a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> for each input parameter of <b>this</b> prototype. </p>
<p>Varnodes will be passed back in order that match current input parameters. A NULL <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> indicates a stack parameter. <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> dimensions may not match parameter dimensions exactly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newinput</td><td>will hold the resulting list of Varnodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>false</b> only if the list needs to indicate stack variables and there is no stack-pointer placeholder </dd></dl>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#afc88cbd3e19e0e1269680de99ee1521e">getSpacebaseRelative()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, and <a class="el" href="classFuncCallSpecs.html#a3ea6ae61949247b9e8c4643ce68860e3">transferLockedInputParam()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncCallSpecs.html#ab55b52b70e4def9167d06709746635e9">lateRestriction()</a>.</p>

</div>
</div>
<a id="a3ea6ae61949247b9e8c4643ce68860e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea6ae61949247b9e8c4643ce68860e3">&#9670;&nbsp;</a></span>transferLockedInputParam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 FuncCallSpecs::transferLockedInputParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classProtoParameter.html">ProtoParameter</a> *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index of the CALL input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> that matches the given parameter. </p>
<p>This method facilitates the building of a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> matching the given parameter from existing data-flow. Return either:</p><ul>
<li>0 if the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> can't be built</li>
<li>slot# for the input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> to reuse</li>
<li>-1 if the parameter needs to be built from the stack <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>is the given parameter to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the encoded slot </dd></dl>
</li>
</ul>

<p class="reference">References <a class="el" href="classFuncCallSpecs.html#ae356496b5aa7f2c01cdbf0e929aba55d">activeinput</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classAddress.html#a2e1cbf153126eebf5ba92f52c5dbc6a8">Address::getSpace()</a>, <a class="el" href="classAddrSpace.html#ab548f4158529a29122d4d0a30d94ed98">AddrSpace::getType()</a>, and <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncCallSpecs.html#a51c269dac5b3730ea0093d2bc6841b07">transferLockedInput()</a>.</p>

</div>
</div>
<a id="aed1cb380c5ca6bf3d02f441cf582c50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1cb380c5ca6bf3d02f441cf582c50e">&#9670;&nbsp;</a></span>transferLockedOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncCallSpecs::transferLockedOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&amp;&#160;</td>
          <td class="paramname"><em>newoutput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass back the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> needed to match the output parameter (return value) </p>
<p>Search for the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> matching the current output parameter and pass it back. The dimensions of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> may not exactly match the return value. If the return value is e void, a NULL is passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newoutput</td><td>will hold the passed back <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the passed back value is accurate </dd></dl>

<p class="reference">References <a class="el" href="classProtoParameter.html#a05bfe5b4fe563c1e4e93bf2648239061">ProtoParameter::getType()</a>, <a class="el" href="classFuncCallSpecs.html#a077b8ed8181bb5523e1be06583d3d588">transferLockedOutputParam()</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa84de340fe64164ed0dcf473aad846961">TYPE_VOID</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncCallSpecs.html#ab55b52b70e4def9167d06709746635e9">lateRestriction()</a>.</p>

</div>
</div>
<a id="a077b8ed8181bb5523e1be06583d3d588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077b8ed8181bb5523e1be06583d3d588">&#9670;&nbsp;</a></span>transferLockedOutputParam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * FuncCallSpecs::transferLockedOutputParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classProtoParameter.html">ProtoParameter</a> *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the p-code op whose output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> corresponds to the given parameter (return value)</p>
<p>The <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> may be attached to the base CALL or CALLIND, but it also may be attached to an INDIRECT preceding the CALL. The output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> may not exactly match the dimensions of the given parameter. We return non-null if either:</p><ul>
<li>The parameter contains the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> (the easier case) OR if</li>
<li>The <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> properly contains the parameter <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>is the given paramter (return value) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a> or NULL </dd></dl>
</li>
</ul>

<p class="reference">References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classAddress.html#a71d6969466b6edf50b9542e6a75dc439">Address::justifiedContain()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, and <a class="el" href="classPcodeOp.html#a2d0518b850450346c635f9d04725be5e">PcodeOp::previousOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncCallSpecs.html#aed1cb380c5ca6bf3d02f441cf582c50e">transferLockedOutput()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="fspec_8hh.html">fspec.hh</a></li>
<li>fspec.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
