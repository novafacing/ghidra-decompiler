<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>decompiler: ValueSetSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classValueSetSolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ValueSetSolver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class that determines a <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem.">ValueSet</a> for each <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> in a data-flow system.  
 <a href="classValueSetSolver.html#details">More...</a></p>

<p><code>#include &lt;rangeutil.hh&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver_1_1ValueSetEdge.html">ValueSetEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over out-bound edges for a single <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem.">ValueSet</a> node in a data-flow system.  <a href="classValueSetSolver_1_1ValueSetEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43a4cb32e3aef1c1cb92cd5b8d6dd300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a43a4cb32e3aef1c1cb92cd5b8d6dd300">establishValueSets</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;sinks, const vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;reads, <a class="el" href="classVarnode.html">Varnode</a> *stackReg, bool indirectAsCopy)</td></tr>
<tr class="memdesc:a43a4cb32e3aef1c1cb92cd5b8d6dd300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build value sets for a data-flow system.  <a href="classValueSetSolver.html#a43a4cb32e3aef1c1cb92cd5b8d6dd300">More...</a><br /></td></tr>
<tr class="separator:a43a4cb32e3aef1c1cb92cd5b8d6dd300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dec4550f9502575b92ca93bf997185c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a8dec4550f9502575b92ca93bf997185c">solve</a> (int4 max, <a class="el" href="classWidener.html">Widener</a> &amp;widener)</td></tr>
<tr class="memdesc:a8dec4550f9502575b92ca93bf997185c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate the <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem.">ValueSet</a> system until it stabilizes.  <a href="classValueSetSolver.html#a8dec4550f9502575b92ca93bf997185c">More...</a><br /></td></tr>
<tr class="separator:a8dec4550f9502575b92ca93bf997185c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aaa7e03150bb730888b0a41b470a845cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#aaa7e03150bb730888b0a41b470a845cb">newValueSet</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, int4 tCode)</td></tr>
<tr class="memdesc:aaa7e03150bb730888b0a41b470a845cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate storage for a new <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem.">ValueSet</a>.  <a href="classValueSetSolver.html#aaa7e03150bb730888b0a41b470a845cb">More...</a><br /></td></tr>
<tr class="separator:aaa7e03150bb730888b0a41b470a845cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45d0eae011647af953863a4d9145f47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#af45d0eae011647af953863a4d9145f47">partitionSurround</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part)</td></tr>
<tr class="memdesc:af45d0eae011647af953863a4d9145f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a full partition component.  <a href="classValueSetSolver.html#af45d0eae011647af953863a4d9145f47">More...</a><br /></td></tr>
<tr class="separator:af45d0eae011647af953863a4d9145f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a09332b5c711af6adc8b9603b5b9bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a97a09332b5c711af6adc8b9603b5b9bc">component</a> (<a class="el" href="classValueSet.html">ValueSet</a> *vertex, <a class="el" href="classPartition.html">Partition</a> &amp;part)</td></tr>
<tr class="memdesc:a97a09332b5c711af6adc8b9603b5b9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a partition component given its head.  <a href="classValueSetSolver.html#a97a09332b5c711af6adc8b9603b5b9bc">More...</a><br /></td></tr>
<tr class="separator:a97a09332b5c711af6adc8b9603b5b9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4d625b2cec5d8712551e63737f42b8"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#add4d625b2cec5d8712551e63737f42b8">visit</a> (<a class="el" href="classValueSet.html">ValueSet</a> *vertex, <a class="el" href="classPartition.html">Partition</a> &amp;part)</td></tr>
<tr class="memdesc:add4d625b2cec5d8712551e63737f42b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively walk the data-flow graph finding partitions.  <a href="classValueSetSolver.html#add4d625b2cec5d8712551e63737f42b8">More...</a><br /></td></tr>
<tr class="separator:add4d625b2cec5d8712551e63737f42b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a3f29f53647357d726347855bc3df7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a81a3f29f53647357d726347855bc3df7">establishTopologicalOrder</a> (void)</td></tr>
<tr class="memdesc:a81a3f29f53647357d726347855bc3df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the optimal order for iterating through the ValueSets.  <a href="classValueSetSolver.html#a81a3f29f53647357d726347855bc3df7">More...</a><br /></td></tr>
<tr class="separator:a81a3f29f53647357d726347855bc3df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129d92ea3879a4ca9dc26d6b1c7d28ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a129d92ea3879a4ca9dc26d6b1c7d28ea">generateTrueEquation</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, int4 slot, int4 type, const <a class="el" href="classCircleRange.html">CircleRange</a> &amp;range)</td></tr>
<tr class="memdesc:a129d92ea3879a4ca9dc26d6b1c7d28ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an equation given a <b>true</b> constraint and the input/output Varnodes it affects.  <a href="classValueSetSolver.html#a129d92ea3879a4ca9dc26d6b1c7d28ea">More...</a><br /></td></tr>
<tr class="separator:a129d92ea3879a4ca9dc26d6b1c7d28ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e500970c198d5d59cf05dbb9b359ee0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a6e500970c198d5d59cf05dbb9b359ee0">generateFalseEquation</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, int4 slot, int4 type, const <a class="el" href="classCircleRange.html">CircleRange</a> &amp;range)</td></tr>
<tr class="memdesc:a6e500970c198d5d59cf05dbb9b359ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the complementary equation given a <b>true</b> constraint and the input/output Varnodes it affects.  <a href="classValueSetSolver.html#a6e500970c198d5d59cf05dbb9b359ee0">More...</a><br /></td></tr>
<tr class="separator:a6e500970c198d5d59cf05dbb9b359ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629f30eb1a0d4f35bc9bc3a855813be5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a629f30eb1a0d4f35bc9bc3a855813be5">applyConstraints</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, int4 type, const <a class="el" href="classCircleRange.html">CircleRange</a> &amp;range, <a class="el" href="classPcodeOp.html">PcodeOp</a> *cbranch)</td></tr>
<tr class="memdesc:a629f30eb1a0d4f35bc9bc3a855813be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for PcodeOps where the given constraint range applies and instantiate an equation.  <a href="classValueSetSolver.html#a629f30eb1a0d4f35bc9bc3a855813be5">More...</a><br /></td></tr>
<tr class="separator:a629f30eb1a0d4f35bc9bc3a855813be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874fc29428abfe7c8b503f8daae65558"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a874fc29428abfe7c8b503f8daae65558">constraintsFromPath</a> (int4 type, <a class="el" href="classCircleRange.html">CircleRange</a> &amp;lift, <a class="el" href="classVarnode.html">Varnode</a> *startVn, <a class="el" href="classVarnode.html">Varnode</a> *endVn, <a class="el" href="classPcodeOp.html">PcodeOp</a> *cbranch)</td></tr>
<tr class="memdesc:a874fc29428abfe7c8b503f8daae65558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate constraints given a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> path.  <a href="classValueSetSolver.html#a874fc29428abfe7c8b503f8daae65558">More...</a><br /></td></tr>
<tr class="separator:a874fc29428abfe7c8b503f8daae65558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e256b19fd0b267fe7d356c2bbff0f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a69e256b19fd0b267fe7d356c2bbff0f4">constraintsFromCBranch</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *cbranch)</td></tr>
<tr class="memdesc:a69e256b19fd0b267fe7d356c2bbff0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate constraints arising from the given branch.  <a href="classValueSetSolver.html#a69e256b19fd0b267fe7d356c2bbff0f4">More...</a><br /></td></tr>
<tr class="separator:a69e256b19fd0b267fe7d356c2bbff0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4371470235d727b0981667f86fefa545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a4371470235d727b0981667f86fefa545">generateConstraints</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;worklist, const vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;reads)</td></tr>
<tr class="memdesc:a4371470235d727b0981667f86fefa545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate constraints given a system of Varnodes.  <a href="classValueSetSolver.html#a4371470235d727b0981667f86fefa545">More...</a><br /></td></tr>
<tr class="separator:a4371470235d727b0981667f86fefa545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08af331cd9e5598111ac03a699c0df5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a08af331cd9e5598111ac03a699c0df5e">checkRelativeConstant</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, int4 &amp;typeCode, uintb &amp;value) const</td></tr>
<tr class="memdesc:a08af331cd9e5598111ac03a699c0df5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is a <em>relative</em> constant.  <a href="classValueSetSolver.html#a08af331cd9e5598111ac03a699c0df5e">More...</a><br /></td></tr>
<tr class="separator:a08af331cd9e5598111ac03a699c0df5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842872867cb49258c51084165f4a0f20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a842872867cb49258c51084165f4a0f20">generateRelativeConstraint</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *compOp, <a class="el" href="classPcodeOp.html">PcodeOp</a> *cbranch)</td></tr>
<tr class="memdesc:a842872867cb49258c51084165f4a0f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a <em>relative</em> constraint.  <a href="classValueSetSolver.html#a842872867cb49258c51084165f4a0f20">More...</a><br /></td></tr>
<tr class="separator:a842872867cb49258c51084165f4a0f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a6368c360ac7ce1322173feef9635bbc4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a6368c360ac7ce1322173feef9635bbc4">partitionPrepend</a> (<a class="el" href="classValueSet.html">ValueSet</a> *vertex, <a class="el" href="classPartition.html">Partition</a> &amp;part)</td></tr>
<tr class="memdesc:a6368c360ac7ce1322173feef9635bbc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend a vertex to a partition.  <a href="classValueSetSolver.html#a6368c360ac7ce1322173feef9635bbc4">More...</a><br /></td></tr>
<tr class="separator:a6368c360ac7ce1322173feef9635bbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73e4960de77e935167bf388f934e1e8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#aa73e4960de77e935167bf388f934e1e8">partitionPrepend</a> (const <a class="el" href="classPartition.html">Partition</a> &amp;head, <a class="el" href="classPartition.html">Partition</a> &amp;part)</td></tr>
<tr class="memdesc:aa73e4960de77e935167bf388f934e1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend full <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together.">Partition</a> to given <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together.">Partition</a>.  <a href="classValueSetSolver.html#aa73e4960de77e935167bf388f934e1e8">More...</a><br /></td></tr>
<tr class="separator:aa73e4960de77e935167bf388f934e1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a2b98c0f17a24b50706fb322ee6145c14"><td class="memItemLeft" align="right" valign="top"><a id="a2b98c0f17a24b50706fb322ee6145c14"></a>
list&lt; <a class="el" href="classValueSet.html">ValueSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a2b98c0f17a24b50706fb322ee6145c14">valueNodes</a></td></tr>
<tr class="memdesc:a2b98c0f17a24b50706fb322ee6145c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for all the current value sets. <br /></td></tr>
<tr class="separator:a2b98c0f17a24b50706fb322ee6145c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb788965618ec854d93fcdb7c284f87"><td class="memItemLeft" align="right" valign="top"><a id="aebb788965618ec854d93fcdb7c284f87"></a>
map&lt; <a class="el" href="classSeqNum.html">SeqNum</a>, <a class="el" href="classValueSetRead.html">ValueSetRead</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#aebb788965618ec854d93fcdb7c284f87">readNodes</a></td></tr>
<tr class="memdesc:aebb788965618ec854d93fcdb7c284f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional, after iteration, add-on value sets. <br /></td></tr>
<tr class="separator:aebb788965618ec854d93fcdb7c284f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4daef35e9b2e16edabb0aee04c26919"><td class="memItemLeft" align="right" valign="top"><a id="ac4daef35e9b2e16edabb0aee04c26919"></a>
<a class="el" href="classPartition.html">Partition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#ac4daef35e9b2e16edabb0aee04c26919">orderPartition</a></td></tr>
<tr class="memdesc:ac4daef35e9b2e16edabb0aee04c26919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value sets in iteration order. <br /></td></tr>
<tr class="separator:ac4daef35e9b2e16edabb0aee04c26919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50feee21009569676cbc28dfb31904f6"><td class="memItemLeft" align="right" valign="top"><a id="a50feee21009569676cbc28dfb31904f6"></a>
list&lt; <a class="el" href="classPartition.html">Partition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a50feee21009569676cbc28dfb31904f6">recordStorage</a></td></tr>
<tr class="memdesc:a50feee21009569676cbc28dfb31904f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the Partitions establishing components. <br /></td></tr>
<tr class="separator:a50feee21009569676cbc28dfb31904f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3112c1fb71e8f9fa95d809a75c0d3916"><td class="memItemLeft" align="right" valign="top"><a id="a3112c1fb71e8f9fa95d809a75c0d3916"></a>
vector&lt; <a class="el" href="classValueSet.html">ValueSet</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a3112c1fb71e8f9fa95d809a75c0d3916">rootNodes</a></td></tr>
<tr class="memdesc:a3112c1fb71e8f9fa95d809a75c0d3916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values treated as inputs. <br /></td></tr>
<tr class="separator:a3112c1fb71e8f9fa95d809a75c0d3916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4418321d42d23d4ee75f25230e974690"><td class="memItemLeft" align="right" valign="top"><a id="a4418321d42d23d4ee75f25230e974690"></a>
vector&lt; <a class="el" href="classValueSet.html">ValueSet</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a4418321d42d23d4ee75f25230e974690">nodeStack</a></td></tr>
<tr class="memdesc:a4418321d42d23d4ee75f25230e974690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack used to generate the topological ordering. <br /></td></tr>
<tr class="separator:a4418321d42d23d4ee75f25230e974690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0295aa881504af04699a83348725e14a"><td class="memItemLeft" align="right" valign="top"><a id="a0295aa881504af04699a83348725e14a"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a0295aa881504af04699a83348725e14a">depthFirstIndex</a></td></tr>
<tr class="memdesc:a0295aa881504af04699a83348725e14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Global) depth first numbering for topological ordering <br /></td></tr>
<tr class="separator:a0295aa881504af04699a83348725e14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb7c05d75bf03cd7c7d50a05adce80f"><td class="memItemLeft" align="right" valign="top"><a id="adfb7c05d75bf03cd7c7d50a05adce80f"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#adfb7c05d75bf03cd7c7d50a05adce80f">numIterations</a></td></tr>
<tr class="memdesc:adfb7c05d75bf03cd7c7d50a05adce80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of individual <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem.">ValueSet</a> iterations. <br /></td></tr>
<tr class="separator:adfb7c05d75bf03cd7c7d50a05adce80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be76d1ba9fdfe55bcb003e490bfc3e2"><td class="memItemLeft" align="right" valign="top"><a id="a3be76d1ba9fdfe55bcb003e490bfc3e2"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a3be76d1ba9fdfe55bcb003e490bfc3e2">maxIterations</a></td></tr>
<tr class="memdesc:a3be76d1ba9fdfe55bcb003e490bfc3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations before forcing termination. <br /></td></tr>
<tr class="separator:a3be76d1ba9fdfe55bcb003e490bfc3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that determines a <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem.">ValueSet</a> for each <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> in a data-flow system. </p>
<p>This class uses <em>value</em> <em>set</em> <em>analysis</em> to calculate (an overestimation of) the range of values that can reach each <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a>. The system is formed by providing a set of Varnodes for which the range is desired (the sinks) via <a class="el" href="classValueSetSolver.html#a43a4cb32e3aef1c1cb92cd5b8d6dd300" title="Build value sets for a data-flow system.">establishValueSets()</a>. This creates a system of Varnodes (within the single function) that can flow to the sinks. Running the method <a class="el" href="classValueSetSolver.html#a8dec4550f9502575b92ca93bf997185c" title="Iterate the ValueSet system until it stabilizes.">solve()</a> does the analysis, and the caller can examine the results by examining the <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem.">ValueSet</a> attached to any of the Varnodes in the system (via Varnode::getValueSet()). The <a class="el" href="classValueSetSolver.html#a8dec4550f9502575b92ca93bf997185c" title="Iterate the ValueSet system until it stabilizes.">ValueSetSolver::solve()</a> starts with minimal value sets and does iteration steps by pushing them through the PcodeOps until stability is reached. A <a class="el" href="classWidener.html" title="Class holding a particular widening strategy for the ValueSetSolver iteration algorithm.">Widener</a> object is passed to <a class="el" href="classValueSetSolver.html#a8dec4550f9502575b92ca93bf997185c" title="Iterate the ValueSet system until it stabilizes.">solve()</a> which selects the specific strategy for accelerating convergence. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a629f30eb1a0d4f35bc9bc3a855813be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629f30eb1a0d4f35bc9bc3a855813be5">&#9670;&nbsp;</a></span>applyConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::applyConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCircleRange.html">CircleRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>cbranch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look for PcodeOps where the given constraint range applies and instantiate an equation. </p>
<p>If a read of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is in a basic block dominated by the condition producing the constraint, then either the constraint or its complement applies to the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a> reading the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a>. An equation holding the constraint is added to the <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem.">ValueSet</a> of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> output of the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </td></tr>
    <tr><td class="paramname">type</td><td>is the constraint characteristic </td></tr>
    <tr><td class="paramname">range</td><td>is the known constraint (assuming the <b>true</b> branch was taken) </td></tr>
    <tr><td class="paramname">cbranch</td><td>is conditional branch creating the constraint </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classValueSetSolver.html#a6e500970c198d5d59cf05dbb9b359ee0">generateFalseEquation()</a>, <a class="el" href="classValueSetSolver.html#a129d92ea3879a4ca9dc26d6b1c7d28ea">generateTrueEquation()</a>, <a class="el" href="classPcodeOp.html#a3bf80a4ef518e6a41cc0f0e8ae08e7b4">PcodeOp::getSlot()</a>, <a class="el" href="classPcodeOp.html#a372abd9553271da8620c4b9597f4e2aa">PcodeOp::isBooleanFlip()</a>, <a class="el" href="classValueSet.html#ad6178f7f7c6875a30070907559143ebf">ValueSet::opCode</a>, and <a class="el" href="classFlowBlock.html#a00ebb66879a68e1d4ddd0fb30a218d0f">FlowBlock::restrictedByConditional()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classValueSetSolver.html#a874fc29428abfe7c8b503f8daae65558">constraintsFromPath()</a>.</p>

</div>
</div>
<a id="a08af331cd9e5598111ac03a699c0df5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08af331cd9e5598111ac03a699c0df5e">&#9670;&nbsp;</a></span>checkRelativeConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ValueSetSolver::checkRelativeConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4 &amp;&#160;</td>
          <td class="paramname"><em>typeCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is a <em>relative</em> constant. </p>
<p>Verify that the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is produced by a straight line sequence of COPYs, INT_ADDs with a constant, from the base register marked as <em>relative</em> for our system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </td></tr>
    <tr><td class="paramname">typeCode</td><td>will hold the base register code (if found) </td></tr>
    <tr><td class="paramname">value</td><td>will hold the additive value relative to the base register (if found) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is a <em>relative</em> constant </dd></dl>

<p class="reference">References <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7acd169003bfcb2e8dde0cb2dc1f534449">CPUI_PTRSUB</a>, and <a class="el" href="classValueSet.html#a4a81331349a81dd4e1b9bb586f8de34d">ValueSet::typeCode</a>.</p>

<p class="reference">Referenced by <a class="el" href="classValueSetSolver.html#a842872867cb49258c51084165f4a0f20">generateRelativeConstraint()</a>.</p>

</div>
</div>
<a id="a97a09332b5c711af6adc8b9603b5b9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a09332b5c711af6adc8b9603b5b9bc">&#9670;&nbsp;</a></span>component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classValueSet.html">ValueSet</a> *&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPartition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a partition component given its head. </p>
<p>Knowing that the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is the head of a partition, generate the partition recursively and generate the formal <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together.">Partition</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>is the given <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem.">ValueSet</a> (attached to the head <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a>) </td></tr>
    <tr><td class="paramname">part</td><td>will hold the constructed <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together.">Partition</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classValueSet.html#aae21d8d6a782bbce080a7633a3b8272e">ValueSet::count</a>, <a class="el" href="classValueSetSolver_1_1ValueSetEdge.html#a9d332bbfd70ec494811c0d98d7dad5a4">ValueSetSolver::ValueSetEdge::getNext()</a>, <a class="el" href="classValueSetSolver.html#a6368c360ac7ce1322173feef9635bbc4">partitionPrepend()</a>, <a class="el" href="classValueSetSolver.html#af45d0eae011647af953863a4d9145f47">partitionSurround()</a>, <a class="el" href="classValueSetSolver.html#a3112c1fb71e8f9fa95d809a75c0d3916">rootNodes</a>, and <a class="el" href="classValueSetSolver.html#add4d625b2cec5d8712551e63737f42b8">visit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classValueSetSolver.html#add4d625b2cec5d8712551e63737f42b8">visit()</a>.</p>

</div>
</div>
<a id="a69e256b19fd0b267fe7d356c2bbff0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e256b19fd0b267fe7d356c2bbff0f4">&#9670;&nbsp;</a></span>constraintsFromCBranch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::constraintsFromCBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>cbranch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate constraints arising from the given branch. </p>
<p>Lift the set of values on the condition for the given CBRANCH to any <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> in the system, and label (the reads) of any such <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> with the constraint. If the values cannot be lifted or no <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> in the system is found, no constraints are generated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbranch</td><td>is the given condition branch </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classValueSetSolver.html#a874fc29428abfe7c8b503f8daae65558">constraintsFromPath()</a>, and <a class="el" href="classValueSetSolver.html#a842872867cb49258c51084165f4a0f20">generateRelativeConstraint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classValueSetSolver.html#a4371470235d727b0981667f86fefa545">generateConstraints()</a>.</p>

</div>
</div>
<a id="a874fc29428abfe7c8b503f8daae65558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874fc29428abfe7c8b503f8daae65558">&#9670;&nbsp;</a></span>constraintsFromPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::constraintsFromPath </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCircleRange.html">CircleRange</a> &amp;&#160;</td>
          <td class="paramname"><em>lift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>startVn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>endVn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>cbranch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate constraints given a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> path. </p>
<p>Knowing that there is a lifting path from the given starting <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> to an ending <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> in the system, go ahead and lift the given range to a final constraint on the ending <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a>. Then look for reads of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> where the constraint applies. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>is the constraint characteristic </td></tr>
    <tr><td class="paramname">lift</td><td>is the given range that will be lifted </td></tr>
    <tr><td class="paramname">startVn</td><td>is the starting <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </td></tr>
    <tr><td class="paramname">endVn</td><td>is the given ending <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> in the system </td></tr>
    <tr><td class="paramname">cbranch</td><td>is the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a> causing the control-flow split </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classValueSetSolver.html#a629f30eb1a0d4f35bc9bc3a855813be5">applyConstraints()</a>, and <a class="el" href="classCircleRange.html#a8b2b3063264a1169940c7131628b9a4b">CircleRange::pullBack()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classValueSetSolver.html#a69e256b19fd0b267fe7d356c2bbff0f4">constraintsFromCBranch()</a>, and <a class="el" href="classValueSetSolver.html#a842872867cb49258c51084165f4a0f20">generateRelativeConstraint()</a>.</p>

</div>
</div>
<a id="a81a3f29f53647357d726347855bc3df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a3f29f53647357d726347855bc3df7">&#9670;&nbsp;</a></span>establishTopologicalOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::establishTopologicalOrder </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the optimal order for iterating through the ValueSets. </p>
<p>Establish the recursive node ordering for iteratively solving the value set system.</p>
<p>This algorithm is based on "Efficient chaotic iteration strategies with widenings" by Francois Bourdoncle. The Varnodes in the system are ordered and a set of nested <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together.">Partition</a> components are generated. Iterating the ValueSets proceeds in this order, looping through the components recursively until a fixed point is reached. This implementation assumes all Varnodes in the system are distinguished by Varnode::isMark() returning <b>true</b>. </p>

<p class="reference">References <a class="el" href="classValueSetSolver.html#a0295aa881504af04699a83348725e14a">depthFirstIndex</a>, <a class="el" href="classValueSet.html#a0ee10854e8e6b08a2b7c565d1f035ced">ValueSet::next</a>, <a class="el" href="classValueSetSolver.html#ac4daef35e9b2e16edabb0aee04c26919">orderPartition</a>, <a class="el" href="classPartition.html#a63681ffecc917c6bf11dd78e891f7c67">Partition::startNode</a>, <a class="el" href="classValueSetSolver.html#a2b98c0f17a24b50706fb322ee6145c14">valueNodes</a>, <a class="el" href="classValueSetSolver.html#add4d625b2cec5d8712551e63737f42b8">visit()</a>, and <a class="el" href="classValueSet.html#a3dadcc9da8de045ec07dd214b8a70836">ValueSet::vn</a>.</p>

<p class="reference">Referenced by <a class="el" href="classValueSetSolver.html#a43a4cb32e3aef1c1cb92cd5b8d6dd300">establishValueSets()</a>.</p>

</div>
</div>
<a id="a43a4cb32e3aef1c1cb92cd5b8d6dd300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a4cb32e3aef1c1cb92cd5b8d6dd300">&#9670;&nbsp;</a></span>establishValueSets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::establishValueSets </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>sinks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>reads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>stackReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>indirectAsCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build value sets for a data-flow system. </p>
<p>Given a set of sinks, find all the Varnodes that flow directly into them and set up their initial <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem.">ValueSet</a> objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sinks</td><td>is the list terminating Varnodes </td></tr>
    <tr><td class="paramname">reads</td><td>are add-on PcodeOps where we would like to know input ValueSets at the point of read </td></tr>
    <tr><td class="paramname">stackReg</td><td>(if non-NULL) gives the stack pointer (for keeping track of relative offsets) </td></tr>
    <tr><td class="paramname">indirectAsCopy</td><td>is <b>true</b> if solver should treat CPUI_INDIRECT as CPUI_COPY operations </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a50235a7bf50bada36dff73ff740c34d0">CPUI_CALL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a500b63ecb17a75652c705bfab98bc8e5">CPUI_CALLIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a7a2b625788b1d23eda50975b6baf7efb">CPUI_CALLOTHER</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a5d4235f59c3d4320bae86e84f0cc9f62">CPUI_CPOOLREF</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a0a8c28845dbb4e140c5225a27b2bc999">CPUI_FLOAT_ABS</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7adda2cf75b28cc922eb7c98a73c7f52c0">CPUI_FLOAT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a4db96873fdb4d248df39cb0db9520c0a">CPUI_FLOAT_CEIL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a0a0736fe93f55b50513a969c9403ce0f">CPUI_FLOAT_DIV</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aab409a4f8049204cbe5be65787497842">CPUI_FLOAT_FLOAT2FLOAT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a4d3f1b7b6743fe7d9f448961aa623196">CPUI_FLOAT_FLOOR</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2fd5fa2cce0871ff743a532f778f33a1">CPUI_FLOAT_INT2FLOAT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a31b993d1b210255c90306c5253fdb7f6">CPUI_FLOAT_MULT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a51d26f25c64bd9a9cf3cd7caaaf92b2c">CPUI_FLOAT_NEG</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7acf38a393024ddf5b2d6e59c114a7fd60">CPUI_FLOAT_ROUND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a0ae2b4db2d21aa9fc438f7017bd174a4">CPUI_FLOAT_SQRT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ad99c56e45d45e1b405f9ba5d3fadcc44">CPUI_FLOAT_SUB</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a6a5722455afc241a3628add3b41efc73">CPUI_FLOAT_TRUNC</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ad76724dd2fcd9df1dca7e09e6427f10f">CPUI_LOAD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a980255c6f8e1cd7c7c7b035554292735">CPUI_NEW</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab67fab74923ce6c8be1c2254b9afb4f9">CPUI_SEGMENTOP</a>, <a class="el" href="classValueSetSolver.html#a81a3f29f53647357d726347855bc3df7">establishTopologicalOrder()</a>, <a class="el" href="classValueSetSolver.html#a4371470235d727b0981667f86fefa545">generateConstraints()</a>, <a class="el" href="classVarnode.html#a1899f1f493fed54c6dea1f445f146de6">Varnode::loneDescend()</a>, <a class="el" href="classValueSetSolver.html#aaa7e03150bb730888b0a41b470a845cb">newValueSet()</a>, <a class="el" href="classValueSetSolver.html#aebb788965618ec854d93fcdb7c284f87">readNodes</a>, and <a class="el" href="classValueSetSolver.html#a3112c1fb71e8f9fa95d809a75c0d3916">rootNodes</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHeritage.html#a7d518d053e1834e600be703ba0ac91b1">Heritage::analyzeNewLoadGuards()</a>.</p>

</div>
</div>
<a id="a4371470235d727b0981667f86fefa545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4371470235d727b0981667f86fefa545">&#9670;&nbsp;</a></span>generateConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::generateConstraints </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>worklist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>reads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate constraints given a system of Varnodes. </p>
<p>Given a complete data-flow system of Varnodes, look for any <em>constraint:</em> </p><ul>
<li>For a particular <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a></li>
<li>A limited set of values</li>
<li>Due to its involvement in a branch condition</li>
<li>Which applies at a particular <em>read</em> of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worklist</td><td>is the set of Varnodes in the data-flow system (all marked) </td></tr>
    <tr><td class="paramname">reads</td><td>is the additional set of PcodeOps that read a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> from the system </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classValueSetSolver.html#a69e256b19fd0b267fe7d356c2bbff0f4">constraintsFromCBranch()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a16130945560323d4b28ead4387094444">CPUI_CBRANCH</a>, and <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>.</p>

<p class="reference">Referenced by <a class="el" href="classValueSetSolver.html#a43a4cb32e3aef1c1cb92cd5b8d6dd300">establishValueSets()</a>.</p>

</div>
</div>
<a id="a6e500970c198d5d59cf05dbb9b359ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e500970c198d5d59cf05dbb9b359ee0">&#9670;&nbsp;</a></span>generateFalseEquation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::generateFalseEquation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCircleRange.html">CircleRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the complementary equation given a <b>true</b> constraint and the input/output Varnodes it affects. </p>
<p>The equation is expressed as: only <b>false</b> values can reach the indicated input to a specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a>. The equation is attached to the output of the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> the equation will be attached to </td></tr>
    <tr><td class="paramname">op</td><td>is the specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a> </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot of the constrained input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </td></tr>
    <tr><td class="paramname">type</td><td>is the type of values </td></tr>
    <tr><td class="paramname">range</td><td>is the range of <b>true</b> values, which must be complemented </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classCircleRange.html#a7e05a9a4816b825f76d823742b2775b4">CircleRange::invert()</a>, and <a class="el" href="classValueSetSolver.html#aebb788965618ec854d93fcdb7c284f87">readNodes</a>.</p>

<p class="reference">Referenced by <a class="el" href="classValueSetSolver.html#a629f30eb1a0d4f35bc9bc3a855813be5">applyConstraints()</a>.</p>

</div>
</div>
<a id="a842872867cb49258c51084165f4a0f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842872867cb49258c51084165f4a0f20">&#9670;&nbsp;</a></span>generateRelativeConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::generateRelativeConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>compOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>cbranch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to find a <em>relative</em> constraint. </p>
<p>Given a binary <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a> producing a conditional branch, check if it can be interpreted as a constraint relative to (the) base register specified for this system. If it can be, a <em>relative</em> Equation is generated, which will apply to <em>relative</em> ValueSets. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compOp</td><td>is the comparison <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a> </td></tr>
    <tr><td class="paramname">cbranch</td><td>is the conditional branch </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classValueSetSolver.html#a08af331cd9e5598111ac03a699c0df5e">checkRelativeConstant()</a>, <a class="el" href="classValueSetSolver.html#a874fc29428abfe7c8b503f8daae65558">constraintsFromPath()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7abfca59d2db4cdc6126afa1d60e4aba51">CPUI_INT_EQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a9fd7576d8174c8e8ad99a71b1bed2518">CPUI_INT_LESS</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2c6c583f14722fee36325c926280cbcc">CPUI_INT_LESSEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a82aa9ec8e7933e35b09e963cd87c2f30">CPUI_INT_NOTEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a0a05aafda58e54690ae841c3642e3b82">CPUI_INT_SLESS</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a49d2a9e93a7a397287ea70f8d6c6a132">CPUI_INT_SLESSEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7acd169003bfcb2e8dde0cb2dc1f534449">CPUI_PTRSUB</a>, and <a class="el" href="classCircleRange.html#a740302ad37ddc285b0527fb6b3c69703">CircleRange::pullBackBinary()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classValueSetSolver.html#a69e256b19fd0b267fe7d356c2bbff0f4">constraintsFromCBranch()</a>.</p>

</div>
</div>
<a id="a129d92ea3879a4ca9dc26d6b1c7d28ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129d92ea3879a4ca9dc26d6b1c7d28ea">&#9670;&nbsp;</a></span>generateTrueEquation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::generateTrueEquation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCircleRange.html">CircleRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate an equation given a <b>true</b> constraint and the input/output Varnodes it affects. </p>
<p>The equation is expressed as: only <b>true</b> values can reach the indicated input to a specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a>. The equation is attached to the output of the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> the equation will be attached to </td></tr>
    <tr><td class="paramname">op</td><td>is the specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language.">PcodeOp</a> </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot of the constrained input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </td></tr>
    <tr><td class="paramname">type</td><td>is the type of values </td></tr>
    <tr><td class="paramname">range</td><td>is the range of <b>true</b> values </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classValueSetSolver.html#aebb788965618ec854d93fcdb7c284f87">readNodes</a>.</p>

<p class="reference">Referenced by <a class="el" href="classValueSetSolver.html#a629f30eb1a0d4f35bc9bc3a855813be5">applyConstraints()</a>.</p>

</div>
</div>
<a id="aaa7e03150bb730888b0a41b470a845cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7e03150bb730888b0a41b470a845cb">&#9670;&nbsp;</a></span>newValueSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::newValueSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>tCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate storage for a new <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem.">ValueSet</a>. </p>
<p>The new <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem.">ValueSet</a> is attached to the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </td></tr>
    <tr><td class="paramname">tCode</td><td>is the type to associate with the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classValueSetSolver.html#a2b98c0f17a24b50706fb322ee6145c14">valueNodes</a>.</p>

<p class="reference">Referenced by <a class="el" href="classValueSetSolver.html#a43a4cb32e3aef1c1cb92cd5b8d6dd300">establishValueSets()</a>.</p>

</div>
</div>
<a id="aa73e4960de77e935167bf388f934e1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73e4960de77e935167bf388f934e1e8">&#9670;&nbsp;</a></span>partitionPrepend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::partitionPrepend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPartition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPartition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepend full <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together.">Partition</a> to given <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together.">Partition</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>is the partition to be prepended </td></tr>
    <tr><td class="paramname">part</td><td>is the given partition being modified (prepended to) </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classValueSet.html#a0ee10854e8e6b08a2b7c565d1f035ced">ValueSet::next</a>, <a class="el" href="classPartition.html#a63681ffecc917c6bf11dd78e891f7c67">Partition::startNode</a>, and <a class="el" href="classPartition.html#a69fb837215064c4654f59139c02f73d8">Partition::stopNode</a>.</p>

</div>
</div>
<a id="a6368c360ac7ce1322173feef9635bbc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6368c360ac7ce1322173feef9635bbc4">&#9670;&nbsp;</a></span>partitionPrepend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::partitionPrepend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classValueSet.html">ValueSet</a> *&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPartition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepend a vertex to a partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>is the node that will be prepended </td></tr>
    <tr><td class="paramname">part</td><td>is the <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together.">Partition</a> being modified </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classValueSet.html#a0ee10854e8e6b08a2b7c565d1f035ced">ValueSet::next</a>, <a class="el" href="classPartition.html#a63681ffecc917c6bf11dd78e891f7c67">Partition::startNode</a>, and <a class="el" href="classPartition.html#a69fb837215064c4654f59139c02f73d8">Partition::stopNode</a>.</p>

<p class="reference">Referenced by <a class="el" href="classValueSetSolver.html#a97a09332b5c711af6adc8b9603b5b9bc">component()</a>, and <a class="el" href="classValueSetSolver.html#add4d625b2cec5d8712551e63737f42b8">visit()</a>.</p>

</div>
</div>
<a id="af45d0eae011647af953863a4d9145f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45d0eae011647af953863a4d9145f47">&#9670;&nbsp;</a></span>partitionSurround()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::partitionSurround </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a full partition component. </p>
<p>This method saves a <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together.">Partition</a> to permanent storage. It marks the starting node of the partition and sets up for the iterating algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>is the partition to store </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classValueSet.html#a20a15827de3f50e15eb8a70198bae5c8">ValueSet::partHead</a>, <a class="el" href="classValueSetSolver.html#a50feee21009569676cbc28dfb31904f6">recordStorage</a>, and <a class="el" href="classPartition.html#a63681ffecc917c6bf11dd78e891f7c67">Partition::startNode</a>.</p>

<p class="reference">Referenced by <a class="el" href="classValueSetSolver.html#a97a09332b5c711af6adc8b9603b5b9bc">component()</a>.</p>

</div>
</div>
<a id="a8dec4550f9502575b92ca93bf997185c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dec4550f9502575b92ca93bf997185c">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::solve </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWidener.html">Widener</a> &amp;&#160;</td>
          <td class="paramname"><em>widener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate the <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem.">ValueSet</a> system until it stabilizes. </p>
<p>The ValueSets are recalculated in the established topological ordering, with looping at various levels until a fixed point is reached. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>is the maximum number of iterations to allow before forcing termination </td></tr>
    <tr><td class="paramname">widener</td><td>is the Widening strategy to use to accelerate stabilization </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classValueSet.html#aae21d8d6a782bbce080a7633a3b8272e">ValueSet::count</a>, <a class="el" href="classWidener.html#ad2dae5401b12d1ae6839b7475d5d8cb4">Widener::determineIterationReset()</a>, <a class="el" href="classPartition.html#a8f1b58895209c9705d03290fc5f23478">Partition::isDirty</a>, <a class="el" href="classValueSet.html#a72f774ca4732701ced824502ab462ead">ValueSet::iterate()</a>, <a class="el" href="classValueSetSolver.html#a3be76d1ba9fdfe55bcb003e490bfc3e2">maxIterations</a>, <a class="el" href="classValueSet.html#a0ee10854e8e6b08a2b7c565d1f035ced">ValueSet::next</a>, <a class="el" href="classValueSetSolver.html#adfb7c05d75bf03cd7c7d50a05adce80f">numIterations</a>, <a class="el" href="classValueSetSolver.html#ac4daef35e9b2e16edabb0aee04c26919">orderPartition</a>, <a class="el" href="classValueSet.html#a20a15827de3f50e15eb8a70198bae5c8">ValueSet::partHead</a>, <a class="el" href="classValueSetSolver.html#aebb788965618ec854d93fcdb7c284f87">readNodes</a>, <a class="el" href="classPartition.html#a63681ffecc917c6bf11dd78e891f7c67">Partition::startNode</a>, <a class="el" href="classPartition.html#a69fb837215064c4654f59139c02f73d8">Partition::stopNode</a>, and <a class="el" href="classValueSetSolver.html#a2b98c0f17a24b50706fb322ee6145c14">valueNodes</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHeritage.html#a7d518d053e1834e600be703ba0ac91b1">Heritage::analyzeNewLoadGuards()</a>.</p>

</div>
</div>
<a id="add4d625b2cec5d8712551e63737f42b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4d625b2cec5d8712551e63737f42b8">&#9670;&nbsp;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 ValueSetSolver::visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classValueSet.html">ValueSet</a> *&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPartition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively walk the data-flow graph finding partitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>is the current <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> being walked </td></tr>
    <tr><td class="paramname">part</td><td>is the current <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together.">Partition</a> being constructed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of calculated head <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem.">ValueSet</a> for the current Parition </dd></dl>

<p class="reference">References <a class="el" href="classValueSetSolver.html#a97a09332b5c711af6adc8b9603b5b9bc">component()</a>, <a class="el" href="classValueSet.html#aae21d8d6a782bbce080a7633a3b8272e">ValueSet::count</a>, <a class="el" href="classValueSetSolver.html#a0295aa881504af04699a83348725e14a">depthFirstIndex</a>, <a class="el" href="classValueSetSolver_1_1ValueSetEdge.html#a9d332bbfd70ec494811c0d98d7dad5a4">ValueSetSolver::ValueSetEdge::getNext()</a>, <a class="el" href="classValueSetSolver.html#a4418321d42d23d4ee75f25230e974690">nodeStack</a>, <a class="el" href="classValueSetSolver.html#a6368c360ac7ce1322173feef9635bbc4">partitionPrepend()</a>, and <a class="el" href="classValueSetSolver.html#a3112c1fb71e8f9fa95d809a75c0d3916">rootNodes</a>.</p>

<p class="reference">Referenced by <a class="el" href="classValueSetSolver.html#a97a09332b5c711af6adc8b9603b5b9bc">component()</a>, and <a class="el" href="classValueSetSolver.html#a81a3f29f53647357d726347855bc3df7">establishTopologicalOrder()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="rangeutil_8hh.html">rangeutil.hh</a></li>
<li>rangeutil.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
