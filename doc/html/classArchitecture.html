<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>decompiler: Architecture Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classArchitecture-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Architecture Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Manager for all the major decompiler subsystems.  
 <a href="classArchitecture.html#details">More...</a></p>

<p><code>#include &lt;architecture.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Architecture:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classArchitecture.png" usemap="#Architecture_map" alt=""/>
  <map id="Architecture_map" name="Architecture_map">
<area href="classAddrSpaceManager.html" title="A manager for different address spaces." alt="AddrSpaceManager" shape="rect" coords="76,0,219,24"/>
<area href="classArchitectureGhidra.html" title="An implementation of the Architecture interface and connection to a Ghidra client." alt="ArchitectureGhidra" shape="rect" coords="0,112,143,136"/>
<area href="classSleighArchitecture.html" title="An Architecture that uses the decompiler&#39;s native SLEIGH translation engine." alt="SleighArchitecture" shape="rect" coords="153,112,296,136"/>
<area href="classBfdArchitecture.html" title="Architecture that reads executable files using GNU BFD libraries." alt="BfdArchitecture" shape="rect" coords="0,168,143,192"/>
<area href="classRawBinaryArchitecture.html" title="Architecture that reads its binary as a raw file." alt="RawBinaryArchitecture" shape="rect" coords="153,168,296,192"/>
<area href="classXmlArchitecture.html" title="An Architecture that loads executables using an XML format." alt="XmlArchitecture" shape="rect" coords="306,168,449,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea7049f03a24618ef02d876b0659f67d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#aea7049f03a24618ef02d876b0659f67d">Architecture</a> (void)</td></tr>
<tr class="memdesc:aea7049f03a24618ef02d876b0659f67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an uninitialized <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a>.  <a href="classArchitecture.html#aea7049f03a24618ef02d876b0659f67d">More...</a><br /></td></tr>
<tr class="separator:aea7049f03a24618ef02d876b0659f67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf0d020ebe4248b9b35f3a51b78363b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#abcf0d020ebe4248b9b35f3a51b78363b">init</a> (<a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;store)</td></tr>
<tr class="memdesc:abcf0d020ebe4248b9b35f3a51b78363b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the image and configure architecture.  <a href="classArchitecture.html#abcf0d020ebe4248b9b35f3a51b78363b">More...</a><br /></td></tr>
<tr class="separator:abcf0d020ebe4248b9b35f3a51b78363b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03485a52fdf3b18f004ff4687d159a1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classProtoModel.html">ProtoModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a03485a52fdf3b18f004ff4687d159a1e">getModel</a> (const string &amp;nm) const</td></tr>
<tr class="memdesc:a03485a52fdf3b18f004ff4687d159a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific PrototypeModel.  <a href="classArchitecture.html#a03485a52fdf3b18f004ff4687d159a1e">More...</a><br /></td></tr>
<tr class="separator:a03485a52fdf3b18f004ff4687d159a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0075f8ca742086c8be493703b3f2f3cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a0075f8ca742086c8be493703b3f2f3cd">hasModel</a> (const string &amp;nm) const</td></tr>
<tr class="memdesc:a0075f8ca742086c8be493703b3f2f3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a> have a specific PrototypeModel.  <a href="classArchitecture.html#a0075f8ca742086c8be493703b3f2f3cd">More...</a><br /></td></tr>
<tr class="separator:a0075f8ca742086c8be493703b3f2f3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec2e6c18d4b1280dc955ec0ace7d476"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a9ec2e6c18d4b1280dc955ec0ace7d476">highPtrPossible</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size) const</td></tr>
<tr class="memdesc:a9ec2e6c18d4b1280dc955ec0ace7d476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are pointers possible to the given location?  <a href="classArchitecture.html#a9ec2e6c18d4b1280dc955ec0ace7d476">More...</a><br /></td></tr>
<tr class="separator:a9ec2e6c18d4b1280dc955ec0ace7d476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cef69bf3d546ca1012fcf5c017f7f3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a6cef69bf3d546ca1012fcf5c017f7f3a">getSpaceBySpacebase</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size) const</td></tr>
<tr class="memdesc:a6cef69bf3d546ca1012fcf5c017f7f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get space associated with a <em>spacebase</em> register.  <a href="classArchitecture.html#a6cef69bf3d546ca1012fcf5c017f7f3a">More...</a><br /></td></tr>
<tr class="separator:a6cef69bf3d546ca1012fcf5c017f7f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ac33eeac5ec397674d1ebd5ac8a199"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classLanedRegister.html">LanedRegister</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#ae8ac33eeac5ec397674d1ebd5ac8a199">getLanedRegister</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size) const</td></tr>
<tr class="memdesc:ae8ac33eeac5ec397674d1ebd5ac8a199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classLanedRegister.html" title="Describes a (register) storage location and the ways it might be split into lanes.">LanedRegister</a> associated with storage.  <a href="classArchitecture.html#ae8ac33eeac5ec397674d1ebd5ac8a199">More...</a><br /></td></tr>
<tr class="separator:ae8ac33eeac5ec397674d1ebd5ac8a199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fada44a26502772bf9060d08289fd3"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a86fada44a26502772bf9060d08289fd3">getMinimumLanedRegisterSize</a> (void) const</td></tr>
<tr class="memdesc:a86fada44a26502772bf9060d08289fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum size of a laned register in bytes.  <a href="classArchitecture.html#a86fada44a26502772bf9060d08289fd3">More...</a><br /></td></tr>
<tr class="separator:a86fada44a26502772bf9060d08289fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc351278b2e416181b2a7c5b65cc614b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#afc351278b2e416181b2a7c5b65cc614b">setDefaultModel</a> (const string &amp;nm)</td></tr>
<tr class="memdesc:afc351278b2e416181b2a7c5b65cc614b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default PrototypeModel.  <a href="classArchitecture.html#afc351278b2e416181b2a7c5b65cc614b">More...</a><br /></td></tr>
<tr class="separator:afc351278b2e416181b2a7c5b65cc614b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb912926505aad414d6054071a9e8d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a5cb912926505aad414d6054071a9e8d8">clearAnalysis</a> (<a class="el" href="classFuncdata.html">Funcdata</a> *fd)</td></tr>
<tr class="memdesc:a5cb912926505aad414d6054071a9e8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear analysis specific to a function.  <a href="classArchitecture.html#a5cb912926505aad414d6054071a9e8d8">More...</a><br /></td></tr>
<tr class="separator:a5cb912926505aad414d6054071a9e8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c95a933f8a42d6d1d46d8663a793a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#ac6c95a933f8a42d6d1d46d8663a793a2">readLoaderSymbols</a> (void)</td></tr>
<tr class="memdesc:ac6c95a933f8a42d6d1d46d8663a793a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read any symbols from loader into database.  <a href="classArchitecture.html#ac6c95a933f8a42d6d1d46d8663a793a2">More...</a><br /></td></tr>
<tr class="separator:ac6c95a933f8a42d6d1d46d8663a793a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5499f02b08260cd95354143546fd374b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a5499f02b08260cd95354143546fd374b">collectBehaviors</a> (vector&lt; <a class="el" href="classOpBehavior.html">OpBehavior</a> * &gt; &amp;behave) const</td></tr>
<tr class="memdesc:a5499f02b08260cd95354143546fd374b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a list of <a class="el" href="classOpBehavior.html" title="Class encapsulating the action/behavior of specific pcode opcodes.">OpBehavior</a> objects.  <a href="classArchitecture.html#a5499f02b08260cd95354143546fd374b">More...</a><br /></td></tr>
<tr class="separator:a5499f02b08260cd95354143546fd374b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8588f5fecba2f618ce640ef57b31f10a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSegmentOp.html">SegmentOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a8588f5fecba2f618ce640ef57b31f10a">getSegmentOp</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc) const</td></tr>
<tr class="memdesc:a8588f5fecba2f618ce640ef57b31f10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <em>segment</em> op for the given space if any.  <a href="classArchitecture.html#a8588f5fecba2f618ce640ef57b31f10a">More...</a><br /></td></tr>
<tr class="separator:a8588f5fecba2f618ce640ef57b31f10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d78ec7be0df339288b7b3adc4c38e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a10d78ec7be0df339288b7b3adc4c38e7">setPrototype</a> (const <a class="el" href="structPrototypePieces.html">PrototypePieces</a> &amp;pieces)</td></tr>
<tr class="memdesc:a10d78ec7be0df339288b7b3adc4c38e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the prototype for a particular function.  <a href="classArchitecture.html#a10d78ec7be0df339288b7b3adc4c38e7">More...</a><br /></td></tr>
<tr class="separator:a10d78ec7be0df339288b7b3adc4c38e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae002322a1fd364665099cbe3f98b63a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#ae002322a1fd364665099cbe3f98b63a6">setPrintLanguage</a> (const string &amp;nm)</td></tr>
<tr class="memdesc:ae002322a1fd364665099cbe3f98b63a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a particular output language.  <a href="classArchitecture.html#ae002322a1fd364665099cbe3f98b63a6">More...</a><br /></td></tr>
<tr class="separator:ae002322a1fd364665099cbe3f98b63a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726878f225eebebb51d4e618f4d53631"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a726878f225eebebb51d4e618f4d53631">globalify</a> (void)</td></tr>
<tr class="memdesc:a726878f225eebebb51d4e618f4d53631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <em>all</em> spaces as global.  <a href="classArchitecture.html#a726878f225eebebb51d4e618f4d53631">More...</a><br /></td></tr>
<tr class="separator:a726878f225eebebb51d4e618f4d53631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4181297a704049ca50c3fc3d233bc0e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a4181297a704049ca50c3fc3d233bc0e4">restoreFlowOverride</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a4181297a704049ca50c3fc3d233bc0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flow overrides from XML.  <a href="classArchitecture.html#a4181297a704049ca50c3fc3d233bc0e4">More...</a><br /></td></tr>
<tr class="separator:a4181297a704049ca50c3fc3d233bc0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef3c8d834e7f5c22db0cf15eefc7e45"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#aaef3c8d834e7f5c22db0cf15eefc7e45">~Architecture</a> (void)</td></tr>
<tr class="memdesc:aaef3c8d834e7f5c22db0cf15eefc7e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classArchitecture.html#aaef3c8d834e7f5c22db0cf15eefc7e45">More...</a><br /></td></tr>
<tr class="separator:aaef3c8d834e7f5c22db0cf15eefc7e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69348906c7601efa002f1f1365decda9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a69348906c7601efa002f1f1365decda9">printMessage</a> (const string &amp;message) const =0</td></tr>
<tr class="memdesc:a69348906c7601efa002f1f1365decda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an error message to console.  <a href="classArchitecture.html#a69348906c7601efa002f1f1365decda9">More...</a><br /></td></tr>
<tr class="separator:a69348906c7601efa002f1f1365decda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af760a127622d4cdd4b6b436122478cb5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#af760a127622d4cdd4b6b436122478cb5">saveXml</a> (ostream &amp;s) const</td></tr>
<tr class="memdesc:af760a127622d4cdd4b6b436122478cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize this architecture to XML.  <a href="classArchitecture.html#af760a127622d4cdd4b6b436122478cb5">More...</a><br /></td></tr>
<tr class="separator:af760a127622d4cdd4b6b436122478cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15a398b9f84dd62ad36d1e83895783a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#ab15a398b9f84dd62ad36d1e83895783a">restoreXml</a> (<a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;store)</td></tr>
<tr class="memdesc:ab15a398b9f84dd62ad36d1e83895783a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a> state from an XML stream.  <a href="classArchitecture.html#ab15a398b9f84dd62ad36d1e83895783a">More...</a><br /></td></tr>
<tr class="separator:ab15a398b9f84dd62ad36d1e83895783a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd655cd2adbd6538883e1771276604e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a7bd655cd2adbd6538883e1771276604e">nameFunction</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, string &amp;name) const</td></tr>
<tr class="memdesc:a7bd655cd2adbd6538883e1771276604e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pick a default name for a function.  <a href="classArchitecture.html#a7bd655cd2adbd6538883e1771276604e">More...</a><br /></td></tr>
<tr class="separator:a7bd655cd2adbd6538883e1771276604e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classAddrSpaceManager"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classAddrSpaceManager')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a></td></tr>
<tr class="memitem:a7012cd8aa3869a8db478ef71dfd04756 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a7012cd8aa3869a8db478ef71dfd04756">AddrSpaceManager</a> (void)</td></tr>
<tr class="memdesc:a7012cd8aa3869a8db478ef71dfd04756 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty address space manager.  <a href="classAddrSpaceManager.html#a7012cd8aa3869a8db478ef71dfd04756">More...</a><br /></td></tr>
<tr class="separator:a7012cd8aa3869a8db478ef71dfd04756 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca145540a3af8f6d35dfc2037580818 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#afca145540a3af8f6d35dfc2037580818">~AddrSpaceManager</a> (void)</td></tr>
<tr class="memdesc:afca145540a3af8f6d35dfc2037580818 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the manager.  <a href="classAddrSpaceManager.html#afca145540a3af8f6d35dfc2037580818">More...</a><br /></td></tr>
<tr class="separator:afca145540a3af8f6d35dfc2037580818 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b808345dc85dc7e4f8e993fd739f96 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#ab1b808345dc85dc7e4f8e993fd739f96">getDefaultSize</a> (void) const</td></tr>
<tr class="memdesc:ab1b808345dc85dc7e4f8e993fd739f96 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of addresses for the default space.  <a href="classAddrSpaceManager.html#ab1b808345dc85dc7e4f8e993fd739f96">More...</a><br /></td></tr>
<tr class="separator:ab1b808345dc85dc7e4f8e993fd739f96 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24efffb904ebb1a0a541fa74cafd51fc inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a24efffb904ebb1a0a541fa74cafd51fc">getSpaceByName</a> (const string &amp;nm) const</td></tr>
<tr class="memdesc:a24efffb904ebb1a0a541fa74cafd51fc inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address space by name.  <a href="classAddrSpaceManager.html#a24efffb904ebb1a0a541fa74cafd51fc">More...</a><br /></td></tr>
<tr class="separator:a24efffb904ebb1a0a541fa74cafd51fc inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69937486b7d2b062011ac39d5513ee3 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#aa69937486b7d2b062011ac39d5513ee3">getSpaceByShortcut</a> (char sc) const</td></tr>
<tr class="memdesc:aa69937486b7d2b062011ac39d5513ee3 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address space from its shortcut.  <a href="classAddrSpaceManager.html#aa69937486b7d2b062011ac39d5513ee3">More...</a><br /></td></tr>
<tr class="separator:aa69937486b7d2b062011ac39d5513ee3 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2175a095b07fef420632724cacc10354 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a2175a095b07fef420632724cacc10354">getIopSpace</a> (void) const</td></tr>
<tr class="memdesc:a2175a095b07fef420632724cacc10354 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal pcode op space.  <a href="classAddrSpaceManager.html#a2175a095b07fef420632724cacc10354">More...</a><br /></td></tr>
<tr class="separator:a2175a095b07fef420632724cacc10354 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734131c0626a1cfbbfd3cb0e93ecba28 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a734131c0626a1cfbbfd3cb0e93ecba28">getFspecSpace</a> (void) const</td></tr>
<tr class="memdesc:a734131c0626a1cfbbfd3cb0e93ecba28 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal callspec space.  <a href="classAddrSpaceManager.html#a734131c0626a1cfbbfd3cb0e93ecba28">More...</a><br /></td></tr>
<tr class="separator:a734131c0626a1cfbbfd3cb0e93ecba28 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc2a210ade7c84962711a962e27dc32 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#addc2a210ade7c84962711a962e27dc32">getJoinSpace</a> (void) const</td></tr>
<tr class="memdesc:addc2a210ade7c84962711a962e27dc32 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the joining space.  <a href="classAddrSpaceManager.html#addc2a210ade7c84962711a962e27dc32">More...</a><br /></td></tr>
<tr class="separator:addc2a210ade7c84962711a962e27dc32 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f3afd0adb68f208c31a9716abe5a4f inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a00f3afd0adb68f208c31a9716abe5a4f">getStackSpace</a> (void) const</td></tr>
<tr class="memdesc:a00f3afd0adb68f208c31a9716abe5a4f inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stack space for this processor.  <a href="classAddrSpaceManager.html#a00f3afd0adb68f208c31a9716abe5a4f">More...</a><br /></td></tr>
<tr class="separator:a00f3afd0adb68f208c31a9716abe5a4f inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7428d74e76200ecc3c99a0e1ad7f613 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#ab7428d74e76200ecc3c99a0e1ad7f613">getUniqueSpace</a> (void) const</td></tr>
<tr class="memdesc:ab7428d74e76200ecc3c99a0e1ad7f613 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the temporary register space for this processor.  <a href="classAddrSpaceManager.html#ab7428d74e76200ecc3c99a0e1ad7f613">More...</a><br /></td></tr>
<tr class="separator:ab7428d74e76200ecc3c99a0e1ad7f613 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7113aad36405ce0cd8dab5eadfbb1b1 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#ad7113aad36405ce0cd8dab5eadfbb1b1">getDefaultCodeSpace</a> (void) const</td></tr>
<tr class="memdesc:ad7113aad36405ce0cd8dab5eadfbb1b1 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default address space of this processor.  <a href="classAddrSpaceManager.html#ad7113aad36405ce0cd8dab5eadfbb1b1">More...</a><br /></td></tr>
<tr class="separator:ad7113aad36405ce0cd8dab5eadfbb1b1 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2aeddbc1955a52c5cfd8c969fc1d9d1 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#ab2aeddbc1955a52c5cfd8c969fc1d9d1">getDefaultDataSpace</a> (void) const</td></tr>
<tr class="memdesc:ab2aeddbc1955a52c5cfd8c969fc1d9d1 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default address space where data is stored.  <a href="classAddrSpaceManager.html#ab2aeddbc1955a52c5cfd8c969fc1d9d1">More...</a><br /></td></tr>
<tr class="separator:ab2aeddbc1955a52c5cfd8c969fc1d9d1 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dec6a4f5671fffb5d5645ebd2cb1f4 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#ab7dec6a4f5671fffb5d5645ebd2cb1f4">getConstantSpace</a> (void) const</td></tr>
<tr class="memdesc:ab7dec6a4f5671fffb5d5645ebd2cb1f4 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the constant space.  <a href="classAddrSpaceManager.html#ab7dec6a4f5671fffb5d5645ebd2cb1f4">More...</a><br /></td></tr>
<tr class="separator:ab7dec6a4f5671fffb5d5645ebd2cb1f4 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd44852a41fe18966cce35b5abd15de inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#aadd44852a41fe18966cce35b5abd15de">getConstant</a> (uintb val) const</td></tr>
<tr class="memdesc:aadd44852a41fe18966cce35b5abd15de inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a constant encoded as an <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data.">Address</a>.  <a href="classAddrSpaceManager.html#aadd44852a41fe18966cce35b5abd15de">More...</a><br /></td></tr>
<tr class="separator:aadd44852a41fe18966cce35b5abd15de inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc6c782b2b4c4c300aaa491e40719b8 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a5dc6c782b2b4c4c300aaa491e40719b8">createConstFromSpace</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc) const</td></tr>
<tr class="memdesc:a5dc6c782b2b4c4c300aaa491e40719b8 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a constant address encoding an address space.  <a href="classAddrSpaceManager.html#a5dc6c782b2b4c4c300aaa491e40719b8">More...</a><br /></td></tr>
<tr class="separator:a5dc6c782b2b4c4c300aaa491e40719b8 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc16df2604d30c067d1b604889891a0 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#aefc16df2604d30c067d1b604889891a0">resolveConstant</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, uintb val, int4 sz, const <a class="el" href="classAddress.html">Address</a> &amp;point, uintb &amp;fullEncoding) const</td></tr>
<tr class="memdesc:aefc16df2604d30c067d1b604889891a0 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve a native constant into an <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data.">Address</a>.  <a href="classAddrSpaceManager.html#aefc16df2604d30c067d1b604889891a0">More...</a><br /></td></tr>
<tr class="separator:aefc16df2604d30c067d1b604889891a0 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d22102a7ce6080918e82daafabbdfa inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#ae2d22102a7ce6080918e82daafabbdfa">numSpaces</a> (void) const</td></tr>
<tr class="memdesc:ae2d22102a7ce6080918e82daafabbdfa inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of address spaces for this processor.  <a href="classAddrSpaceManager.html#ae2d22102a7ce6080918e82daafabbdfa">More...</a><br /></td></tr>
<tr class="separator:ae2d22102a7ce6080918e82daafabbdfa inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a9a620e767ffe8bd929913f882e2a4 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#ad1a9a620e767ffe8bd929913f882e2a4">getSpace</a> (int4 i) const</td></tr>
<tr class="memdesc:ad1a9a620e767ffe8bd929913f882e2a4 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an address space via its index.  <a href="classAddrSpaceManager.html#ad1a9a620e767ffe8bd929913f882e2a4">More...</a><br /></td></tr>
<tr class="separator:ad1a9a620e767ffe8bd929913f882e2a4 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe31b83fccddf3c6d9d35e981f203b19 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#abe31b83fccddf3c6d9d35e981f203b19">getNextSpaceInOrder</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc) const</td></tr>
<tr class="memdesc:abe31b83fccddf3c6d9d35e981f203b19 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next <em>contiguous</em> address space.  <a href="classAddrSpaceManager.html#abe31b83fccddf3c6d9d35e981f203b19">More...</a><br /></td></tr>
<tr class="separator:abe31b83fccddf3c6d9d35e981f203b19 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9e7e934e22b6bea3b2b949fd2b2159 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJoinRecord.html">JoinRecord</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a1b9e7e934e22b6bea3b2b949fd2b2159">findAddJoin</a> (const vector&lt; <a class="el" href="structVarnodeData.html">VarnodeData</a> &gt; &amp;pieces, uint4 logicalsize)</td></tr>
<tr class="memdesc:a1b9e7e934e22b6bea3b2b949fd2b2159 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get (or create) <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split.">JoinRecord</a> for <em>pieces</em>.  <a href="classAddrSpaceManager.html#a1b9e7e934e22b6bea3b2b949fd2b2159">More...</a><br /></td></tr>
<tr class="separator:a1b9e7e934e22b6bea3b2b949fd2b2159 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff0f9e662ebffdf724dca82b6b544bb inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJoinRecord.html">JoinRecord</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#adff0f9e662ebffdf724dca82b6b544bb">findJoin</a> (uintb offset) const</td></tr>
<tr class="memdesc:adff0f9e662ebffdf724dca82b6b544bb inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split.">JoinRecord</a> for <em>offset</em> in the join space.  <a href="classAddrSpaceManager.html#adff0f9e662ebffdf724dca82b6b544bb">More...</a><br /></td></tr>
<tr class="separator:adff0f9e662ebffdf724dca82b6b544bb inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82d08eab20f86a31fe366a9bcd58629 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#ae82d08eab20f86a31fe366a9bcd58629">setDeadcodeDelay</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, int4 delaydelta)</td></tr>
<tr class="memdesc:ae82d08eab20f86a31fe366a9bcd58629 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the deadcodedelay for a specific space.  <a href="classAddrSpaceManager.html#ae82d08eab20f86a31fe366a9bcd58629">More...</a><br /></td></tr>
<tr class="separator:ae82d08eab20f86a31fe366a9bcd58629 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7d980ea2fc0c6450e941fd7dbec7e6 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#aef7d980ea2fc0c6450e941fd7dbec7e6">truncateSpace</a> (const <a class="el" href="classTruncationTag.html">TruncationTag</a> &amp;tag)</td></tr>
<tr class="memdesc:aef7d980ea2fc0c6450e941fd7dbec7e6 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a space as truncated from its original size.  <a href="classAddrSpaceManager.html#aef7d980ea2fc0c6450e941fd7dbec7e6">More...</a><br /></td></tr>
<tr class="separator:aef7d980ea2fc0c6450e941fd7dbec7e6 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed824a71a1d12bb5d167a7a488eb7198 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#aed824a71a1d12bb5d167a7a488eb7198">constructFloatExtensionAddress</a> (const <a class="el" href="classAddress.html">Address</a> &amp;realaddr, int4 realsize, int4 logicalsize)</td></tr>
<tr class="memdesc:aed824a71a1d12bb5d167a7a488eb7198 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a logically lower precision storage location for a bigger floating point register.  <a href="classAddrSpaceManager.html#aed824a71a1d12bb5d167a7a488eb7198">More...</a><br /></td></tr>
<tr class="separator:aed824a71a1d12bb5d167a7a488eb7198 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfc5383270584be6e9b974114e65f13 inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a1cfc5383270584be6e9b974114e65f13">constructJoinAddress</a> (const <a class="el" href="classTranslate.html">Translate</a> *translate, const <a class="el" href="classAddress.html">Address</a> &amp;hiaddr, int4 hisz, const <a class="el" href="classAddress.html">Address</a> &amp;loaddr, int4 losz)</td></tr>
<tr class="memdesc:a1cfc5383270584be6e9b974114e65f13 inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a logical whole from register pairs.  <a href="classAddrSpaceManager.html#a1cfc5383270584be6e9b974114e65f13">More...</a><br /></td></tr>
<tr class="separator:a1cfc5383270584be6e9b974114e65f13 inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cf42a54806161d8bf3c1fa283036dd inherit pub_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a68cf42a54806161d8bf3c1fa283036dd">renormalizeJoinAddress</a> (<a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size)</td></tr>
<tr class="memdesc:a68cf42a54806161d8bf3c1fa283036dd inherit pub_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure a possibly offset <em>join</em> address has a proper <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split.">JoinRecord</a>.  <a href="classAddrSpaceManager.html#a68cf42a54806161d8bf3c1fa283036dd">More...</a><br /></td></tr>
<tr class="separator:a68cf42a54806161d8bf3c1fa283036dd inherit pub_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a78260a0e141deda850d56d17e6e728cf"><td class="memItemLeft" align="right" valign="top"><a id="a78260a0e141deda850d56d17e6e728cf"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a78260a0e141deda850d56d17e6e728cf">archid</a></td></tr>
<tr class="memdesc:a78260a0e141deda850d56d17e6e728cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID string uniquely describing this architecture. <br /></td></tr>
<tr class="separator:a78260a0e141deda850d56d17e6e728cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb294ba6c3bb21f691e0208c1ac53a1"><td class="memItemLeft" align="right" valign="top"><a id="adbb294ba6c3bb21f691e0208c1ac53a1"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#adbb294ba6c3bb21f691e0208c1ac53a1">trim_recurse_max</a></td></tr>
<tr class="memdesc:adbb294ba6c3bb21f691e0208c1ac53a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many levels to let parameter trims recurse. <br /></td></tr>
<tr class="separator:adbb294ba6c3bb21f691e0208c1ac53a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c32c1c7e592435d70f41145d5c548f1"><td class="memItemLeft" align="right" valign="top"><a id="a6c32c1c7e592435d70f41145d5c548f1"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a6c32c1c7e592435d70f41145d5c548f1">max_implied_ref</a></td></tr>
<tr class="memdesc:a6c32c1c7e592435d70f41145d5c548f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of references to an implied var. <br /></td></tr>
<tr class="separator:a6c32c1c7e592435d70f41145d5c548f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99db0ca5ac8e5c9edfa7515f97b2ab5a"><td class="memItemLeft" align="right" valign="top"><a id="a99db0ca5ac8e5c9edfa7515f97b2ab5a"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a99db0ca5ac8e5c9edfa7515f97b2ab5a">max_term_duplication</a></td></tr>
<tr class="memdesc:a99db0ca5ac8e5c9edfa7515f97b2ab5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max terms duplicated without a new variable. <br /></td></tr>
<tr class="separator:a99db0ca5ac8e5c9edfa7515f97b2ab5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37de4bf5cb39955f32a24074e768a591"><td class="memItemLeft" align="right" valign="top"><a id="a37de4bf5cb39955f32a24074e768a591"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a37de4bf5cb39955f32a24074e768a591">max_basetype_size</a></td></tr>
<tr class="memdesc:a37de4bf5cb39955f32a24074e768a591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of an "integer" type before creating an array type. <br /></td></tr>
<tr class="separator:a37de4bf5cb39955f32a24074e768a591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c79b6eca1b3c98884bb53c90bf417d"><td class="memItemLeft" align="right" valign="top"><a id="aa5c79b6eca1b3c98884bb53c90bf417d"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#aa5c79b6eca1b3c98884bb53c90bf417d">min_funcsymbol_size</a></td></tr>
<tr class="memdesc:aa5c79b6eca1b3c98884bb53c90bf417d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum size of a function symbol. <br /></td></tr>
<tr class="separator:aa5c79b6eca1b3c98884bb53c90bf417d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c3648c6133efc1d5115b86dd10115a"><td class="memItemLeft" align="right" valign="top"><a id="a51c3648c6133efc1d5115b86dd10115a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a51c3648c6133efc1d5115b86dd10115a">aggressive_ext_trim</a></td></tr>
<tr class="memdesc:a51c3648c6133efc1d5115b86dd10115a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggressively trim inputs that look like they are sign extended. <br /></td></tr>
<tr class="separator:a51c3648c6133efc1d5115b86dd10115a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c49555bfdee44b82f3a9a98005ed0d"><td class="memItemLeft" align="right" valign="top"><a id="a64c49555bfdee44b82f3a9a98005ed0d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a64c49555bfdee44b82f3a9a98005ed0d">readonlypropagate</a></td></tr>
<tr class="memdesc:a64c49555bfdee44b82f3a9a98005ed0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if readonly values should be treated as constants <br /></td></tr>
<tr class="separator:a64c49555bfdee44b82f3a9a98005ed0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbeb3c604a337ce88bd4e9d8beb78806"><td class="memItemLeft" align="right" valign="top"><a id="adbeb3c604a337ce88bd4e9d8beb78806"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#adbeb3c604a337ce88bd4e9d8beb78806">infer_pointers</a></td></tr>
<tr class="memdesc:adbeb3c604a337ce88bd4e9d8beb78806"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if we should infer pointers from constants that are likely addresses. <br /></td></tr>
<tr class="separator:adbeb3c604a337ce88bd4e9d8beb78806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a3bfa09d16108be8995658502f93a4"><td class="memItemLeft" align="right" valign="top"><a id="a60a3bfa09d16108be8995658502f93a4"></a>
vector&lt; <a class="el" href="classAddrSpace.html">AddrSpace</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a60a3bfa09d16108be8995658502f93a4">inferPtrSpaces</a></td></tr>
<tr class="memdesc:a60a3bfa09d16108be8995658502f93a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of address spaces in which a pointer constant is inferable. <br /></td></tr>
<tr class="separator:a60a3bfa09d16108be8995658502f93a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b94f4312717f6cd89eb784e3e73611"><td class="memItemLeft" align="right" valign="top"><a id="af1b94f4312717f6cd89eb784e3e73611"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#af1b94f4312717f6cd89eb784e3e73611">funcptr_align</a></td></tr>
<tr class="memdesc:af1b94f4312717f6cd89eb784e3e73611"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many bits of alignment a function ptr has. <br /></td></tr>
<tr class="separator:af1b94f4312717f6cd89eb784e3e73611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed18744b8dc08d3ca81d6b1b6df682e"><td class="memItemLeft" align="right" valign="top"><a id="a4ed18744b8dc08d3ca81d6b1b6df682e"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a4ed18744b8dc08d3ca81d6b1b6df682e">flowoptions</a></td></tr>
<tr class="memdesc:a4ed18744b8dc08d3ca81d6b1b6df682e"><td class="mdescLeft">&#160;</td><td class="mdescRight">options passed to flow following engine <br /></td></tr>
<tr class="separator:a4ed18744b8dc08d3ca81d6b1b6df682e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb5b3b31fe283d2a030246872bc4855"><td class="memItemLeft" align="right" valign="top"><a id="a6eb5b3b31fe283d2a030246872bc4855"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a6eb5b3b31fe283d2a030246872bc4855">alias_block_level</a></td></tr>
<tr class="memdesc:a6eb5b3b31fe283d2a030246872bc4855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliases blocked by 0=none, 1=struct, 2=array, 3=all. <br /></td></tr>
<tr class="separator:a6eb5b3b31fe283d2a030246872bc4855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6218d36328733cd9798ad6c3dbe921d8"><td class="memItemLeft" align="right" valign="top"><a id="a6218d36328733cd9798ad6c3dbe921d8"></a>
vector&lt; <a class="el" href="classRule.html">Rule</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a6218d36328733cd9798ad6c3dbe921d8">extra_pool_rules</a></td></tr>
<tr class="memdesc:a6218d36328733cd9798ad6c3dbe921d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extra rules that go in the main pool (cpu specific, experimental) <br /></td></tr>
<tr class="separator:a6218d36328733cd9798ad6c3dbe921d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab426c9baa9013d9826041a4083e844ef"><td class="memItemLeft" align="right" valign="top"><a id="ab426c9baa9013d9826041a4083e844ef"></a>
<a class="el" href="classDatabase.html">Database</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">symboltab</a></td></tr>
<tr class="memdesc:ab426c9baa9013d9826041a4083e844ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory map of global variables and functions. <br /></td></tr>
<tr class="separator:ab426c9baa9013d9826041a4083e844ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbd3d4cf806f7ca3a2a2943aab28165"><td class="memItemLeft" align="right" valign="top"><a id="abbbd3d4cf806f7ca3a2a2943aab28165"></a>
<a class="el" href="classContextDatabase.html">ContextDatabase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#abbbd3d4cf806f7ca3a2a2943aab28165">context</a></td></tr>
<tr class="memdesc:abbbd3d4cf806f7ca3a2a2943aab28165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from addresses to context settings. <br /></td></tr>
<tr class="separator:abbbd3d4cf806f7ca3a2a2943aab28165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15c8b7bbcb9408075014902da4f8687"><td class="memItemLeft" align="right" valign="top"><a id="ab15c8b7bbcb9408075014902da4f8687"></a>
map&lt; string, <a class="el" href="classProtoModel.html">ProtoModel</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#ab15c8b7bbcb9408075014902da4f8687">protoModels</a></td></tr>
<tr class="memdesc:ab15c8b7bbcb9408075014902da4f8687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsed forms of possible prototypes. <br /></td></tr>
<tr class="separator:ab15c8b7bbcb9408075014902da4f8687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0f5d45f6dcd494b15bb55f81f656b2"><td class="memItemLeft" align="right" valign="top"><a id="a1e0f5d45f6dcd494b15bb55f81f656b2"></a>
<a class="el" href="classProtoModel.html">ProtoModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a1e0f5d45f6dcd494b15bb55f81f656b2">defaultfp</a></td></tr>
<tr class="memdesc:a1e0f5d45f6dcd494b15bb55f81f656b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsed form of default prototype. <br /></td></tr>
<tr class="separator:a1e0f5d45f6dcd494b15bb55f81f656b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b5e0d6c22247d4ec2422c81ddec8f8"><td class="memItemLeft" align="right" valign="top"><a id="ad0b5e0d6c22247d4ec2422c81ddec8f8"></a>
<a class="el" href="structVarnodeData.html">VarnodeData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#ad0b5e0d6c22247d4ec2422c81ddec8f8">defaultReturnAddr</a></td></tr>
<tr class="memdesc:ad0b5e0d6c22247d4ec2422c81ddec8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default storage location of return address (for current function) <br /></td></tr>
<tr class="separator:ad0b5e0d6c22247d4ec2422c81ddec8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb08ee0ed38a4c586a99d0f45a3af6e"><td class="memItemLeft" align="right" valign="top"><a id="a9fb08ee0ed38a4c586a99d0f45a3af6e"></a>
<a class="el" href="classProtoModel.html">ProtoModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a9fb08ee0ed38a4c586a99d0f45a3af6e">evalfp_current</a></td></tr>
<tr class="memdesc:a9fb08ee0ed38a4c586a99d0f45a3af6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function proto to use when evaluating current function. <br /></td></tr>
<tr class="separator:a9fb08ee0ed38a4c586a99d0f45a3af6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c624320bcc9d52dcecdf553f3b4796"><td class="memItemLeft" align="right" valign="top"><a id="a44c624320bcc9d52dcecdf553f3b4796"></a>
<a class="el" href="classProtoModel.html">ProtoModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a44c624320bcc9d52dcecdf553f3b4796">evalfp_called</a></td></tr>
<tr class="memdesc:a44c624320bcc9d52dcecdf553f3b4796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function proto to use when evaluating called functions. <br /></td></tr>
<tr class="separator:a44c624320bcc9d52dcecdf553f3b4796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8225ba7bd6ac802660e03ee793289dd1"><td class="memItemLeft" align="right" valign="top"><a id="a8225ba7bd6ac802660e03ee793289dd1"></a>
<a class="el" href="classTypeFactory.html">TypeFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">types</a></td></tr>
<tr class="memdesc:a8225ba7bd6ac802660e03ee793289dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of types for this binary. <br /></td></tr>
<tr class="separator:a8225ba7bd6ac802660e03ee793289dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f2db17fdc609a7d1cedbc0a2eb7753"><td class="memItemLeft" align="right" valign="top"><a id="a81f2db17fdc609a7d1cedbc0a2eb7753"></a>
const <a class="el" href="classTranslate.html">Translate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a81f2db17fdc609a7d1cedbc0a2eb7753">translate</a></td></tr>
<tr class="memdesc:a81f2db17fdc609a7d1cedbc0a2eb7753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translation method for this binary. <br /></td></tr>
<tr class="separator:a81f2db17fdc609a7d1cedbc0a2eb7753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344b1348ed8f0bbe0d050e7038bb290d"><td class="memItemLeft" align="right" valign="top"><a id="a344b1348ed8f0bbe0d050e7038bb290d"></a>
<a class="el" href="classLoadImage.html">LoadImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a344b1348ed8f0bbe0d050e7038bb290d">loader</a></td></tr>
<tr class="memdesc:a344b1348ed8f0bbe0d050e7038bb290d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for loading portions of binary. <br /></td></tr>
<tr class="separator:a344b1348ed8f0bbe0d050e7038bb290d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d04d77ca75b9e75caa3750c156d9bbf"><td class="memItemLeft" align="right" valign="top"><a id="a7d04d77ca75b9e75caa3750c156d9bbf"></a>
<a class="el" href="classPcodeInjectLibrary.html">PcodeInjectLibrary</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a7d04d77ca75b9e75caa3750c156d9bbf">pcodeinjectlib</a></td></tr>
<tr class="memdesc:a7d04d77ca75b9e75caa3750c156d9bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pcode injection manager. <br /></td></tr>
<tr class="separator:a7d04d77ca75b9e75caa3750c156d9bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693da460aeb788e4fbaf3361bd07756a"><td class="memItemLeft" align="right" valign="top"><a id="a693da460aeb788e4fbaf3361bd07756a"></a>
<a class="el" href="classRangeList.html">RangeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a693da460aeb788e4fbaf3361bd07756a">nohighptr</a></td></tr>
<tr class="memdesc:a693da460aeb788e4fbaf3361bd07756a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ranges for which high-level pointers are not possible. <br /></td></tr>
<tr class="separator:a693da460aeb788e4fbaf3361bd07756a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5425576df9b7ce15b6ddddbf17b03df6"><td class="memItemLeft" align="right" valign="top"><a id="a5425576df9b7ce15b6ddddbf17b03df6"></a>
<a class="el" href="classCommentDatabase.html">CommentDatabase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a5425576df9b7ce15b6ddddbf17b03df6">commentdb</a></td></tr>
<tr class="memdesc:a5425576df9b7ce15b6ddddbf17b03df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comments for this architecture. <br /></td></tr>
<tr class="separator:a5425576df9b7ce15b6ddddbf17b03df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb5761c98d8af556fb59753d68dfd97"><td class="memItemLeft" align="right" valign="top"><a id="adeb5761c98d8af556fb59753d68dfd97"></a>
<a class="el" href="classConstantPool.html">ConstantPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#adeb5761c98d8af556fb59753d68dfd97">cpool</a></td></tr>
<tr class="memdesc:adeb5761c98d8af556fb59753d68dfd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deferred constant values. <br /></td></tr>
<tr class="separator:adeb5761c98d8af556fb59753d68dfd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72890bc88edf8d6074e24d92fd31c57"><td class="memItemLeft" align="right" valign="top"><a id="af72890bc88edf8d6074e24d92fd31c57"></a>
<a class="el" href="classPrintLanguage.html">PrintLanguage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#af72890bc88edf8d6074e24d92fd31c57">print</a></td></tr>
<tr class="memdesc:af72890bc88edf8d6074e24d92fd31c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current high-level language printer. <br /></td></tr>
<tr class="separator:af72890bc88edf8d6074e24d92fd31c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118dbf145a9f2b6cae5d48b40f00e4d8"><td class="memItemLeft" align="right" valign="top"><a id="a118dbf145a9f2b6cae5d48b40f00e4d8"></a>
vector&lt; <a class="el" href="classPrintLanguage.html">PrintLanguage</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a118dbf145a9f2b6cae5d48b40f00e4d8">printlist</a></td></tr>
<tr class="memdesc:a118dbf145a9f2b6cae5d48b40f00e4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of high-level language printers supported. <br /></td></tr>
<tr class="separator:a118dbf145a9f2b6cae5d48b40f00e4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab581a0109bda8e9206bb155a80a3a694"><td class="memItemLeft" align="right" valign="top"><a id="ab581a0109bda8e9206bb155a80a3a694"></a>
<a class="el" href="classOptionDatabase.html">OptionDatabase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#ab581a0109bda8e9206bb155a80a3a694">options</a></td></tr>
<tr class="memdesc:ab581a0109bda8e9206bb155a80a3a694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options that can be configured. <br /></td></tr>
<tr class="separator:ab581a0109bda8e9206bb155a80a3a694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9badb712693d9abec7e21abc20fde1"><td class="memItemLeft" align="right" valign="top"><a id="a3a9badb712693d9abec7e21abc20fde1"></a>
vector&lt; <a class="el" href="classTypeOp.html">TypeOp</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a3a9badb712693d9abec7e21abc20fde1">inst</a></td></tr>
<tr class="memdesc:a3a9badb712693d9abec7e21abc20fde1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registered p-code instructions. <br /></td></tr>
<tr class="separator:a3a9badb712693d9abec7e21abc20fde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9c927fbda44de1ab46122f49248003"><td class="memItemLeft" align="right" valign="top"><a id="abd9c927fbda44de1ab46122f49248003"></a>
<a class="el" href="classUserOpManage.html">UserOpManage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#abd9c927fbda44de1ab46122f49248003">userops</a></td></tr>
<tr class="memdesc:abd9c927fbda44de1ab46122f49248003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifically registered user-defined p-code ops. <br /></td></tr>
<tr class="separator:abd9c927fbda44de1ab46122f49248003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed25d7790e67e8bfaef34c092e5f39b"><td class="memItemLeft" align="right" valign="top"><a id="a2ed25d7790e67e8bfaef34c092e5f39b"></a>
vector&lt; <a class="el" href="structPreferSplitRecord.html">PreferSplitRecord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a2ed25d7790e67e8bfaef34c092e5f39b">splitrecords</a></td></tr>
<tr class="memdesc:a2ed25d7790e67e8bfaef34c092e5f39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">registers that we would prefer to see split for this processor <br /></td></tr>
<tr class="separator:a2ed25d7790e67e8bfaef34c092e5f39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60119c02b8a8de5e5510364556f194fb"><td class="memItemLeft" align="right" valign="top"><a id="a60119c02b8a8de5e5510364556f194fb"></a>
vector&lt; <a class="el" href="classLanedRegister.html">LanedRegister</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a60119c02b8a8de5e5510364556f194fb">lanerecords</a></td></tr>
<tr class="memdesc:a60119c02b8a8de5e5510364556f194fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector registers that have preferred lane sizes. <br /></td></tr>
<tr class="separator:a60119c02b8a8de5e5510364556f194fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbe1c5d170cb2a4d359765b97fef26f"><td class="memItemLeft" align="right" valign="top"><a id="a4cbe1c5d170cb2a4d359765b97fef26f"></a>
<a class="el" href="classActionDatabase.html">ActionDatabase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a4cbe1c5d170cb2a4d359765b97fef26f">allacts</a></td></tr>
<tr class="memdesc:a4cbe1c5d170cb2a4d359765b97fef26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions that can be applied in this architecture. <br /></td></tr>
<tr class="separator:a4cbe1c5d170cb2a4d359765b97fef26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff44e0cd6303a22689d6601fc5418918"><td class="memItemLeft" align="right" valign="top"><a id="aff44e0cd6303a22689d6601fc5418918"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#aff44e0cd6303a22689d6601fc5418918">loadersymbols_parsed</a></td></tr>
<tr class="memdesc:aff44e0cd6303a22689d6601fc5418918"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if loader symbols have been read. <br /></td></tr>
<tr class="separator:aff44e0cd6303a22689d6601fc5418918"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3bbc62dedbb13b6fdb2969e1e83446d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a3bbc62dedbb13b6fdb2969e1e83446d5">addSpacebase</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *basespace, const string &amp;nm, const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;ptrdata, int4 truncSize, bool isreversejustified, bool stackGrowth)</td></tr>
<tr class="memdesc:a3bbc62dedbb13b6fdb2969e1e83446d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new space and associated pointer.  <a href="classArchitecture.html#a3bbc62dedbb13b6fdb2969e1e83446d5">More...</a><br /></td></tr>
<tr class="separator:a3bbc62dedbb13b6fdb2969e1e83446d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70efc8f5d9e212d039dccbfe8556f05d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a70efc8f5d9e212d039dccbfe8556f05d">addNoHighPtr</a> (const <a class="el" href="classRange.html">Range</a> &amp;rng)</td></tr>
<tr class="memdesc:a70efc8f5d9e212d039dccbfe8556f05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new region where pointers do not exist.  <a href="classArchitecture.html#a70efc8f5d9e212d039dccbfe8556f05d">More...</a><br /></td></tr>
<tr class="separator:a70efc8f5d9e212d039dccbfe8556f05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2d6a96b669efefe4b89915aa8a65f7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#afa2d6a96b669efefe4b89915aa8a65f7">buildGlobalScope</a> (void)</td></tr>
<tr class="memdesc:afa2d6a96b669efefe4b89915aa8a65f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the global scope for this executable.  <a href="classArchitecture.html#afa2d6a96b669efefe4b89915aa8a65f7">More...</a><br /></td></tr>
<tr class="separator:afa2d6a96b669efefe4b89915aa8a65f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab951056481cac3e73770db9d567d5212"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTranslate.html">Translate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#ab951056481cac3e73770db9d567d5212">buildTranslator</a> (<a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;store)=0</td></tr>
<tr class="memdesc:ab951056481cac3e73770db9d567d5212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the Translator object.  <a href="classArchitecture.html#ab951056481cac3e73770db9d567d5212">More...</a><br /></td></tr>
<tr class="separator:ab951056481cac3e73770db9d567d5212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a19e1f07ba0449dfb21d3388b0dbc33"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a9a19e1f07ba0449dfb21d3388b0dbc33">buildLoader</a> (<a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;store)=0</td></tr>
<tr class="memdesc:a9a19e1f07ba0449dfb21d3388b0dbc33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the <a class="el" href="classLoadImage.html" title="An interface into a particular binary executable image.">LoadImage</a> object and load the executable image.  <a href="classArchitecture.html#a9a19e1f07ba0449dfb21d3388b0dbc33">More...</a><br /></td></tr>
<tr class="separator:a9a19e1f07ba0449dfb21d3388b0dbc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dae4f59e2c196a623b45e68cacc1a7a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPcodeInjectLibrary.html">PcodeInjectLibrary</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a7dae4f59e2c196a623b45e68cacc1a7a">buildPcodeInjectLibrary</a> (void)=0</td></tr>
<tr class="memdesc:a7dae4f59e2c196a623b45e68cacc1a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the injection library.  <a href="classArchitecture.html#a7dae4f59e2c196a623b45e68cacc1a7a">More...</a><br /></td></tr>
<tr class="separator:a7dae4f59e2c196a623b45e68cacc1a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf041374ee649d2c0d8e95e450af5bf9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#aaf041374ee649d2c0d8e95e450af5bf9">buildTypegrp</a> (<a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;store)</td></tr>
<tr class="memdesc:aaf041374ee649d2c0d8e95e450af5bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the data-type factory/container.  <a href="classArchitecture.html#aaf041374ee649d2c0d8e95e450af5bf9">More...</a><br /></td></tr>
<tr class="separator:aaf041374ee649d2c0d8e95e450af5bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517bf0e0ba766b241edf122422766249"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a517bf0e0ba766b241edf122422766249">buildCommentDB</a> (<a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;store)</td></tr>
<tr class="memdesc:a517bf0e0ba766b241edf122422766249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the comment database.  <a href="classArchitecture.html#a517bf0e0ba766b241edf122422766249">More...</a><br /></td></tr>
<tr class="separator:a517bf0e0ba766b241edf122422766249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8aa1186293e453601bedb0db3d4ec1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#aed8aa1186293e453601bedb0db3d4ec1">buildConstantPool</a> (<a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;store)</td></tr>
<tr class="memdesc:aed8aa1186293e453601bedb0db3d4ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the constant pool.  <a href="classArchitecture.html#aed8aa1186293e453601bedb0db3d4ec1">More...</a><br /></td></tr>
<tr class="separator:aed8aa1186293e453601bedb0db3d4ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa059c551a53018c8d70a1c2f9fc6ed73"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#aa059c551a53018c8d70a1c2f9fc6ed73">buildInstructions</a> (<a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;store)</td></tr>
<tr class="memdesc:aa059c551a53018c8d70a1c2f9fc6ed73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the p-code operations.  <a href="classArchitecture.html#aa059c551a53018c8d70a1c2f9fc6ed73">More...</a><br /></td></tr>
<tr class="separator:aa059c551a53018c8d70a1c2f9fc6ed73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad646d95818d9c3615da8a259732546b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#ad646d95818d9c3615da8a259732546b8">buildAction</a> (<a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;store)</td></tr>
<tr class="memdesc:ad646d95818d9c3615da8a259732546b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the <a class="el" href="classAction.html" title="Large scale transformations applied to the varnode/op graph.">Action</a> framework.  <a href="classArchitecture.html#ad646d95818d9c3615da8a259732546b8">More...</a><br /></td></tr>
<tr class="separator:ad646d95818d9c3615da8a259732546b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2fd38d4d08155637ebee1e043fd9a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a9a2fd38d4d08155637ebee1e043fd9a8">buildContext</a> (<a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;store)</td></tr>
<tr class="memdesc:a9a2fd38d4d08155637ebee1e043fd9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the Context database.  <a href="classArchitecture.html#a9a2fd38d4d08155637ebee1e043fd9a8">More...</a><br /></td></tr>
<tr class="separator:a9a2fd38d4d08155637ebee1e043fd9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e8edfa21e63d4b37b8003397804933"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#ad9e8edfa21e63d4b37b8003397804933">buildSpecFile</a> (<a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;store)=0</td></tr>
<tr class="memdesc:ad9e8edfa21e63d4b37b8003397804933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load any relevant specification files.  <a href="classArchitecture.html#ad9e8edfa21e63d4b37b8003397804933">More...</a><br /></td></tr>
<tr class="separator:ad9e8edfa21e63d4b37b8003397804933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1784d8729ba0f13cd7ea63ee546995"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#aec1784d8729ba0f13cd7ea63ee546995">modifySpaces</a> (<a class="el" href="classTranslate.html">Translate</a> *trans)=0</td></tr>
<tr class="memdesc:aec1784d8729ba0f13cd7ea63ee546995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify address spaces as required by <b>this</b> <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a>.  <a href="classArchitecture.html#aec1784d8729ba0f13cd7ea63ee546995">More...</a><br /></td></tr>
<tr class="separator:aec1784d8729ba0f13cd7ea63ee546995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0174d51a9975df9be6a6e603d65b1c6c"><td class="memItemLeft" align="right" valign="top"><a id="a0174d51a9975df9be6a6e603d65b1c6c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a0174d51a9975df9be6a6e603d65b1c6c">postSpecFile</a> (void)</td></tr>
<tr class="memdesc:a0174d51a9975df9be6a6e603d65b1c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let components initialize after <a class="el" href="classTranslate.html" title="The interface to a translation engine for a processor.">Translate</a> is built. <br /></td></tr>
<tr class="separator:a0174d51a9975df9be6a6e603d65b1c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7d061dab582340c8e9bb3323abdf4a"><td class="memItemLeft" align="right" valign="top"><a id="aea7d061dab582340c8e9bb3323abdf4a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#aea7d061dab582340c8e9bb3323abdf4a">resolveArchitecture</a> (void)=0</td></tr>
<tr class="memdesc:aea7d061dab582340c8e9bb3323abdf4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Figure out the processor and compiler of the target executable. <br /></td></tr>
<tr class="separator:aea7d061dab582340c8e9bb3323abdf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed18df408eb73d0735966c68b44e413b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#aed18df408eb73d0735966c68b44e413b">restoreFromSpec</a> (<a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;store)</td></tr>
<tr class="memdesc:aed18df408eb73d0735966c68b44e413b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully initialize the <a class="el" href="classTranslate.html" title="The interface to a translation engine for a processor.">Translate</a> object.  <a href="classArchitecture.html#aed18df408eb73d0735966c68b44e413b">More...</a><br /></td></tr>
<tr class="separator:aed18df408eb73d0735966c68b44e413b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b374a6d9b25a638567c3519ac1796c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a74b374a6d9b25a638567c3519ac1796c">fillinReadOnlyFromLoader</a> (void)</td></tr>
<tr class="memdesc:a74b374a6d9b25a638567c3519ac1796c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load info about read-only sections.  <a href="classArchitecture.html#a74b374a6d9b25a638567c3519ac1796c">More...</a><br /></td></tr>
<tr class="separator:a74b374a6d9b25a638567c3519ac1796c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fb7a8902a213abbf0c730fa5b6a9d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a20fb7a8902a213abbf0c730fa5b6a9d7">initializeSegments</a> ()</td></tr>
<tr class="memdesc:a20fb7a8902a213abbf0c730fa5b6a9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up segment resolvers.  <a href="classArchitecture.html#a20fb7a8902a213abbf0c730fa5b6a9d7">More...</a><br /></td></tr>
<tr class="separator:a20fb7a8902a213abbf0c730fa5b6a9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b9348b5c4279321a8f9014541e5194"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#aa4b9348b5c4279321a8f9014541e5194">cacheAddrSpaceProperties</a> (void)</td></tr>
<tr class="memdesc:aa4b9348b5c4279321a8f9014541e5194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate some frequently used space properties and cache them.  <a href="classArchitecture.html#aa4b9348b5c4279321a8f9014541e5194">More...</a><br /></td></tr>
<tr class="separator:aa4b9348b5c4279321a8f9014541e5194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd4815cc79c6582840043de2e3e65eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a4cd4815cc79c6582840043de2e3e65eb">parseProcessorConfig</a> (<a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;store)</td></tr>
<tr class="memdesc:a4cd4815cc79c6582840043de2e3e65eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply processor specific configuration.  <a href="classArchitecture.html#a4cd4815cc79c6582840043de2e3e65eb">More...</a><br /></td></tr>
<tr class="separator:a4cd4815cc79c6582840043de2e3e65eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20147b2a4be785c30ea29cc7d9278b42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">parseCompilerConfig</a> (<a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;store)</td></tr>
<tr class="memdesc:a20147b2a4be785c30ea29cc7d9278b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply compiler specific configuration.  <a href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">More...</a><br /></td></tr>
<tr class="separator:a20147b2a4be785c30ea29cc7d9278b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568ff11996bb679327d3d83dbb50d454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a568ff11996bb679327d3d83dbb50d454">parseExtraRules</a> (<a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;store)</td></tr>
<tr class="memdesc:a568ff11996bb679327d3d83dbb50d454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply any <a class="el" href="classRule.html" title="Class for performing a single transformation on a PcodeOp or Varnode.">Rule</a> tags.  <a href="classArchitecture.html#a568ff11996bb679327d3d83dbb50d454">More...</a><br /></td></tr>
<tr class="separator:a568ff11996bb679327d3d83dbb50d454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6b370b90db6fbf3a8b8b62740c77ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#aef6b370b90db6fbf3a8b8b62740c77ba">parseDynamicRule</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:aef6b370b90db6fbf3a8b8b62740c77ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply details of a dynamic <a class="el" href="classRule.html" title="Class for performing a single transformation on a PcodeOp or Varnode.">Rule</a> object.  <a href="classArchitecture.html#aef6b370b90db6fbf3a8b8b62740c77ba">More...</a><br /></td></tr>
<tr class="separator:aef6b370b90db6fbf3a8b8b62740c77ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2938da725012462a68a85627a2dc2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classProtoModel.html">ProtoModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#afb2938da725012462a68a85627a2dc2c">parseProto</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:afb2938da725012462a68a85627a2dc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a proto-type model from an XML tag.  <a href="classArchitecture.html#afb2938da725012462a68a85627a2dc2c">More...</a><br /></td></tr>
<tr class="separator:afb2938da725012462a68a85627a2dc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e32daad5f4744f55c43f8acdd7ee8eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a3e32daad5f4744f55c43f8acdd7ee8eb">parseProtoEval</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a3e32daad5f4744f55c43f8acdd7ee8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply prototype evaluation configuration.  <a href="classArchitecture.html#a3e32daad5f4744f55c43f8acdd7ee8eb">More...</a><br /></td></tr>
<tr class="separator:a3e32daad5f4744f55c43f8acdd7ee8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea36f2638d65351dd00ba06fe0dc00b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a1ea36f2638d65351dd00ba06fe0dc00b">parseDefaultProto</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a1ea36f2638d65351dd00ba06fe0dc00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply default prototype model configuration.  <a href="classArchitecture.html#a1ea36f2638d65351dd00ba06fe0dc00b">More...</a><br /></td></tr>
<tr class="separator:a1ea36f2638d65351dd00ba06fe0dc00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6348f797097deb07776eca437458ecc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a6348f797097deb07776eca437458ecc8">parseGlobal</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a6348f797097deb07776eca437458ecc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply global space configuration.  <a href="classArchitecture.html#a6348f797097deb07776eca437458ecc8">More...</a><br /></td></tr>
<tr class="separator:a6348f797097deb07776eca437458ecc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c6730574d3dc658db221b50831d416"><td class="memItemLeft" align="right" valign="top"><a id="af0c6730574d3dc658db221b50831d416"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#af0c6730574d3dc658db221b50831d416">addOtherSpace</a> (void)</td></tr>
<tr class="memdesc:af0c6730574d3dc658db221b50831d416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add OTHER space and all of its overlays to the symboltab. <br /></td></tr>
<tr class="separator:af0c6730574d3dc658db221b50831d416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85374e24548406ae6497021150aa5d2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a85374e24548406ae6497021150aa5d2c">parseReadOnly</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a85374e24548406ae6497021150aa5d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply read-only region configuration.  <a href="classArchitecture.html#a85374e24548406ae6497021150aa5d2c">More...</a><br /></td></tr>
<tr class="separator:a85374e24548406ae6497021150aa5d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90175b3753d44c818064e08425c57d97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a90175b3753d44c818064e08425c57d97">parseVolatile</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a90175b3753d44c818064e08425c57d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply volatile region configuration.  <a href="classArchitecture.html#a90175b3753d44c818064e08425c57d97">More...</a><br /></td></tr>
<tr class="separator:a90175b3753d44c818064e08425c57d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24090e497ce6273f83bcb842be816ccb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a24090e497ce6273f83bcb842be816ccb">parseReturnAddress</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a24090e497ce6273f83bcb842be816ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply return address configuration.  <a href="classArchitecture.html#a24090e497ce6273f83bcb842be816ccb">More...</a><br /></td></tr>
<tr class="separator:a24090e497ce6273f83bcb842be816ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2290f8d9cf479d4b49fb26c83ff8c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a8b2290f8d9cf479d4b49fb26c83ff8c5">parseIncidentalCopy</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a8b2290f8d9cf479d4b49fb26c83ff8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply incidental copy configuration.  <a href="classArchitecture.html#a8b2290f8d9cf479d4b49fb26c83ff8c5">More...</a><br /></td></tr>
<tr class="separator:a8b2290f8d9cf479d4b49fb26c83ff8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d66be927f6539c287de92687838869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a59d66be927f6539c287de92687838869">parseLaneSizes</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a59d66be927f6539c287de92687838869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply lane size configuration.  <a href="classArchitecture.html#a59d66be927f6539c287de92687838869">More...</a><br /></td></tr>
<tr class="separator:a59d66be927f6539c287de92687838869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac48da0d464ff216982db607b43d4757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#aac48da0d464ff216982db607b43d4757">parseStackPointer</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:aac48da0d464ff216982db607b43d4757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply stack pointer configuration.  <a href="classArchitecture.html#aac48da0d464ff216982db607b43d4757">More...</a><br /></td></tr>
<tr class="separator:aac48da0d464ff216982db607b43d4757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ad4de633bc630b03425ab46b31f42b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a29ad4de633bc630b03425ab46b31f42b">parseDeadcodeDelay</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a29ad4de633bc630b03425ab46b31f42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply dead-code delay configuration.  <a href="classArchitecture.html#a29ad4de633bc630b03425ab46b31f42b">More...</a><br /></td></tr>
<tr class="separator:a29ad4de633bc630b03425ab46b31f42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e10589073ea41018047b8affb10025e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a5e10589073ea41018047b8affb10025e">parseFuncPtrAlign</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a5e10589073ea41018047b8affb10025e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply function pointer alignment configuration.  <a href="classArchitecture.html#a5e10589073ea41018047b8affb10025e">More...</a><br /></td></tr>
<tr class="separator:a5e10589073ea41018047b8affb10025e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3b1aecaff0ca84c647ddbe6e25de5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#adf3b1aecaff0ca84c647ddbe6e25de5c">parseSpacebase</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:adf3b1aecaff0ca84c647ddbe6e25de5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an additional indexed space.  <a href="classArchitecture.html#adf3b1aecaff0ca84c647ddbe6e25de5c">More...</a><br /></td></tr>
<tr class="separator:adf3b1aecaff0ca84c647ddbe6e25de5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f51fadb288b36927fa9dfda725ffd88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a6f51fadb288b36927fa9dfda725ffd88">parseNoHighPtr</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a6f51fadb288b36927fa9dfda725ffd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply memory alias configuration.  <a href="classArchitecture.html#a6f51fadb288b36927fa9dfda725ffd88">More...</a><br /></td></tr>
<tr class="separator:a6f51fadb288b36927fa9dfda725ffd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbe749d5bcc143838f2590fc08acf26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a7cbe749d5bcc143838f2590fc08acf26">parsePreferSplit</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a7cbe749d5bcc143838f2590fc08acf26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Designate registers to be split.  <a href="classArchitecture.html#a7cbe749d5bcc143838f2590fc08acf26">More...</a><br /></td></tr>
<tr class="separator:a7cbe749d5bcc143838f2590fc08acf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be334560223db2a9742d8097edf2cf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArchitecture.html#a8be334560223db2a9742d8097edf2cf6">parseAggressiveTrim</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a8be334560223db2a9742d8097edf2cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Designate how to trim extension p-code ops.  <a href="classArchitecture.html#a8be334560223db2a9742d8097edf2cf6">More...</a><br /></td></tr>
<tr class="separator:a8be334560223db2a9742d8097edf2cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classAddrSpaceManager"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classAddrSpaceManager')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a></td></tr>
<tr class="memitem:a107cb2ba1e4c562090ac1ad3b94cd16b inherit pro_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a107cb2ba1e4c562090ac1ad3b94cd16b">restoreXmlSpace</a> (const <a class="el" href="classElement.html">Element</a> *el, const <a class="el" href="classTranslate.html">Translate</a> *trans)</td></tr>
<tr class="memdesc:a107cb2ba1e4c562090ac1ad3b94cd16b inherit pro_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a space to the model based an on XML tag.  <a href="classAddrSpaceManager.html#a107cb2ba1e4c562090ac1ad3b94cd16b">More...</a><br /></td></tr>
<tr class="separator:a107cb2ba1e4c562090ac1ad3b94cd16b inherit pro_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196d3c70790942337861ae7d571c5e31 inherit pro_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a196d3c70790942337861ae7d571c5e31">restoreXmlSpaces</a> (const <a class="el" href="classElement.html">Element</a> *el, const <a class="el" href="classTranslate.html">Translate</a> *trans)</td></tr>
<tr class="memdesc:a196d3c70790942337861ae7d571c5e31 inherit pro_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore address spaces in the model from an XML tag.  <a href="classAddrSpaceManager.html#a196d3c70790942337861ae7d571c5e31">More...</a><br /></td></tr>
<tr class="separator:a196d3c70790942337861ae7d571c5e31 inherit pro_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9001bbb4f273b895325e1cad6a8930d6 inherit pro_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a9001bbb4f273b895325e1cad6a8930d6">setDefaultCodeSpace</a> (int4 index)</td></tr>
<tr class="memdesc:a9001bbb4f273b895325e1cad6a8930d6 inherit pro_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default address space (for code)  <a href="classAddrSpaceManager.html#a9001bbb4f273b895325e1cad6a8930d6">More...</a><br /></td></tr>
<tr class="separator:a9001bbb4f273b895325e1cad6a8930d6 inherit pro_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5889b07364f07bbc30f79cda62a68d23 inherit pro_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a5889b07364f07bbc30f79cda62a68d23">setDefaultDataSpace</a> (int4 index)</td></tr>
<tr class="memdesc:a5889b07364f07bbc30f79cda62a68d23 inherit pro_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default address space for data.  <a href="classAddrSpaceManager.html#a5889b07364f07bbc30f79cda62a68d23">More...</a><br /></td></tr>
<tr class="separator:a5889b07364f07bbc30f79cda62a68d23 inherit pro_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdab85595c68e18ab86dd42af914f35b inherit pro_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#abdab85595c68e18ab86dd42af914f35b">setReverseJustified</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:abdab85595c68e18ab86dd42af914f35b inherit pro_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set reverse justified property on this space.  <a href="classAddrSpaceManager.html#abdab85595c68e18ab86dd42af914f35b">More...</a><br /></td></tr>
<tr class="separator:abdab85595c68e18ab86dd42af914f35b inherit pro_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5300e7a40dba53c7c78fdacebfc6ed inherit pro_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a9d5300e7a40dba53c7c78fdacebfc6ed">assignShortcut</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:a9d5300e7a40dba53c7c78fdacebfc6ed inherit pro_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a shortcut character for a new space.  <a href="classAddrSpaceManager.html#a9d5300e7a40dba53c7c78fdacebfc6ed">More...</a><br /></td></tr>
<tr class="separator:a9d5300e7a40dba53c7c78fdacebfc6ed inherit pro_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1c818ccc3950c188e06df08746725f inherit pro_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#aba1c818ccc3950c188e06df08746725f">markNearPointers</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, int4 size)</td></tr>
<tr class="memdesc:aba1c818ccc3950c188e06df08746725f inherit pro_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that given space can be accessed with near pointers.  <a href="classAddrSpaceManager.html#aba1c818ccc3950c188e06df08746725f">More...</a><br /></td></tr>
<tr class="separator:aba1c818ccc3950c188e06df08746725f inherit pro_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89658bd677414a271a918f0f37af0bd6 inherit pro_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a89658bd677414a271a918f0f37af0bd6">insertSpace</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:a89658bd677414a271a918f0f37af0bd6 inherit pro_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new address space to the model.  <a href="classAddrSpaceManager.html#a89658bd677414a271a918f0f37af0bd6">More...</a><br /></td></tr>
<tr class="separator:a89658bd677414a271a918f0f37af0bd6 inherit pro_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45068bcc8331bebc780f00e51bd85250 inherit pro_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a45068bcc8331bebc780f00e51bd85250">copySpaces</a> (const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *op2)</td></tr>
<tr class="memdesc:a45068bcc8331bebc780f00e51bd85250 inherit pro_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy spaces from another manager.  <a href="classAddrSpaceManager.html#a45068bcc8331bebc780f00e51bd85250">More...</a><br /></td></tr>
<tr class="separator:a45068bcc8331bebc780f00e51bd85250 inherit pro_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd0ab3084fd8bb9cb4ea5a84885704d inherit pro_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a6dd0ab3084fd8bb9cb4ea5a84885704d">addSpacebasePointer</a> (<a class="el" href="classSpacebaseSpace.html">SpacebaseSpace</a> *basespace, const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;ptrdata, int4 truncSize, bool stackGrowth)</td></tr>
<tr class="memdesc:a6dd0ab3084fd8bb9cb4ea5a84885704d inherit pro_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the base register of a spacebase space.  <a href="classAddrSpaceManager.html#a6dd0ab3084fd8bb9cb4ea5a84885704d">More...</a><br /></td></tr>
<tr class="separator:a6dd0ab3084fd8bb9cb4ea5a84885704d inherit pro_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6330481f1f40a24d860c820a5a2b64f5 inherit pro_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a6330481f1f40a24d860c820a5a2b64f5">insertResolver</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, <a class="el" href="classAddressResolver.html">AddressResolver</a> *rsolv)</td></tr>
<tr class="memdesc:a6330481f1f40a24d860c820a5a2b64f5 inherit pro_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOverride.html" title="A container of commands that override the decompiler&#39;s default behavior for a single function.">Override</a> the base resolver for a space.  <a href="classAddrSpaceManager.html#a6330481f1f40a24d860c820a5a2b64f5">More...</a><br /></td></tr>
<tr class="separator:a6330481f1f40a24d860c820a5a2b64f5 inherit pro_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79ba636cc911bcd83371f00436f1dc5 inherit pro_methods_classAddrSpaceManager"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJoinRecord.html">JoinRecord</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#ad79ba636cc911bcd83371f00436f1dc5">findJoinInternal</a> (uintb offset) const</td></tr>
<tr class="memdesc:ad79ba636cc911bcd83371f00436f1dc5 inherit pro_methods_classAddrSpaceManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split.">JoinRecord</a> for <em>offset</em> in the join space.  <a href="classAddrSpaceManager.html#ad79ba636cc911bcd83371f00436f1dc5">More...</a><br /></td></tr>
<tr class="separator:ad79ba636cc911bcd83371f00436f1dc5 inherit pro_methods_classAddrSpaceManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manager for all the major decompiler subsystems. </p>
<p>An instantiation is tailored to a specific <a class="el" href="classLoadImage.html" title="An interface into a particular binary executable image.">LoadImage</a>, processor, and compiler spec. This class is the <em>owner</em> of the <a class="el" href="classLoadImage.html" title="An interface into a particular binary executable image.">LoadImage</a>, <a class="el" href="classTranslate.html" title="The interface to a translation engine for a processor.">Translate</a>, symbols (<a class="el" href="classDatabase.html" title="A manager for symbol scopes for a whole executable.">Database</a>), <a class="el" href="classPrintLanguage.html" title="The base class API for emitting a high-level language.">PrintLanguage</a>, etc. This class also holds numerous configuration parameters for the analysis process </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aea7049f03a24618ef02d876b0659f67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7049f03a24618ef02d876b0659f67d">&#9670;&nbsp;</a></span>Architecture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Architecture::Architecture </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an uninitialized <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a>. </p>
<p>Set most sub-components to null pointers. Provide reasonable defaults for the configurable options </p>

<p class="reference">References <a class="el" href="classArchitecture.html#a51c3648c6133efc1d5115b86dd10115a">aggressive_ext_trim</a>, <a class="el" href="classArchitecture.html#a6eb5b3b31fe283d2a030246872bc4855">alias_block_level</a>, <a class="el" href="classPrintLanguageCapability.html#a50e2abb3f0b4cf3ab67556f77eacc51e">PrintLanguageCapability::buildLanguage()</a>, <a class="el" href="classArchitecture.html#a5425576df9b7ce15b6ddddbf17b03df6">commentdb</a>, <a class="el" href="classArchitecture.html#abbbd3d4cf806f7ca3a2a2943aab28165">context</a>, <a class="el" href="classArchitecture.html#adeb5761c98d8af556fb59753d68dfd97">cpool</a>, <a class="el" href="classArchitecture.html#a1e0f5d45f6dcd494b15bb55f81f656b2">defaultfp</a>, <a class="el" href="classArchitecture.html#ad0b5e0d6c22247d4ec2422c81ddec8f8">defaultReturnAddr</a>, <a class="el" href="classArchitecture.html#a44c624320bcc9d52dcecdf553f3b4796">evalfp_called</a>, <a class="el" href="classArchitecture.html#a9fb08ee0ed38a4c586a99d0f45a3af6e">evalfp_current</a>, <a class="el" href="classArchitecture.html#a4ed18744b8dc08d3ca81d6b1b6df682e">flowoptions</a>, <a class="el" href="classArchitecture.html#af1b94f4312717f6cd89eb784e3e73611">funcptr_align</a>, <a class="el" href="classPrintLanguageCapability.html#a2902f4f1ca2e24f215dcd431dbedc310">PrintLanguageCapability::getDefault()</a>, <a class="el" href="classArchitecture.html#adbeb3c604a337ce88bd4e9d8beb78806">infer_pointers</a>, <a class="el" href="classArchitecture.html#a344b1348ed8f0bbe0d050e7038bb290d">loader</a>, <a class="el" href="classArchitecture.html#aff44e0cd6303a22689d6601fc5418918">loadersymbols_parsed</a>, <a class="el" href="classArchitecture.html#a37de4bf5cb39955f32a24074e768a591">max_basetype_size</a>, <a class="el" href="classArchitecture.html#a6c32c1c7e592435d70f41145d5c548f1">max_implied_ref</a>, <a class="el" href="classArchitecture.html#a99db0ca5ac8e5c9edfa7515f97b2ab5a">max_term_duplication</a>, <a class="el" href="classArchitecture.html#aa5c79b6eca1b3c98884bb53c90bf417d">min_funcsymbol_size</a>, <a class="el" href="classArchitecture.html#ab581a0109bda8e9206bb155a80a3a694">options</a>, <a class="el" href="classArchitecture.html#a7d04d77ca75b9e75caa3750c156d9bbf">pcodeinjectlib</a>, <a class="el" href="classArchitecture.html#af72890bc88edf8d6074e24d92fd31c57">print</a>, <a class="el" href="classArchitecture.html#a118dbf145a9f2b6cae5d48b40f00e4d8">printlist</a>, <a class="el" href="classArchitecture.html#a64c49555bfdee44b82f3a9a98005ed0d">readonlypropagate</a>, <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>, <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">symboltab</a>, <a class="el" href="classArchitecture.html#a81f2db17fdc609a7d1cedbc0a2eb7753">translate</a>, <a class="el" href="classArchitecture.html#adbb294ba6c3bb21f691e0208c1ac53a1">trim_recurse_max</a>, and <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">types</a>.</p>

</div>
</div>
<a id="aaef3c8d834e7f5c22db0cf15eefc7e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef3c8d834e7f5c22db0cf15eefc7e45">&#9670;&nbsp;</a></span>~Architecture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Architecture::~Architecture </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Release resources for all sub-components. </p>

<p class="reference">References <a class="el" href="classArchitecture.html#a5425576df9b7ce15b6ddddbf17b03df6">commentdb</a>, <a class="el" href="classArchitecture.html#abbbd3d4cf806f7ca3a2a2943aab28165">context</a>, <a class="el" href="classArchitecture.html#adeb5761c98d8af556fb59753d68dfd97">cpool</a>, <a class="el" href="classArchitecture.html#a6218d36328733cd9798ad6c3dbe921d8">extra_pool_rules</a>, <a class="el" href="classArchitecture.html#a3a9badb712693d9abec7e21abc20fde1">inst</a>, <a class="el" href="classArchitecture.html#a344b1348ed8f0bbe0d050e7038bb290d">loader</a>, <a class="el" href="classArchitecture.html#ab581a0109bda8e9206bb155a80a3a694">options</a>, <a class="el" href="classArchitecture.html#a7d04d77ca75b9e75caa3750c156d9bbf">pcodeinjectlib</a>, <a class="el" href="classArchitecture.html#a118dbf145a9f2b6cae5d48b40f00e4d8">printlist</a>, <a class="el" href="classArchitecture.html#ab15c8b7bbcb9408075014902da4f8687">protoModels</a>, <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">symboltab</a>, <a class="el" href="classArchitecture.html#a81f2db17fdc609a7d1cedbc0a2eb7753">translate</a>, and <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">types</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a70efc8f5d9e212d039dccbfe8556f05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70efc8f5d9e212d039dccbfe8556f05d">&#9670;&nbsp;</a></span>addNoHighPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::addNoHighPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>rng</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new region where pointers do not exist. </p>
<p>This routine is used by the initialization process to add address ranges to which there is never an (indirect) pointer Should only be called during initialization </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>is the new range with no aliases to be added </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classRangeList.html#ab0ab4e29f9f3b6b096e985d99daac763">RangeList::insertRange()</a>, and <a class="el" href="classArchitecture.html#a693da460aeb788e4fbaf3361bd07756a">nohighptr</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a6f51fadb288b36927fa9dfda725ffd88">parseNoHighPtr()</a>.</p>

</div>
</div>
<a id="a3bbc62dedbb13b6fdb2969e1e83446d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbc62dedbb13b6fdb2969e1e83446d5">&#9670;&nbsp;</a></span>addSpacebase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::addSpacebase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>basespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td>
          <td class="paramname"><em>ptrdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>truncSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isreversejustified</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stackGrowth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new space and associated pointer. </p>
<p>This process sets up a "register relative" space for this architecture If the name is "stack", this space takes on the role of an "official" stack space Should only be called once during initialization </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basespace</td><td>is the address space underlying the stack </td></tr>
    <tr><td class="paramname">nm</td><td>is the name of the new space </td></tr>
    <tr><td class="paramname">ptrdata</td><td>is the register location acting as a pointer into the new space </td></tr>
    <tr><td class="paramname">truncSize</td><td>is the (possibly truncated) size of the register that fits the space </td></tr>
    <tr><td class="paramname">isreversejustified</td><td>is <b>true</b> if small variables are justified opposite of endianness </td></tr>
    <tr><td class="paramname">stackGrowth</td><td>is <b>true</b> if a stack implemented in this space grows in the negative direction </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classAddrSpaceManager.html#a6dd0ab3084fd8bb9cb4ea5a84885704d">AddrSpaceManager::addSpacebasePointer()</a>, <a class="el" href="classAddrSpace.html#a63b510a07fd8450dc432d7e671f79f66">AddrSpace::getDelay()</a>, <a class="el" href="classAddrSpaceManager.html#a89658bd677414a271a918f0f37af0bd6">AddrSpaceManager::insertSpace()</a>, <a class="el" href="classAddrSpaceManager.html#ae2d22102a7ce6080918e82daafabbdfa">AddrSpaceManager::numSpaces()</a>, <a class="el" href="classAddrSpaceManager.html#abdab85595c68e18ab86dd42af914f35b">AddrSpaceManager::setReverseJustified()</a>, <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>, and <a class="el" href="classArchitecture.html#a81f2db17fdc609a7d1cedbc0a2eb7753">translate</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#adf3b1aecaff0ca84c647ddbe6e25de5c">parseSpacebase()</a>, and <a class="el" href="classArchitecture.html#aac48da0d464ff216982db607b43d4757">parseStackPointer()</a>.</p>

</div>
</div>
<a id="ad646d95818d9c3615da8a259732546b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad646d95818d9c3615da8a259732546b8">&#9670;&nbsp;</a></span>buildAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::buildAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the <a class="el" href="classAction.html" title="Large scale transformations applied to the varnode/op graph.">Action</a> framework. </p>
<p>This builds the <em>universal</em> <a class="el" href="classAction.html" title="Large scale transformations applied to the varnode/op graph.">Action</a> for function transformation and instantiates the "decompile" root <a class="el" href="classAction.html" title="Large scale transformations applied to the varnode/op graph.">Action</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>may hold configuration information </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#a4cbe1c5d170cb2a4d359765b97fef26f">allacts</a>, <a class="el" href="classArchitecture.html#a568ff11996bb679327d3d83dbb50d454">parseExtraRules()</a>, <a class="el" href="classActionDatabase.html#a19e09431e4e66936090715ab8afe774b">ActionDatabase::setCurrent()</a>, and <a class="el" href="coreaction_8hh.html#a122798abac4d42f44020ef5d71d689e3">universal_action()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#aed18df408eb73d0735966c68b44e413b">restoreFromSpec()</a>.</p>

</div>
</div>
<a id="a517bf0e0ba766b241edf122422766249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517bf0e0ba766b241edf122422766249">&#9670;&nbsp;</a></span>buildCommentDB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::buildCommentDB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the comment database. </p>
<p>Build the container that holds comments for executable in this <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>may hold configuration information </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classArchitectureGhidra.html#aa7ca74344c368e3cb8d340f0c921f8c8">ArchitectureGhidra</a>.</p>

<p class="reference">References <a class="el" href="classArchitecture.html#a5425576df9b7ce15b6ddddbf17b03df6">commentdb</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#abcf0d020ebe4248b9b35f3a51b78363b">init()</a>.</p>

</div>
</div>
<a id="aed8aa1186293e453601bedb0db3d4ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8aa1186293e453601bedb0db3d4ec1">&#9670;&nbsp;</a></span>buildConstantPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::buildConstantPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the constant pool. </p>
<p>Some processor models (Java byte-code) need a database of constants. The database is always built, but may remain empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>may hold configuration information </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classArchitectureGhidra.html#a7b107b393dc04717081c1a73b53c0f8e">ArchitectureGhidra</a>.</p>

<p class="reference">References <a class="el" href="classArchitecture.html#adeb5761c98d8af556fb59753d68dfd97">cpool</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#abcf0d020ebe4248b9b35f3a51b78363b">init()</a>.</p>

</div>
</div>
<a id="a9a2fd38d4d08155637ebee1e043fd9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2fd38d4d08155637ebee1e043fd9a8">&#9670;&nbsp;</a></span>buildContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::buildContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the Context database. </p>
<p>This builds the database which holds the status registers setings and other information that can affect disassembly depending on context. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>may hold configuration information </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classArchitectureGhidra.html#a562a2651d3321d9252ed64bbdaebb6b2">ArchitectureGhidra</a>.</p>

<p class="reference">References <a class="el" href="classArchitecture.html#abbbd3d4cf806f7ca3a2a2943aab28165">context</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#abcf0d020ebe4248b9b35f3a51b78363b">init()</a>.</p>

</div>
</div>
<a id="afa2d6a96b669efefe4b89915aa8a65f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2d6a96b669efefe4b89915aa8a65f7">&#9670;&nbsp;</a></span>buildGlobalScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classScope.html">Scope</a> * Architecture::buildGlobalScope </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the global scope for this executable. </p>
<p>If it does not already exist create the glocal <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> object </p><dl class="section return"><dt>Returns</dt><dd>the global <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> object </dd></dl>

<p>Reimplemented in <a class="el" href="classArchitectureGhidra.html#a7ccad967788698b7313e4603b81e4c4c">ArchitectureGhidra</a>.</p>

<p class="reference">References <a class="el" href="classDatabase.html#a1bc096166a8cfde3d77229c9e38bfabf">Database::attachScope()</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">symboltab</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#af0c6730574d3dc658db221b50831d416">addOtherSpace()</a>, <a class="el" href="classArchitecture.html#a726878f225eebebb51d4e618f4d53631">globalify()</a>, and <a class="el" href="classArchitecture.html#a6348f797097deb07776eca437458ecc8">parseGlobal()</a>.</p>

</div>
</div>
<a id="aa059c551a53018c8d70a1c2f9fc6ed73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa059c551a53018c8d70a1c2f9fc6ed73">&#9670;&nbsp;</a></span>buildInstructions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::buildInstructions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register the p-code operations. </p>
<p>This registers the <a class="el" href="classOpBehavior.html" title="Class encapsulating the action/behavior of specific pcode opcodes.">OpBehavior</a> objects for all known p-code OpCodes. The <a class="el" href="classTranslate.html" title="The interface to a translation engine for a processor.">Translate</a> and <a class="el" href="classTypeFactory.html" title="Container class for all Datatype objects in an Architecture.">TypeFactory</a> object should already be built. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>may hold configuration information </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#a3a9badb712693d9abec7e21abc20fde1">inst</a>, <a class="el" href="classTypeOp.html#a1a6335312cb599605f7cddb617ab113d">TypeOp::registerInstructions()</a>, <a class="el" href="classArchitecture.html#a81f2db17fdc609a7d1cedbc0a2eb7753">translate</a>, and <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">types</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#abcf0d020ebe4248b9b35f3a51b78363b">init()</a>.</p>

</div>
</div>
<a id="a9a19e1f07ba0449dfb21d3388b0dbc33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a19e1f07ba0449dfb21d3388b0dbc33">&#9670;&nbsp;</a></span>buildLoader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Architecture::buildLoader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the <a class="el" href="classLoadImage.html" title="An interface into a particular binary executable image.">LoadImage</a> object and load the executable image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>may hold configuration information </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classArchitectureGhidra.html#a2d7a56feede670d8794638fe969e1bc5">ArchitectureGhidra</a>, <a class="el" href="classBfdArchitecture.html#a6dd10c3cdc8bab4b44d651641ef77509">BfdArchitecture</a>, <a class="el" href="classRawBinaryArchitecture.html#acfbd3128339a19126154e4543510fd88">RawBinaryArchitecture</a>, and <a class="el" href="classXmlArchitecture.html#a88c2088a72021170c101ce71eec791a0">XmlArchitecture</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#abcf0d020ebe4248b9b35f3a51b78363b">init()</a>.</p>

</div>
</div>
<a id="a7dae4f59e2c196a623b45e68cacc1a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dae4f59e2c196a623b45e68cacc1a7a">&#9670;&nbsp;</a></span>buildPcodeInjectLibrary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPcodeInjectLibrary.html">PcodeInjectLibrary</a>* Architecture::buildPcodeInjectLibrary </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the injection library. </p>
<p>This creates the container for p-code injections. It is initially empty. </p><dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classPcodeInjectLibrary.html" title="A collection of p-code injection payloads.">PcodeInjectLibrary</a> object </dd></dl>

<p>Implemented in <a class="el" href="classSleighArchitecture.html#ae0b7773ee748ea290358c389e71f2003">SleighArchitecture</a>, and <a class="el" href="classArchitectureGhidra.html#a0f90d114ddfa9d72f10bcba06c81b3ce">ArchitectureGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#aed18df408eb73d0735966c68b44e413b">restoreFromSpec()</a>.</p>

</div>
</div>
<a id="ad9e8edfa21e63d4b37b8003397804933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e8edfa21e63d4b37b8003397804933">&#9670;&nbsp;</a></span>buildSpecFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Architecture::buildSpecFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load any relevant specification files. </p>
<p>Processor/architecture specific configuration files are loaded into the XML store </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>is the document store that will hold the configuration </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classSleighArchitecture.html#a80e8e72ca0059be816575262b7db395f">SleighArchitecture</a>, and <a class="el" href="classArchitectureGhidra.html#a0317de86fcc2bb436ff4487050b30a9b">ArchitectureGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#abcf0d020ebe4248b9b35f3a51b78363b">init()</a>.</p>

</div>
</div>
<a id="ab951056481cac3e73770db9d567d5212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab951056481cac3e73770db9d567d5212">&#9670;&nbsp;</a></span>buildTranslator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTranslate.html">Translate</a>* Architecture::buildTranslator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the Translator object. </p>
<p>This builds the main disassembly component for the <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a> This does <em>not</em> initially the engine for a specific processor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>may hold configuration information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTranslate.html" title="The interface to a translation engine for a processor.">Translate</a> object </dd></dl>

<p>Implemented in <a class="el" href="classSleighArchitecture.html#aae195ea2828d13b6e15d16c722d14b18">SleighArchitecture</a>, and <a class="el" href="classArchitectureGhidra.html#af37fa553422a8b39bfb1289711c8a6a5">ArchitectureGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#aed18df408eb73d0735966c68b44e413b">restoreFromSpec()</a>.</p>

</div>
</div>
<a id="aaf041374ee649d2c0d8e95e450af5bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf041374ee649d2c0d8e95e450af5bf9">&#9670;&nbsp;</a></span>buildTypegrp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::buildTypegrp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the data-type factory/container. </p>
<p>This builds the <a class="el" href="classTypeFactory.html" title="Container class for all Datatype objects in an Architecture.">TypeFactory</a> object specific to this architecture and prepopulates it with the <em>core</em> types. Core types may be pulled from the configuration information, or default core types are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>contains possible configuration information </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classArchitectureGhidra.html#afdc4a7c905c401909628967b4b249ddc">ArchitectureGhidra</a>.</p>

<p class="reference">References <a class="el" href="classTypeFactory.html#a16ccfeecd29c1d5d40ada6b1d4032212">TypeFactory::cacheCoreTypes()</a>, <a class="el" href="classDocumentStorage.html#a10fdfff18994e73daacdb63b4df7f863">DocumentStorage::getTag()</a>, <a class="el" href="classTypeFactory.html#a24c7308dab804e4f89fd567500b97d63">TypeFactory::restoreXmlCoreTypes()</a>, <a class="el" href="classTypeFactory.html#a7f142a54450d41bc12ca18fe06c6e1e0">TypeFactory::setCoreType()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa3e0f738756c5205d71c69d955603f46c">TYPE_BOOL</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa88922d1c65a64d2f39ebaba3411aa057">TYPE_CODE</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa19a0a402d33a2e049e91ea9e37e90c2f">TYPE_FLOAT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa4fcd4421533bb21c827865bdbac4fef9">TYPE_INT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61faba807ad7d41a3ac08fd4a71e9e013192">TYPE_UINT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa84de340fe64164ed0dcf473aad846961">TYPE_VOID</a>, and <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">types</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#abcf0d020ebe4248b9b35f3a51b78363b">init()</a>.</p>

</div>
</div>
<a id="aa4b9348b5c4279321a8f9014541e5194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b9348b5c4279321a8f9014541e5194">&#9670;&nbsp;</a></span>cacheAddrSpaceProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::cacheAddrSpaceProperties </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate some frequently used space properties and cache them. </p>
<p>Determine the minimum pointer size for the space and whether or not there are near pointers. Set up an ordered list of inferable spaces (where constant pointers can be infered). Inferable spaces include the default space and anything explicitly listed in the cspec &lt;global&gt; tag that is not a register space. An initial list of potential spaces is passed in that needs to be ordered, filtered, and deduplicated. </p>

<p class="reference">References <a class="el" href="classAddrSpace.html#aee2e93b0348411a63144f566c684764d">AddrSpace::compareByIndex()</a>, <a class="el" href="classAddrSpaceManager.html#ad7113aad36405ce0cd8dab5eadfbb1b1">AddrSpaceManager::getDefaultCodeSpace()</a>, <a class="el" href="classAddrSpaceManager.html#ab2aeddbc1955a52c5cfd8c969fc1d9d1">AddrSpaceManager::getDefaultDataSpace()</a>, <a class="el" href="classAddrSpace.html#a63b510a07fd8450dc432d7e671f79f66">AddrSpace::getDelay()</a>, <a class="el" href="classArchitecture.html#a8588f5fecba2f618ce640ef57b31f10a">getSegmentOp()</a>, <a class="el" href="classAddrSpace.html#ab548f4158529a29122d4d0a30d94ed98">AddrSpace::getType()</a>, <a class="el" href="classArchitecture.html#a60a3bfa09d16108be8995658502f93a4">inferPtrSpaces</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classAddrSpace.html#a8b6b90c06dda0ff2b05d77e9779935e7">AddrSpace::isOtherSpace()</a>, <a class="el" href="classAddrSpace.html#ad81b44bbbe7c6b561a7985aa23f3bd0d">AddrSpace::isOverlay()</a>, and <a class="el" href="classAddrSpaceManager.html#aba1c818ccc3950c188e06df08746725f">AddrSpaceManager::markNearPointers()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a0174d51a9975df9be6a6e603d65b1c6c">postSpecFile()</a>.</p>

</div>
</div>
<a id="a5cb912926505aad414d6054071a9e8d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb912926505aad414d6054071a9e8d8">&#9670;&nbsp;</a></span>clearAnalysis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::clearAnalysis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear analysis specific to a function. </p>
<p>Throw out the syntax tree, (unlocked) symbols, comments, and other derived information about a single function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>is the function to clear </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classFuncdata.html#a25b616d10d9514eda69dd9d974c62eb8">Funcdata::clear()</a>, <a class="el" href="classCommentDatabase.html#af4467b35ea8555ddc77e810453051a96">CommentDatabase::clearType()</a>, <a class="el" href="classArchitecture.html#a5425576df9b7ce15b6ddddbf17b03df6">commentdb</a>, <a class="el" href="classComment.html#a25e5457bf3deeb109bdef2f532317cf2a2166c8f68c37806afa4c67052b04b51e">Comment::warning</a>, and <a class="el" href="classComment.html#a25e5457bf3deeb109bdef2f532317cf2a22b7847860fc380835ca045cc01af9ee">Comment::warningheader</a>.</p>

</div>
</div>
<a id="a5499f02b08260cd95354143546fd374b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5499f02b08260cd95354143546fd374b">&#9670;&nbsp;</a></span>collectBehaviors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::collectBehaviors </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classOpBehavior.html">OpBehavior</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>behave</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide a list of <a class="el" href="classOpBehavior.html" title="Class encapsulating the action/behavior of specific pcode opcodes.">OpBehavior</a> objects. </p>
<p>For all registered p-code opcodes, return the corresponding <a class="el" href="classOpBehavior.html" title="Class encapsulating the action/behavior of specific pcode opcodes.">OpBehavior</a> object. The object pointers are provided in a list indexed by OpCode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behave</td><td>is the list to be populated </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#a3a9badb712693d9abec7e21abc20fde1">inst</a>.</p>

<p class="reference">Referenced by <a class="el" href="classPcodeInjectLibraryGhidra.html#a1195225ccb9918e6ca0b62d9a932b66f">PcodeInjectLibraryGhidra::getBehaviors()</a>.</p>

</div>
</div>
<a id="a74b374a6d9b25a638567c3519ac1796c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b374a6d9b25a638567c3519ac1796c">&#9670;&nbsp;</a></span>fillinReadOnlyFromLoader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::fillinReadOnlyFromLoader </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load info about read-only sections. </p>
<p>The <a class="el" href="classLoadImage.html" title="An interface into a particular binary executable image.">LoadImage</a> may have access information about the executables sections. Query for any read-only ranges and store this information in the property database </p>

<p class="reference">References <a class="el" href="classLoadImage.html#a31dba7f0f819c97e68f868cc623e4054">LoadImage::getReadonly()</a>, <a class="el" href="classArchitecture.html#a344b1348ed8f0bbe0d050e7038bb290d">loader</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca0d7f659884b50f2fa71a3d700a729258">Varnode::readonly</a>, <a class="el" href="classDatabase.html#aca0311269bfa73f5673c998dec92bb95">Database::setPropertyRange()</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">symboltab</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#abcf0d020ebe4248b9b35f3a51b78363b">init()</a>.</p>

</div>
</div>
<a id="ae8ac33eeac5ec397674d1ebd5ac8a199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ac33eeac5ec397674d1ebd5ac8a199">&#9670;&nbsp;</a></span>getLanedRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classLanedRegister.html">LanedRegister</a> * Architecture::getLanedRegister </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <a class="el" href="classLanedRegister.html" title="Describes a (register) storage location and the ways it might be split into lanes.">LanedRegister</a> associated with storage. </p>
<p>Look-up the laned register record associated with a specific storage location. Currently, the record is only associated with the <em>size</em> of the storage, not its address. If there is no associated record, null is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>is the starting address of the storage location </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the storage in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classLanedRegister.html" title="Describes a (register) storage location and the ways it might be split into lanes.">LanedRegister</a> record or null </dd></dl>

<p class="reference">References <a class="el" href="classArchitecture.html#a60119c02b8a8de5e5510364556f194fb">lanerecords</a>.</p>

<p class="reference">Referenced by <a class="el" href="classActionVarnodeProps.html#ac54d0dd2ba2a63df74b2ea2d5d3dcacb">ActionVarnodeProps::markLanedVarnode()</a>.</p>

</div>
</div>
<a id="a86fada44a26502772bf9060d08289fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fada44a26502772bf9060d08289fd3">&#9670;&nbsp;</a></span>getMinimumLanedRegisterSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int4 Architecture::getMinimumLanedRegisterSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the minimum size of a laned register in bytes. </p>
<p>Return a size intended for comparison with a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> size to immediately determine if the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is a potential laned register. If there are no laned registers for the architecture, -1 is returned. </p><dl class="section return"><dt>Returns</dt><dd>the size in bytes of the smallest laned register or -1. </dd></dl>

<p class="reference">References <a class="el" href="classArchitecture.html#a60119c02b8a8de5e5510364556f194fb">lanerecords</a>.</p>

<p class="reference">Referenced by <a class="el" href="classActionVarnodeProps.html#a531c9985eb2e6a5796009bea79a465fe">ActionVarnodeProps::apply()</a>.</p>

</div>
</div>
<a id="a03485a52fdf3b18f004ff4687d159a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03485a52fdf3b18f004ff4687d159a1e">&#9670;&nbsp;</a></span>getModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classProtoModel.html">ProtoModel</a> * Architecture::getModel </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific PrototypeModel. </p>
<p>The <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a> maintains the set of prototype models that can be applied for this particular executable. Retrieve one by name. The model must exist or an exception is thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching model </dd></dl>

<p class="reference">References <a class="el" href="classArchitecture.html#ab15c8b7bbcb9408075014902da4f8687">protoModels</a>.</p>

<p class="reference">Referenced by <a class="el" href="classProtoModelMerged.html#a1c80c617c086b0edacb483f8315d12e9">ProtoModelMerged::restoreXml()</a>, <a class="el" href="classFuncProto.html#a4c4f9da74ee904e6abfa195bd843521e">FuncProto::restoreXml()</a>, and <a class="el" href="classArchitecture.html#afc351278b2e416181b2a7c5b65cc614b">setDefaultModel()</a>.</p>

</div>
</div>
<a id="a8588f5fecba2f618ce640ef57b31f10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8588f5fecba2f618ce640ef57b31f10a">&#9670;&nbsp;</a></span>getSegmentOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSegmentOp.html">SegmentOp</a> * Architecture::getSegmentOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the <em>segment</em> op for the given space if any. </p>
<p>This method searches for a user-defined segment op registered for the given space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the address space to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classSegmentOp.html" title="The segmented address operator.">SegmentOp</a> object or null </dd></dl>

<p class="reference">References <a class="el" href="classAddrSpace.html#abac46fe0121579ac29f2e8e93753183d">AddrSpace::getIndex()</a>, <a class="el" href="classUserOpManage.html#a59f67a150f53117fc159be3e66721640">UserOpManage::getSegmentOp()</a>, and <a class="el" href="classArchitecture.html#abd9c927fbda44de1ab46122f49248003">userops</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#aa4b9348b5c4279321a8f9014541e5194">cacheAddrSpaceProperties()</a>.</p>

</div>
</div>
<a id="a6cef69bf3d546ca1012fcf5c017f7f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cef69bf3d546ca1012fcf5c017f7f3a">&#9670;&nbsp;</a></span>getSpaceBySpacebase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * Architecture::getSpaceBySpacebase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get space associated with a <em>spacebase</em> register. </p>
<p>Get the address space associated with the indicated <em>spacebase</em> register. I.e. if the location of the <em>stack</em> <em>pointer</em> is passed in, this routine would return a pointer to the <b>stack</b> space. An exception is thrown if no corresponding space is found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>is the location of the <em>spacebase</em> register </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the register in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the address space </dd></dl>

<p class="reference">References <a class="el" href="classAddress.html#a208ce07ecf27e5c148d8395913831c2a">Address::getOffset()</a>, <a class="el" href="classAddress.html#a2e1cbf153126eebf5ba92f52c5dbc6a8">Address::getSpace()</a>, <a class="el" href="classAddrSpaceManager.html#ad1a9a620e767ffe8bd929913f882e2a4">AddrSpaceManager::getSpace()</a>, <a class="el" href="classAddrSpace.html#ad6b5eb815514577118d9b998447cc4d0">AddrSpace::getSpacebase()</a>, <a class="el" href="classAddrSpaceManager.html#ae2d22102a7ce6080918e82daafabbdfa">AddrSpaceManager::numSpaces()</a>, <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">VarnodeData::offset</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, and <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRuleLoadVarnode.html#a99f23028201e2d986b87915f4511c0ee">RuleLoadVarnode::correctSpacebase()</a>.</p>

</div>
</div>
<a id="a726878f225eebebb51d4e618f4d53631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726878f225eebebb51d4e618f4d53631">&#9670;&nbsp;</a></span>globalify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::globalify </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark <em>all</em> spaces as global. </p>
<p>Set all IPTR_PROCESSOR and IPTR_SPACEBASE spaces to be global. </p>

<p class="reference">References <a class="el" href="classDatabase.html#a3ad165aa6ec64f417376669625d31c69">Database::addRange()</a>, <a class="el" href="classArchitecture.html#afa2d6a96b669efefe4b89915aa8a65f7">buildGlobalScope()</a>, <a class="el" href="classAddrSpace.html#ab4c316eafd39b4e6c7a8017e01d5a841">AddrSpace::getHighest()</a>, <a class="el" href="classAddrSpaceManager.html#ad1a9a620e767ffe8bd929913f882e2a4">AddrSpaceManager::getSpace()</a>, <a class="el" href="classAddrSpace.html#ab548f4158529a29122d4d0a30d94ed98">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231ac6a759a590195b56c099150c63cdd7b2">IPTR_PROCESSOR</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classAddrSpaceManager.html#ae2d22102a7ce6080918e82daafabbdfa">AddrSpaceManager::numSpaces()</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">symboltab</a>.</p>

</div>
</div>
<a id="a0075f8ca742086c8be493703b3f2f3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0075f8ca742086c8be493703b3f2f3cd">&#9670;&nbsp;</a></span>hasModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Architecture::hasModel </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a> have a specific PrototypeModel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the name of the model </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if this <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a> supports a model with that name </dd></dl>

<p class="reference">References <a class="el" href="classArchitecture.html#ab15c8b7bbcb9408075014902da4f8687">protoModels</a>.</p>

</div>
</div>
<a id="a9ec2e6c18d4b1280dc955ec0ace7d476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec2e6c18d4b1280dc955ec0ace7d476">&#9670;&nbsp;</a></span>highPtrPossible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Architecture::highPtrPossible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are pointers possible to the given location? </p>
<p>The <a class="el" href="classTranslate.html" title="The interface to a translation engine for a processor.">Translate</a> object keeps track of address ranges for which it is effectively impossible to have a pointer into. This is used for pointer aliasing calculations. This routine returns <b>true</b> if it is <em>possible</em> to have pointers into the indicated range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>is the starting address of the range </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the range in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if pointers are possible </dd></dl>

<p class="reference">References <a class="el" href="classAddress.html#a2e1cbf153126eebf5ba92f52c5dbc6a8">Address::getSpace()</a>, <a class="el" href="classAddrSpace.html#ab548f4158529a29122d4d0a30d94ed98">AddrSpace::getType()</a>, <a class="el" href="classRangeList.html#a61b4034c6930b45dd8d365c382c73b86">RangeList::inRange()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a1eef2cfc279c246cc7ea0387d8c0aa66">IPTR_INTERNAL</a>, and <a class="el" href="classArchitecture.html#a693da460aeb788e4fbaf3361bd07756a">nohighptr</a>.</p>

</div>
</div>
<a id="abcf0d020ebe4248b9b35f3a51b78363b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf0d020ebe4248b9b35f3a51b78363b">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the image and configure architecture. </p>
<p>Create the <a class="el" href="classLoadImage.html" title="An interface into a particular binary executable image.">LoadImage</a> and load the executable to be analyzed. Using this and possibly other initialization information, create all the sub-components necessary for a complete <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a> The DocumentStore may hold previously gleaned configuration information and is used to read in other configuration files while initializing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>is the XML document store </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#a517bf0e0ba766b241edf122422766249">buildCommentDB()</a>, <a class="el" href="classArchitecture.html#aed8aa1186293e453601bedb0db3d4ec1">buildConstantPool()</a>, <a class="el" href="classArchitecture.html#a9a2fd38d4d08155637ebee1e043fd9a8">buildContext()</a>, <a class="el" href="classArchitecture.html#aa059c551a53018c8d70a1c2f9fc6ed73">buildInstructions()</a>, <a class="el" href="classArchitecture.html#a9a19e1f07ba0449dfb21d3388b0dbc33">buildLoader()</a>, <a class="el" href="classArchitecture.html#ad9e8edfa21e63d4b37b8003397804933">buildSpecFile()</a>, <a class="el" href="classArchitecture.html#aaf041374ee649d2c0d8e95e450af5bf9">buildTypegrp()</a>, <a class="el" href="classArchitecture.html#a74b374a6d9b25a638567c3519ac1796c">fillinReadOnlyFromLoader()</a>, <a class="el" href="classArchitecture.html#a0174d51a9975df9be6a6e603d65b1c6c">postSpecFile()</a>, <a class="el" href="classArchitecture.html#af72890bc88edf8d6074e24d92fd31c57">print</a>, <a class="el" href="classArchitecture.html#aea7d061dab582340c8e9bb3323abdf4a">resolveArchitecture()</a>, <a class="el" href="classArchitecture.html#aed18df408eb73d0735966c68b44e413b">restoreFromSpec()</a>, and <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">types</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRegisterProgram.html#ae79c022fba3244f9969aa007058f4b53">RegisterProgram::rawAction()</a>, <a class="el" href="classXmlArchitecture.html#aead4d5224e18ab98cd30ca89774b9faa">XmlArchitecture::restoreXml()</a>, <a class="el" href="classRawBinaryArchitecture.html#a381c8c1c048d0c8a17322ef8a17ae6ea">RawBinaryArchitecture::restoreXml()</a>, and <a class="el" href="classBfdArchitecture.html#a577d1f082486f2cd6f134d1ce5eb3989">BfdArchitecture::restoreXml()</a>.</p>

</div>
</div>
<a id="a20fb7a8902a213abbf0c730fa5b6a9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fb7a8902a213abbf0c730fa5b6a9d7">&#9670;&nbsp;</a></span>initializeSegments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::initializeSegments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up segment resolvers. </p>
<p>If any address space supports near pointers and segment operators, setup <a class="el" href="classSegmentedResolver.html" title="A resolver for segmented architectures.">SegmentedResolver</a> objects that can be used to recover full pointers in context. </p>

<p class="reference">References <a class="el" href="classUserOpManage.html#a59f67a150f53117fc159be3e66721640">UserOpManage::getSegmentOp()</a>, <a class="el" href="classAddrSpaceManager.html#a6330481f1f40a24d860c820a5a2b64f5">AddrSpaceManager::insertResolver()</a>, and <a class="el" href="classArchitecture.html#abd9c927fbda44de1ab46122f49248003">userops</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">parseCompilerConfig()</a>.</p>

</div>
</div>
<a id="aec1784d8729ba0f13cd7ea63ee546995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1784d8729ba0f13cd7ea63ee546995">&#9670;&nbsp;</a></span>modifySpaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Architecture::modifySpaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTranslate.html">Translate</a> *&#160;</td>
          <td class="paramname"><em>trans</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify address spaces as required by <b>this</b> <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a>. </p>
<p>If spaces need to be truncated or otherwise changed from processor defaults, this routine performs the modification. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trans</td><td>is the processor disassembly object </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classSleighArchitecture.html#aaf0c0ad5b1160d42fecce0a27ce05674">SleighArchitecture</a>, and <a class="el" href="classArchitectureGhidra.html#af638d5e7691942a0e4bba79bbadf9036">ArchitectureGhidra</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#aed18df408eb73d0735966c68b44e413b">restoreFromSpec()</a>.</p>

</div>
</div>
<a id="a7bd655cd2adbd6538883e1771276604e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd655cd2adbd6538883e1771276604e">&#9670;&nbsp;</a></span>nameFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::nameFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pick a default name for a function. </p>
<p>If no better name is available, this method can be used to generate a function name based on its address </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the address of the function </td></tr>
    <tr><td class="paramname">name</td><td>will hold the constructed name </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classAddress.html#abc8be0370dd8397596c06a5f68bcc8e8">Address::printRaw()</a>.</p>

</div>
</div>
<a id="a8be334560223db2a9742d8097edf2cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be334560223db2a9742d8097edf2cf6">&#9670;&nbsp;</a></span>parseAggressiveTrim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseAggressiveTrim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Designate how to trim extension p-code ops. </p>
<p>Configure based on the &lt;aggressivetrim&gt; tag, how aggressively the decompiler will remove extension operations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#a51c3648c6133efc1d5115b86dd10115a">aggressive_ext_trim</a>, <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>, and <a class="el" href="xml_8hh.html#ac2d01d7c2986f1143b2f6145311d093e">xml_readbool()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">parseCompilerConfig()</a>.</p>

</div>
</div>
<a id="a20147b2a4be785c30ea29cc7d9278b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20147b2a4be785c30ea29cc7d9278b42">&#9670;&nbsp;</a></span>parseCompilerConfig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseCompilerConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply compiler specific configuration. </p>
<p>This looks for the &lt;compiler_spec&gt; tag and sets configuration parameters based on it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>is the document store holding the tag </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#af0c6730574d3dc658db221b50831d416">addOtherSpace()</a>, <a class="el" href="classArchitecture.html#a78260a0e141deda850d56d17e6e728cf">archid</a>, <a class="el" href="classInjectPayload.html#a2f892cddd3a2d0dbc1ef81961a8ddc84ad5a56c387d306b588447302bfc5191bc">InjectPayload::CALLFIXUP_TYPE</a>, <a class="el" href="classArchitecture.html#abbbd3d4cf806f7ca3a2a2943aab28165">context</a>, <a class="el" href="classArchitecture.html#a1e0f5d45f6dcd494b15bb55f81f656b2">defaultfp</a>, <a class="el" href="classDocumentStorage.html#a10fdfff18994e73daacdb63b4df7f863">DocumentStorage::getTag()</a>, <a class="el" href="classArchitecture.html#a20fb7a8902a213abbf0c730fa5b6a9d7">initializeSegments()</a>, <a class="el" href="classArchitecture.html#a8be334560223db2a9742d8097edf2cf6">parseAggressiveTrim()</a>, <a class="el" href="classUserOpManage.html#ad692cedd6253a601e45116ed8dc402bd">UserOpManage::parseCallOtherFixup()</a>, <a class="el" href="classTypeFactory.html#a6e13c732148b6c5f78797d60e1a115f5">TypeFactory::parseDataOrganization()</a>, <a class="el" href="classArchitecture.html#a29ad4de633bc630b03425ab46b31f42b">parseDeadcodeDelay()</a>, <a class="el" href="classArchitecture.html#a1ea36f2638d65351dd00ba06fe0dc00b">parseDefaultProto()</a>, <a class="el" href="classTypeFactory.html#a8d10b37cae4c213ca3a613f454ada676">TypeFactory::parseEnumConfig()</a>, <a class="el" href="classArchitecture.html#a5e10589073ea41018047b8affb10025e">parseFuncPtrAlign()</a>, <a class="el" href="classArchitecture.html#a6348f797097deb07776eca437458ecc8">parseGlobal()</a>, <a class="el" href="classArchitecture.html#a6f51fadb288b36927fa9dfda725ffd88">parseNoHighPtr()</a>, <a class="el" href="classArchitecture.html#a7cbe749d5bcc143838f2590fc08acf26">parsePreferSplit()</a>, <a class="el" href="classArchitecture.html#afb2938da725012462a68a85627a2dc2c">parseProto()</a>, <a class="el" href="classArchitecture.html#a3e32daad5f4744f55c43f8acdd7ee8eb">parseProtoEval()</a>, <a class="el" href="classArchitecture.html#a85374e24548406ae6497021150aa5d2c">parseReadOnly()</a>, <a class="el" href="classArchitecture.html#a24090e497ce6273f83bcb842be816ccb">parseReturnAddress()</a>, <a class="el" href="classUserOpManage.html#ab6ce4b3d4fb3046930b47b1e94c2131d">UserOpManage::parseSegmentOp()</a>, <a class="el" href="classArchitecture.html#adf3b1aecaff0ca84c647ddbe6e25de5c">parseSpacebase()</a>, <a class="el" href="classArchitecture.html#aac48da0d464ff216982db607b43d4757">parseStackPointer()</a>, <a class="el" href="classArchitecture.html#a7d04d77ca75b9e75caa3750c156d9bbf">pcodeinjectlib</a>, <a class="el" href="classArchitecture.html#ab15c8b7bbcb9408075014902da4f8687">protoModels</a>, <a class="el" href="classContextDatabase.html#ab21ed86cbe093ccf2f5a81a7db4a7174">ContextDatabase::restoreFromSpec()</a>, <a class="el" href="classPcodeInjectLibrary.html#a738666065a924346cf552b1d62c84848">PcodeInjectLibrary::restoreXmlInject()</a>, <a class="el" href="classUserOpManage.html#ac1fd9f8f2ee822b082ef0a3b1bcae120">UserOpManage::setDefaults()</a>, <a class="el" href="classTypeFactory.html#afae3189d62867e5358bcbb98e7723b75">TypeFactory::setupSizes()</a>, <a class="el" href="classArchitecture.html#a2ed25d7790e67e8bfaef34c092e5f39b">splitrecords</a>, <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">types</a>, and <a class="el" href="classArchitecture.html#abd9c927fbda44de1ab46122f49248003">userops</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#aed18df408eb73d0735966c68b44e413b">restoreFromSpec()</a>.</p>

</div>
</div>
<a id="a29ad4de633bc630b03425ab46b31f42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ad4de633bc630b03425ab46b31f42b">&#9670;&nbsp;</a></span>parseDeadcodeDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseDeadcodeDelay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply dead-code delay configuration. </p>
<p>Manually alter the dead-code delay for a specific address space, based on a &lt;deadcodedelay&gt; tag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>, <a class="el" href="classAddrSpaceManager.html#a24efffb904ebb1a0a541fa74cafd51fc">AddrSpaceManager::getSpaceByName()</a>, and <a class="el" href="classAddrSpaceManager.html#ae82d08eab20f86a31fe366a9bcd58629">AddrSpaceManager::setDeadcodeDelay()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">parseCompilerConfig()</a>.</p>

</div>
</div>
<a id="a1ea36f2638d65351dd00ba06fe0dc00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea36f2638d65351dd00ba06fe0dc00b">&#9670;&nbsp;</a></span>parseDefaultProto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseDefaultProto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply default prototype model configuration. </p>
<p>There should be exactly one &lt;default_proto&gt; tag that specifies what the default prototype model is. This builds the <a class="el" href="classProtoModel.html" title="A prototype model: a model for passing parameters between functions.">ProtoModel</a> object and sets it as the default. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#a1e0f5d45f6dcd494b15bb55f81f656b2">defaultfp</a>, and <a class="el" href="classArchitecture.html#afb2938da725012462a68a85627a2dc2c">parseProto()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">parseCompilerConfig()</a>.</p>

</div>
</div>
<a id="aef6b370b90db6fbf3a8b8b62740c77ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6b370b90db6fbf3a8b8b62740c77ba">&#9670;&nbsp;</a></span>parseDynamicRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseDynamicRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply details of a dynamic <a class="el" href="classRule.html" title="Class for performing a single transformation on a PcodeOp or Varnode.">Rule</a> object. </p>
<p>Recover information out of a &lt;rule&gt; tag and build the new <a class="el" href="classRule.html" title="Class for performing a single transformation on a PcodeOp or Varnode.">Rule</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#a6218d36328733cd9798ad6c3dbe921d8">extra_pool_rules</a>, and <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a568ff11996bb679327d3d83dbb50d454">parseExtraRules()</a>.</p>

</div>
</div>
<a id="a568ff11996bb679327d3d83dbb50d454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568ff11996bb679327d3d83dbb50d454">&#9670;&nbsp;</a></span>parseExtraRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseExtraRules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply any <a class="el" href="classRule.html" title="Class for performing a single transformation on a PcodeOp or Varnode.">Rule</a> tags. </p>
<p>Look for the &lt;experimental_rules&gt; tag and create any dynamic <a class="el" href="classRule.html" title="Class for performing a single transformation on a PcodeOp or Varnode.">Rule</a> objects it specifies. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>is the document store containing the tag </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classDocumentStorage.html#a10fdfff18994e73daacdb63b4df7f863">DocumentStorage::getTag()</a>, and <a class="el" href="classArchitecture.html#aef6b370b90db6fbf3a8b8b62740c77ba">parseDynamicRule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#ad646d95818d9c3615da8a259732546b8">buildAction()</a>.</p>

</div>
</div>
<a id="a5e10589073ea41018047b8affb10025e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e10589073ea41018047b8affb10025e">&#9670;&nbsp;</a></span>parseFuncPtrAlign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseFuncPtrAlign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply function pointer alignment configuration. </p>
<p>Pull information from a &lt;funcptr&gt; tag. Turn on alignment analysis of function pointers, some architectures have aligned function pointers and encode extra information in the unused bits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#af1b94f4312717f6cd89eb784e3e73611">funcptr_align</a>, and <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">parseCompilerConfig()</a>.</p>

</div>
</div>
<a id="a6348f797097deb07776eca437458ecc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6348f797097deb07776eca437458ecc8">&#9670;&nbsp;</a></span>parseGlobal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseGlobal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply global space configuration. </p>
<p>This handles the &lt;global&gt; tag adding an address space (or part of the space) to the global scope. Varnodes in this region will be assumed to be global variables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classDatabase.html#a3ad165aa6ec64f417376669625d31c69">Database::addRange()</a>, <a class="el" href="classArchitecture.html#afa2d6a96b669efefe4b89915aa8a65f7">buildGlobalScope()</a>, <a class="el" href="classOverlaySpace.html#a3a9afed136f872a975743f173f896689">OverlaySpace::getBaseSpace()</a>, <a class="el" href="classAddrSpaceManager.html#ad1a9a620e767ffe8bd929913f882e2a4">AddrSpaceManager::getSpace()</a>, <a class="el" href="classArchitecture.html#a60a3bfa09d16108be8995658502f93a4">inferPtrSpaces</a>, <a class="el" href="classAddrSpace.html#ad81b44bbbe7c6b561a7985aa23f3bd0d">AddrSpace::isOverlay()</a>, <a class="el" href="classAddrSpaceManager.html#ae2d22102a7ce6080918e82daafabbdfa">AddrSpaceManager::numSpaces()</a>, <a class="el" href="classRange.html#ad88a42471281f5bc6abf1dc1fb79f12b">Range::restoreXml()</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">symboltab</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">parseCompilerConfig()</a>.</p>

</div>
</div>
<a id="a8b2290f8d9cf479d4b49fb26c83ff8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2290f8d9cf479d4b49fb26c83ff8c5">&#9670;&nbsp;</a></span>parseIncidentalCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseIncidentalCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply incidental copy configuration. </p>
<p>Apply information from an &lt;incidentalcopy&gt; tag, which marks a set of addresses as being copied to incidentally. This allows the decompiler to ignore certain side-effects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cae9fccd0da71d0cbf7ba0b169330dccc9">Varnode::incidental_copy</a>, <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">VarnodeData::offset</a>, <a class="el" href="structVarnodeData.html#a20a4c1ccbaa1f2477d036be8be923894">VarnodeData::restoreXml()</a>, <a class="el" href="classDatabase.html#aca0311269bfa73f5673c998dec92bb95">Database::setPropertyRange()</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">symboltab</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a4cd4815cc79c6582840043de2e3e65eb">parseProcessorConfig()</a>.</p>

</div>
</div>
<a id="a59d66be927f6539c287de92687838869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d66be927f6539c287de92687838869">&#9670;&nbsp;</a></span>parseLaneSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseLaneSizes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply lane size configuration. </p>
<p>Look for &lt;register&gt; tags that have a <em>vector_lane_size</em> attribute. Record these so that the decompiler can split large registers into appropriate lane size pieces. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#a60119c02b8a8de5e5510364556f194fb">lanerecords</a>, and <a class="el" href="classLanedRegister.html#aac521602aa1d317bdd521b489fc6e546">LanedRegister::restoreXml()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a4cd4815cc79c6582840043de2e3e65eb">parseProcessorConfig()</a>.</p>

</div>
</div>
<a id="a6f51fadb288b36927fa9dfda725ffd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f51fadb288b36927fa9dfda725ffd88">&#9670;&nbsp;</a></span>parseNoHighPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseNoHighPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply memory alias configuration. </p>
<p>Configure memory based on a &lt;nohighptr&gt; tag. Mark specific address ranges to indicate the decompiler will not encounter pointers (aliases) into the range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#a70efc8f5d9e212d039dccbfe8556f05d">addNoHighPtr()</a>, and <a class="el" href="classRange.html#ad88a42471281f5bc6abf1dc1fb79f12b">Range::restoreXml()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">parseCompilerConfig()</a>.</p>

</div>
</div>
<a id="a7cbe749d5bcc143838f2590fc08acf26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbe749d5bcc143838f2590fc08acf26">&#9670;&nbsp;</a></span>parsePreferSplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parsePreferSplit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Designate registers to be split. </p>
<p>Configure registers based on a &lt;prefersplit&gt; tag. Mark specific varnodes that the decompiler should automatically split when it first sees them. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>, <a class="el" href="structVarnodeData.html#a20a4c1ccbaa1f2477d036be8be923894">VarnodeData::restoreXml()</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, and <a class="el" href="classArchitecture.html#a2ed25d7790e67e8bfaef34c092e5f39b">splitrecords</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">parseCompilerConfig()</a>.</p>

</div>
</div>
<a id="a4cd4815cc79c6582840043de2e3e65eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd4815cc79c6582840043de2e3e65eb">&#9670;&nbsp;</a></span>parseProcessorConfig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseProcessorConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply processor specific configuration. </p>
<p>This looks for the &lt;processor_spec&gt; tag and and sets configuration parameters based on it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>is the document store holding the tag </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#abbbd3d4cf806f7ca3a2a2943aab28165">context</a>, <a class="el" href="classAddrSpace.html#abac46fe0121579ac29f2e8e93753183d">AddrSpace::getIndex()</a>, <a class="el" href="classAddrSpaceManager.html#a24efffb904ebb1a0a541fa74cafd51fc">AddrSpaceManager::getSpaceByName()</a>, <a class="el" href="classDocumentStorage.html#a10fdfff18994e73daacdb63b4df7f863">DocumentStorage::getTag()</a>, <a class="el" href="classArchitecture.html#a8b2290f8d9cf479d4b49fb26c83ff8c5">parseIncidentalCopy()</a>, <a class="el" href="classUserOpManage.html#ad51fcfacc1f75bb23dcad875eda155f9">UserOpManage::parseJumpAssist()</a>, <a class="el" href="classArchitecture.html#a59d66be927f6539c287de92687838869">parseLaneSizes()</a>, <a class="el" href="classUserOpManage.html#ab6ce4b3d4fb3046930b47b1e94c2131d">UserOpManage::parseSegmentOp()</a>, <a class="el" href="classArchitecture.html#a90175b3753d44c818064e08425c57d97">parseVolatile()</a>, <a class="el" href="classContextDatabase.html#ab21ed86cbe093ccf2f5a81a7db4a7174">ContextDatabase::restoreFromSpec()</a>, <a class="el" href="classAddrSpaceManager.html#a5889b07364f07bbc30f79cda62a68d23">AddrSpaceManager::setDefaultDataSpace()</a>, and <a class="el" href="classArchitecture.html#abd9c927fbda44de1ab46122f49248003">userops</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#aed18df408eb73d0735966c68b44e413b">restoreFromSpec()</a>.</p>

</div>
</div>
<a id="afb2938da725012462a68a85627a2dc2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2938da725012462a68a85627a2dc2c">&#9670;&nbsp;</a></span>parseProto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classProtoModel.html">ProtoModel</a> * Architecture::parseProto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a proto-type model from an XML tag. </p>
<p>This handles the &lt;prototype&gt; and &lt;resolveprototype&gt; tags. It builds the <a class="el" href="classProtoModel.html" title="A prototype model: a model for passing parameters between functions.">ProtoModel</a> object based on the tag and makes it available generally to the decompiler. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML tag element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#ab15c8b7bbcb9408075014902da4f8687">protoModels</a>, and <a class="el" href="classProtoModel.html#a8fe30abbc7fe1c709b1b8fe9c81803b8">ProtoModel::restoreXml()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">parseCompilerConfig()</a>, and <a class="el" href="classArchitecture.html#a1ea36f2638d65351dd00ba06fe0dc00b">parseDefaultProto()</a>.</p>

</div>
</div>
<a id="a3e32daad5f4744f55c43f8acdd7ee8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e32daad5f4744f55c43f8acdd7ee8eb">&#9670;&nbsp;</a></span>parseProtoEval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseProtoEval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply prototype evaluation configuration. </p>
<p>This supports the &lt;eval_called_prototype&gt; and &lt;eval_current_prototype&gt; tag. This determines which prototype model to assume when recovering the prototype for a <em>called</em> function and the <em>current</em> function respectively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#a44c624320bcc9d52dcecdf553f3b4796">evalfp_called</a>, <a class="el" href="classArchitecture.html#a9fb08ee0ed38a4c586a99d0f45a3af6e">evalfp_current</a>, <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>, and <a class="el" href="classArchitecture.html#ab15c8b7bbcb9408075014902da4f8687">protoModels</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">parseCompilerConfig()</a>.</p>

</div>
</div>
<a id="a85374e24548406ae6497021150aa5d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85374e24548406ae6497021150aa5d2c">&#9670;&nbsp;</a></span>parseReadOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseReadOnly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply read-only region configuration. </p>
<p>This applies info from a &lt;readonly&gt; tag marking a specific region of the executable as <em>read-only</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca0d7f659884b50f2fa71a3d700a729258">Varnode::readonly</a>, <a class="el" href="classRange.html#ad88a42471281f5bc6abf1dc1fb79f12b">Range::restoreXml()</a>, <a class="el" href="classDatabase.html#aca0311269bfa73f5673c998dec92bb95">Database::setPropertyRange()</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">symboltab</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">parseCompilerConfig()</a>.</p>

</div>
</div>
<a id="a24090e497ce6273f83bcb842be816ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24090e497ce6273f83bcb842be816ccb">&#9670;&nbsp;</a></span>parseReturnAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseReturnAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply return address configuration. </p>
<p>This applies info from &lt;returnaddress&gt; tag and sets the default storage location for the <em>return</em> <em>address</em> of a function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#ad0b5e0d6c22247d4ec2422c81ddec8f8">defaultReturnAddr</a>, <a class="el" href="structVarnodeData.html#a20a4c1ccbaa1f2477d036be8be923894">VarnodeData::restoreXml()</a>, and <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">parseCompilerConfig()</a>.</p>

</div>
</div>
<a id="adf3b1aecaff0ca84c647ddbe6e25de5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3b1aecaff0ca84c647ddbe6e25de5c">&#9670;&nbsp;</a></span>parseSpacebase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseSpacebase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an additional indexed space. </p>
<p>Designate a new index register and create a new address space associated with it, based on a &lt;spacebase&gt; tag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#a3bbc62dedbb13b6fdb2969e1e83446d5">addSpacebase()</a>, <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>, <a class="el" href="classTranslate.html#a3a62c460db4eccc285fa3dd29dd4a29b">Translate::getRegister()</a>, <a class="el" href="classAddrSpaceManager.html#a24efffb904ebb1a0a541fa74cafd51fc">AddrSpaceManager::getSpaceByName()</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, and <a class="el" href="classArchitecture.html#a81f2db17fdc609a7d1cedbc0a2eb7753">translate</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">parseCompilerConfig()</a>.</p>

</div>
</div>
<a id="aac48da0d464ff216982db607b43d4757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac48da0d464ff216982db607b43d4757">&#9670;&nbsp;</a></span>parseStackPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseStackPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply stack pointer configuration. </p>
<p>Create a stack space and a stack-pointer register from this &lt;stackpointer&gt; element </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#a3bbc62dedbb13b6fdb2969e1e83446d5">addSpacebase()</a>, <a class="el" href="classAddrSpace.html#aa4217d683f1de141406d009dc4364874">AddrSpace::getAddrSize()</a>, <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>, <a class="el" href="classTranslate.html#a3a62c460db4eccc285fa3dd29dd4a29b">Translate::getRegister()</a>, <a class="el" href="classAddrSpaceManager.html#a24efffb904ebb1a0a541fa74cafd51fc">AddrSpaceManager::getSpaceByName()</a>, <a class="el" href="classAddrSpace.html#a06ef47bec774e59d14ab721eef35e315">AddrSpace::isTruncated()</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, <a class="el" href="classArchitecture.html#a81f2db17fdc609a7d1cedbc0a2eb7753">translate</a>, and <a class="el" href="xml_8hh.html#ac2d01d7c2986f1143b2f6145311d093e">xml_readbool()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">parseCompilerConfig()</a>.</p>

</div>
</div>
<a id="a90175b3753d44c818064e08425c57d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90175b3753d44c818064e08425c57d97">&#9670;&nbsp;</a></span>parseVolatile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::parseVolatile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply volatile region configuration. </p>
<p>This applies info from a &lt;volatile&gt; tag marking specific regions of the executable as holding <em>volatile</em> memory or registers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classUserOpManage.html#a643a087e70166f5e914673476c9189ba">UserOpManage::parseVolatile()</a>, <a class="el" href="classRange.html#ad88a42471281f5bc6abf1dc1fb79f12b">Range::restoreXml()</a>, <a class="el" href="classDatabase.html#aca0311269bfa73f5673c998dec92bb95">Database::setPropertyRange()</a>, <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">symboltab</a>, <a class="el" href="classArchitecture.html#abd9c927fbda44de1ab46122f49248003">userops</a>, and <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cafd8f85c37b5ee3374d865cafbaf6f7e5">Varnode::volatil</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a4cd4815cc79c6582840043de2e3e65eb">parseProcessorConfig()</a>.</p>

</div>
</div>
<a id="a69348906c7601efa002f1f1365decda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69348906c7601efa002f1f1365decda9">&#9670;&nbsp;</a></span>printMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Architecture::printMessage </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an error message to console. </p>
<p>Write the given message to whatever the registered error stream is </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>is the error message </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classArchitectureGhidra.html#ae7cdac6309428d288bc2317f9997aa4e">ArchitectureGhidra</a>, and <a class="el" href="classSleighArchitecture.html#a70cc8c22ebab95cf41ab21b7d886c08f">SleighArchitecture</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScope.html#a4dcaf595e4437d91af6a243ef0d49640">Scope::addCodeLabel()</a>, <a class="el" href="classScope.html#a8f7f8bc9f073a957d43298394cac0678">Scope::addFunction()</a>, <a class="el" href="classScope.html#a421f1b66be24bd5a20c77761e7a51268">Scope::addMapSym()</a>, <a class="el" href="classAction.html#a04e458190e48fb7aeeb49088b92488bd">Action::issueWarning()</a>, and <a class="el" href="classRule.html#a2def29cb6523ed3a95a16c29456d2170">Rule::issueWarning()</a>.</p>

</div>
</div>
<a id="ac6c95a933f8a42d6d1d46d8663a793a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c95a933f8a42d6d1d46d8663a793a2">&#9670;&nbsp;</a></span>readLoaderSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::readLoaderSymbols </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read any symbols from loader into database. </p>
<p>Symbols do not necessarily need to be available for the decompiler. This routine loads all the <em>load</em> <em>image</em> knows about into the symbol table </p>

<p class="reference">References <a class="el" href="classScope.html#a8f7f8bc9f073a957d43298394cac0678">Scope::addFunction()</a>, <a class="el" href="structLoadImageFunc.html#a928751ffba76427337bb1e7e8e808cb3">LoadImageFunc::address</a>, <a class="el" href="classLoadImage.html#a58c86c5342b7500e317ba98bcbf66753">LoadImage::closeSymbols()</a>, <a class="el" href="classLoadImage.html#af4a887cf44c719c576bb05605a4c5c7e">LoadImage::getNextSymbol()</a>, <a class="el" href="classArchitecture.html#a344b1348ed8f0bbe0d050e7038bb290d">loader</a>, <a class="el" href="classArchitecture.html#aff44e0cd6303a22689d6601fc5418918">loadersymbols_parsed</a>, <a class="el" href="structLoadImageFunc.html#a1f3c54ce75f8f381ea597fa5f127a26c">LoadImageFunc::name</a>, <a class="el" href="classLoadImage.html#a5b17f1d68413ab802966bdc7aa07cc73">LoadImage::openSymbols()</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">symboltab</a>.</p>

</div>
</div>
<a id="a4181297a704049ca50c3fc3d233bc0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4181297a704049ca50c3fc3d233bc0e4">&#9670;&nbsp;</a></span>restoreFlowOverride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::restoreFlowOverride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set flow overrides from XML. </p>
<p>Insert a series of out-of-band flow overrides based on a &lt;flowoverridelist&gt; tag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>, <a class="el" href="classAddress.html#a31fdc8c33088abb3040027d35e7c4026">Address::restoreXml()</a>, <a class="el" href="classOverride.html#a7456d7f93fb0f67cdebb42ac1bca5c46">Override::stringToType()</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">symboltab</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#ab15a398b9f84dd62ad36d1e83895783a">restoreXml()</a>.</p>

</div>
</div>
<a id="aed18df408eb73d0735966c68b44e413b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed18df408eb73d0735966c68b44e413b">&#9670;&nbsp;</a></span>restoreFromSpec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::restoreFromSpec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fully initialize the <a class="el" href="classTranslate.html" title="The interface to a translation engine for a processor.">Translate</a> object. </p>
<p>Once the processor is known, the <a class="el" href="classTranslate.html" title="The interface to a translation engine for a processor.">Translate</a> object can be built and fully initialized. Processor and compiler specific configuration is performed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>will hold parsed configuration information </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#ad646d95818d9c3615da8a259732546b8">buildAction()</a>, <a class="el" href="classArchitecture.html#a7dae4f59e2c196a623b45e68cacc1a7a">buildPcodeInjectLibrary()</a>, <a class="el" href="classArchitecture.html#ab951056481cac3e73770db9d567d5212">buildTranslator()</a>, <a class="el" href="classAddrSpaceManager.html#a45068bcc8331bebc780f00e51bd85250">AddrSpaceManager::copySpaces()</a>, <a class="el" href="classTranslate.html#aeb013fbe5257988ffea2f8147b96620a">Translate::getAlignment()</a>, <a class="el" href="classUserOpManage.html#a3a4220cee8c82eb2a30b527bb952a4d6">UserOpManage::initialize()</a>, <a class="el" href="classTranslate.html#af8e71e9a9477e9a91be400ecca565df5">Translate::initialize()</a>, <a class="el" href="classAddrSpaceManager.html#a89658bd677414a271a918f0f37af0bd6">AddrSpaceManager::insertSpace()</a>, <a class="el" href="classArchitecture.html#aa5c79b6eca1b3c98884bb53c90bf417d">min_funcsymbol_size</a>, <a class="el" href="classArchitecture.html#aec1784d8729ba0f13cd7ea63ee546995">modifySpaces()</a>, <a class="el" href="classAddrSpaceManager.html#ae2d22102a7ce6080918e82daafabbdfa">AddrSpaceManager::numSpaces()</a>, <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">parseCompilerConfig()</a>, <a class="el" href="classArchitecture.html#a4cd4815cc79c6582840043de2e3e65eb">parseProcessorConfig()</a>, <a class="el" href="classArchitecture.html#a7d04d77ca75b9e75caa3750c156d9bbf">pcodeinjectlib</a>, <a class="el" href="classTranslate.html#af3405dfdc80d8742a482193f030601ed">Translate::setDefaultFloatFormats()</a>, <a class="el" href="classArchitecture.html#a81f2db17fdc609a7d1cedbc0a2eb7753">translate</a>, and <a class="el" href="classArchitecture.html#abd9c927fbda44de1ab46122f49248003">userops</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#abcf0d020ebe4248b9b35f3a51b78363b">init()</a>.</p>

</div>
</div>
<a id="ab15a398b9f84dd62ad36d1e83895783a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15a398b9f84dd62ad36d1e83895783a">&#9670;&nbsp;</a></span>restoreXml()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::restoreXml </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDocumentStorage.html">DocumentStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore the <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a> state from an XML stream. </p>
<p>Read in all the sub-component state from a &lt;save_state&gt; XML tag When adding stuff to this BEWARE: The spec file has already initialized stuff </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>is document store containing the parsed root tag </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classBfdArchitecture.html#a577d1f082486f2cd6f134d1ce5eb3989">BfdArchitecture</a>, <a class="el" href="classRawBinaryArchitecture.html#a381c8c1c048d0c8a17322ef8a17ae6ea">RawBinaryArchitecture</a>, and <a class="el" href="classXmlArchitecture.html#aead4d5224e18ab98cd30ca89774b9faa">XmlArchitecture</a>.</p>

<p class="reference">References <a class="el" href="classArchitecture.html#a5425576df9b7ce15b6ddddbf17b03df6">commentdb</a>, <a class="el" href="classArchitecture.html#abbbd3d4cf806f7ca3a2a2943aab28165">context</a>, <a class="el" href="classArchitecture.html#adeb5761c98d8af556fb59753d68dfd97">cpool</a>, <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>, <a class="el" href="classDocumentStorage.html#a10fdfff18994e73daacdb63b4df7f863">DocumentStorage::getTag()</a>, <a class="el" href="classArchitecture.html#aff44e0cd6303a22689d6601fc5418918">loadersymbols_parsed</a>, <a class="el" href="classArchitecture.html#ab581a0109bda8e9206bb155a80a3a694">options</a>, <a class="el" href="classArchitecture.html#a7d04d77ca75b9e75caa3750c156d9bbf">pcodeinjectlib</a>, <a class="el" href="classPcodeInjectLibrary.html#a48cebdddd48a1fa5db300d80ed6bdaa2">PcodeInjectLibrary::restoreDebug()</a>, <a class="el" href="classArchitecture.html#a4181297a704049ca50c3fc3d233bc0e4">restoreFlowOverride()</a>, <a class="el" href="classOptionDatabase.html#afe0ea0f1c7a7cd2591ac159027082149">OptionDatabase::restoreXml()</a>, <a class="el" href="classCommentDatabase.html#a21e8b98e7f4276e239f6b2ea59191ded">CommentDatabase::restoreXml()</a>, <a class="el" href="classConstantPool.html#a1ba24a59e40a1110cdd5d2a63f1a978c">ConstantPool::restoreXml()</a>, <a class="el" href="classContextDatabase.html#a779b5bcb5326d79e748a3dc9df0137d0">ContextDatabase::restoreXml()</a>, <a class="el" href="classTypeFactory.html#af9a16d80bfd84732a8dca11ed4a23fab">TypeFactory::restoreXml()</a>, <a class="el" href="classDatabase.html#ad216578696aaa7c956be9cfe752edf57">Database::restoreXml()</a>, <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">symboltab</a>, <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">types</a>, and <a class="el" href="xml_8hh.html#ac2d01d7c2986f1143b2f6145311d093e">xml_readbool()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classXmlArchitecture.html#aead4d5224e18ab98cd30ca89774b9faa">XmlArchitecture::restoreXml()</a>, <a class="el" href="classRawBinaryArchitecture.html#a381c8c1c048d0c8a17322ef8a17ae6ea">RawBinaryArchitecture::restoreXml()</a>, and <a class="el" href="classBfdArchitecture.html#a577d1f082486f2cd6f134d1ce5eb3989">BfdArchitecture::restoreXml()</a>.</p>

</div>
</div>
<a id="af760a127622d4cdd4b6b436122478cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af760a127622d4cdd4b6b436122478cb5">&#9670;&nbsp;</a></span>saveXml()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::saveXml </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize this architecture to XML. </p>
<p>Write the current state of all types, symbols, functions, etc. an XML stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classBfdArchitecture.html#ac775d8894dd3abba1effafe22881a131">BfdArchitecture</a>, <a class="el" href="classRawBinaryArchitecture.html#a3aafb658662f5d6af564e22f5b35aafc">RawBinaryArchitecture</a>, and <a class="el" href="classXmlArchitecture.html#abf5dd16b5343f89d2b165cf2206c7bf6">XmlArchitecture</a>.</p>

<p class="reference">References <a class="el" href="xml_8hh.html#a87634423f394bc832a51957ee6fc85c9">a_v_b()</a>, <a class="el" href="classArchitecture.html#a5425576df9b7ce15b6ddddbf17b03df6">commentdb</a>, <a class="el" href="classArchitecture.html#abbbd3d4cf806f7ca3a2a2943aab28165">context</a>, <a class="el" href="classArchitecture.html#adeb5761c98d8af556fb59753d68dfd97">cpool</a>, <a class="el" href="classConstantPool.html#a22bef84ddc137d871c05a55c5757a3e1">ConstantPool::empty()</a>, <a class="el" href="classArchitecture.html#aff44e0cd6303a22689d6601fc5418918">loadersymbols_parsed</a>, <a class="el" href="classCommentDatabase.html#ab80e2cbdabe2e275695c5980b8f8eb9a">CommentDatabase::saveXml()</a>, <a class="el" href="classConstantPool.html#a859daeda0a7969af5462f6484905ab08">ConstantPool::saveXml()</a>, <a class="el" href="classContextDatabase.html#aaf116d099044b04dbcb6d83a079b1836">ContextDatabase::saveXml()</a>, <a class="el" href="classTypeFactory.html#adf9b9838cfe8166a236de6562f6dfcc3">TypeFactory::saveXml()</a>, <a class="el" href="classDatabase.html#ae44b2d77910ea8fd574443e5d7da55e9">Database::saveXml()</a>, <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">symboltab</a>, and <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">types</a>.</p>

<p class="reference">Referenced by <a class="el" href="classXmlArchitecture.html#abf5dd16b5343f89d2b165cf2206c7bf6">XmlArchitecture::saveXml()</a>, <a class="el" href="classRawBinaryArchitecture.html#a3aafb658662f5d6af564e22f5b35aafc">RawBinaryArchitecture::saveXml()</a>, and <a class="el" href="classBfdArchitecture.html#ac775d8894dd3abba1effafe22881a131">BfdArchitecture::saveXml()</a>.</p>

</div>
</div>
<a id="afc351278b2e416181b2a7c5b65cc614b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc351278b2e416181b2a7c5b65cc614b">&#9670;&nbsp;</a></span>setDefaultModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::setDefaultModel </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the default PrototypeModel. </p>
<p>The default model is used whenever an explicit model is not known or can't be determined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the name of the model to set </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classArchitecture.html#a1e0f5d45f6dcd494b15bb55f81f656b2">defaultfp</a>, and <a class="el" href="classArchitecture.html#a03485a52fdf3b18f004ff4687d159a1e">getModel()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classOptionDefaultPrototype.html#af350045f3bd78a0f63b8788fa21ee7f2">OptionDefaultPrototype::apply()</a>.</p>

</div>
</div>
<a id="ae002322a1fd364665099cbe3f98b63a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae002322a1fd364665099cbe3f98b63a6">&#9670;&nbsp;</a></span>setPrintLanguage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::setPrintLanguage </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a particular output language. </p>
<p>The decompiler supports one or more output languages (C, Java). This method does the main work of selecting one of the supported languages. In addition to selecting the main <a class="el" href="classPrintLanguage.html" title="The base class API for emitting a high-level language.">PrintLanguage</a> object, this triggers configuration of the cast strategy and p-code op behaviors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the name of the language </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classPrintLanguage.html#afe7b69e9583dfd99d310d7fbcb447986">PrintLanguage::adjustTypeOperators()</a>, <a class="el" href="classPrintLanguageCapability.html#a50e2abb3f0b4cf3ab67556f77eacc51e">PrintLanguageCapability::buildLanguage()</a>, <a class="el" href="classPrintLanguageCapability.html#a5feea559122bb1d976707540eb4b32ff">PrintLanguageCapability::findCapability()</a>, <a class="el" href="classArchitecture.html#af72890bc88edf8d6074e24d92fd31c57">print</a>, <a class="el" href="classArchitecture.html#a118dbf145a9f2b6cae5d48b40f00e4d8">printlist</a>, <a class="el" href="classPrintLanguage.html#abec94ce8a6a2afb7daa0cc6bd6b222d8">PrintLanguage::setXML()</a>, and <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">types</a>.</p>

<p class="reference">Referenced by <a class="el" href="classOptionSetLanguage.html#add4e5b7ef4cc478556814a4b232969fc">OptionSetLanguage::apply()</a>.</p>

</div>
</div>
<a id="a10d78ec7be0df339288b7b3adc4c38e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d78ec7be0df339288b7b3adc4c38e7">&#9670;&nbsp;</a></span>setPrototype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Architecture::setPrototype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPrototypePieces.html">PrototypePieces</a> &amp;&#160;</td>
          <td class="paramname"><em>pieces</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the prototype for a particular function. </p>
<p>Establish details of the prototype for a given function symbol </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pieces</td><td>holds the raw prototype information and the symbol name </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="structPrototypePieces.html#ac0eadd4acbffa119e16210b39e32623e">PrototypePieces::name</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">symboltab</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="architecture_8hh.html">architecture.hh</a></li>
<li>architecture.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
