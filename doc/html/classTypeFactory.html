<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>decompiler: TypeFactory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classTypeFactory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TypeFactory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Container class for all <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> objects in an <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a>.  
 <a href="classTypeFactory.html#details">More...</a></p>

<p><code>#include &lt;type.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TypeFactory:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classTypeFactory.png" usemap="#TypeFactory_map" alt=""/>
  <map id="TypeFactory_map" name="TypeFactory_map">
<area href="classTypeFactoryGhidra.html" title="An implementation of the TypeFactory interface, query a Ghidra client for data-type information." alt="TypeFactoryGhidra" shape="rect" coords="0,56,122,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a68a14752ee51f674664cce90522fe559"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a68a14752ee51f674664cce90522fe559">TypeFactory</a> (<a class="el" href="classArchitecture.html">Architecture</a> *g)</td></tr>
<tr class="memdesc:a68a14752ee51f674664cce90522fe559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a factory.  <a href="classTypeFactory.html#a68a14752ee51f674664cce90522fe559">More...</a><br /></td></tr>
<tr class="separator:a68a14752ee51f674664cce90522fe559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae3189d62867e5358bcbb98e7723b75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#afae3189d62867e5358bcbb98e7723b75">setupSizes</a> (void)</td></tr>
<tr class="memdesc:afae3189d62867e5358bcbb98e7723b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive some size information from <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a>.  <a href="classTypeFactory.html#afae3189d62867e5358bcbb98e7723b75">More...</a><br /></td></tr>
<tr class="separator:afae3189d62867e5358bcbb98e7723b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8497930bbd88dd89d91536de06a79f3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a8497930bbd88dd89d91536de06a79f3f">clear</a> (void)</td></tr>
<tr class="memdesc:a8497930bbd88dd89d91536de06a79f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear out all types.  <a href="classTypeFactory.html#a8497930bbd88dd89d91536de06a79f3f">More...</a><br /></td></tr>
<tr class="separator:a8497930bbd88dd89d91536de06a79f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4b55a83c2f6dbb6f4f13b5ca930ae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#afa4b55a83c2f6dbb6f4f13b5ca930ae4">clearNoncore</a> (void)</td></tr>
<tr class="memdesc:afa4b55a83c2f6dbb6f4f13b5ca930ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear out non-core types.  <a href="classTypeFactory.html#afa4b55a83c2f6dbb6f4f13b5ca930ae4">More...</a><br /></td></tr>
<tr class="separator:afa4b55a83c2f6dbb6f4f13b5ca930ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d006876061f78e680f8697a335399d5"><td class="memItemLeft" align="right" valign="top"><a id="a2d006876061f78e680f8697a335399d5"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a2d006876061f78e680f8697a335399d5">~TypeFactory</a> (void)</td></tr>
<tr class="memdesc:a2d006876061f78e680f8697a335399d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a2d006876061f78e680f8697a335399d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e139f5b338e423fd2b1beb7d941d30f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a5e139f5b338e423fd2b1beb7d941d30f">findByName</a> (const string &amp;n)</td></tr>
<tr class="memdesc:a5e139f5b338e423fd2b1beb7d941d30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of given name.  <a href="classTypeFactory.html#a5e139f5b338e423fd2b1beb7d941d30f">More...</a><br /></td></tr>
<tr class="separator:a5e139f5b338e423fd2b1beb7d941d30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2c74462f5a832e6233421bb6cb1beb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a6a2c74462f5a832e6233421bb6cb1beb">setName</a> (<a class="el" href="classDatatype.html">Datatype</a> *ct, const string &amp;n)</td></tr>
<tr class="memdesc:a6a2c74462f5a832e6233421bb6cb1beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the given types name.  <a href="classTypeFactory.html#a6a2c74462f5a832e6233421bb6cb1beb">More...</a><br /></td></tr>
<tr class="separator:a6a2c74462f5a832e6233421bb6cb1beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17480d8c1040602a1becb483e6c59652"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a17480d8c1040602a1becb483e6c59652">setFields</a> (vector&lt; <a class="el" href="structTypeField.html">TypeField</a> &gt; &amp;fd, <a class="el" href="classTypeStruct.html">TypeStruct</a> *ot, int4 fixedsize)</td></tr>
<tr class="memdesc:a17480d8c1040602a1becb483e6c59652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set fields on a <a class="el" href="classTypeStruct.html" title="A composite Datatype object: A &quot;structure&quot; with component &quot;fields&quot;.">TypeStruct</a>.  <a href="classTypeFactory.html#a17480d8c1040602a1becb483e6c59652">More...</a><br /></td></tr>
<tr class="separator:a17480d8c1040602a1becb483e6c59652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cf58ac6b927a91b4f794a3347b2822"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a17cf58ac6b927a91b4f794a3347b2822">setEnumValues</a> (const vector&lt; string &gt; &amp;namelist, const vector&lt; uintb &gt; &amp;vallist, const vector&lt; bool &gt; &amp;assignlist, <a class="el" href="classTypeEnum.html">TypeEnum</a> *te)</td></tr>
<tr class="memdesc:a17cf58ac6b927a91b4f794a3347b2822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set named values for an enumeration.  <a href="classTypeFactory.html#a17cf58ac6b927a91b4f794a3347b2822">More...</a><br /></td></tr>
<tr class="separator:a17cf58ac6b927a91b4f794a3347b2822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5f4036abb11e63ca5f79a9eacfc93c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#aea5f4036abb11e63ca5f79a9eacfc93c">restoreXmlType</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:aea5f4036abb11e63ca5f79a9eacfc93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> from XML.  <a href="classTypeFactory.html#aea5f4036abb11e63ca5f79a9eacfc93c">More...</a><br /></td></tr>
<tr class="separator:aea5f4036abb11e63ca5f79a9eacfc93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1dcb82c1c7493b55aae9b339e909c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a1b1dcb82c1c7493b55aae9b339e909c7">restoreXmlTypeWithCodeFlags</a> (const <a class="el" href="classElement.html">Element</a> *el, bool hasThisPtr, bool isConstructor, bool isDestructor)</td></tr>
<tr class="memdesc:a1b1dcb82c1c7493b55aae9b339e909c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore data-type from XML with extra "code" flags.  <a href="classTypeFactory.html#a1b1dcb82c1c7493b55aae9b339e909c7">More...</a><br /></td></tr>
<tr class="separator:a1b1dcb82c1c7493b55aae9b339e909c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7277908ef32101f172633ec00fbecb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeVoid.html">TypeVoid</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#ab7277908ef32101f172633ec00fbecb1">getTypeVoid</a> (void)</td></tr>
<tr class="memdesc:ab7277908ef32101f172633ec00fbecb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "void" data-type.  <a href="classTypeFactory.html#ab7277908ef32101f172633ec00fbecb1">More...</a><br /></td></tr>
<tr class="separator:ab7277908ef32101f172633ec00fbecb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca2937f24e37c5ac19ba442cd1df0d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#adca2937f24e37c5ac19ba442cd1df0d8">getBaseNoChar</a> (int4 s, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a> m)</td></tr>
<tr class="memdesc:adca2937f24e37c5ac19ba442cd1df0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get atomic type excluding "char".  <a href="classTypeFactory.html#adca2937f24e37c5ac19ba442cd1df0d8">More...</a><br /></td></tr>
<tr class="separator:adca2937f24e37c5ac19ba442cd1df0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe1ae26c0b76b18d59d5cd27a9b8ff1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">getBase</a> (int4 s, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a> m)</td></tr>
<tr class="memdesc:a5fe1ae26c0b76b18d59d5cd27a9b8ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get atomic type.  <a href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">More...</a><br /></td></tr>
<tr class="separator:a5fe1ae26c0b76b18d59d5cd27a9b8ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2848b5923834b755de0749d9f96880e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a2848b5923834b755de0749d9f96880e1">getBase</a> (int4 s, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a> m, const string &amp;n)</td></tr>
<tr class="memdesc:a2848b5923834b755de0749d9f96880e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get named atomic type.  <a href="classTypeFactory.html#a2848b5923834b755de0749d9f96880e1">More...</a><br /></td></tr>
<tr class="separator:a2848b5923834b755de0749d9f96880e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c3d70d9598d2b4ce3770593f6ce97e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeCode.html">TypeCode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a47c3d70d9598d2b4ce3770593f6ce97e">getTypeCode</a> (void)</td></tr>
<tr class="memdesc:a47c3d70d9598d2b4ce3770593f6ce97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an "anonymous" function data-type.  <a href="classTypeFactory.html#a47c3d70d9598d2b4ce3770593f6ce97e">More...</a><br /></td></tr>
<tr class="separator:a47c3d70d9598d2b4ce3770593f6ce97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff26aa7e6197ffb865907313f752d43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypePointer.html">TypePointer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a2ff26aa7e6197ffb865907313f752d43">getTypePointer</a> (int4 s, <a class="el" href="classDatatype.html">Datatype</a> *pt, uint4 ws)</td></tr>
<tr class="memdesc:a2ff26aa7e6197ffb865907313f752d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a pointer data-type.  <a href="classTypeFactory.html#a2ff26aa7e6197ffb865907313f752d43">More...</a><br /></td></tr>
<tr class="separator:a2ff26aa7e6197ffb865907313f752d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2295006d8d970d51dc205f5242846d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypePointer.html">TypePointer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a2295006d8d970d51dc205f5242846d54">getTypePointerAbsolute</a> (int4 s, <a class="el" href="classDatatype.html">Datatype</a> *pt, uint4 ws)</td></tr>
<tr class="memdesc:a2295006d8d970d51dc205f5242846d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an absolute pointer data-type.  <a href="classTypeFactory.html#a2295006d8d970d51dc205f5242846d54">More...</a><br /></td></tr>
<tr class="separator:a2295006d8d970d51dc205f5242846d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77988d5cf50fc10fe92dec8e265a720f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypePointer.html">TypePointer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a77988d5cf50fc10fe92dec8e265a720f">getTypePointerNoDepth</a> (int4 s, <a class="el" href="classDatatype.html">Datatype</a> *pt, uint4 ws)</td></tr>
<tr class="memdesc:a77988d5cf50fc10fe92dec8e265a720f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a depth limited pointer data-type.  <a href="classTypeFactory.html#a77988d5cf50fc10fe92dec8e265a720f">More...</a><br /></td></tr>
<tr class="separator:a77988d5cf50fc10fe92dec8e265a720f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1efe412493c66b6072ae0def3b53004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeArray.html">TypeArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#ad1efe412493c66b6072ae0def3b53004">getTypeArray</a> (int4 as, <a class="el" href="classDatatype.html">Datatype</a> *ao)</td></tr>
<tr class="memdesc:ad1efe412493c66b6072ae0def3b53004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array data-type.  <a href="classTypeFactory.html#ad1efe412493c66b6072ae0def3b53004">More...</a><br /></td></tr>
<tr class="separator:ad1efe412493c66b6072ae0def3b53004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4a75179b840571eeb97e24642c55ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeStruct.html">TypeStruct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#aaa4a75179b840571eeb97e24642c55ee">getTypeStruct</a> (const string &amp;n)</td></tr>
<tr class="memdesc:aaa4a75179b840571eeb97e24642c55ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an (empty) structure.  <a href="classTypeFactory.html#aaa4a75179b840571eeb97e24642c55ee">More...</a><br /></td></tr>
<tr class="separator:aaa4a75179b840571eeb97e24642c55ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb1aba15e198a7ba2b67741c571de3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeEnum.html">TypeEnum</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a3bb1aba15e198a7ba2b67741c571de3a">getTypeEnum</a> (const string &amp;n)</td></tr>
<tr class="memdesc:a3bb1aba15e198a7ba2b67741c571de3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an (empty) enumeration.  <a href="classTypeFactory.html#a3bb1aba15e198a7ba2b67741c571de3a">More...</a><br /></td></tr>
<tr class="separator:a3bb1aba15e198a7ba2b67741c571de3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85de9d19ce1dc44476a414f5ce69b97e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeSpacebase.html">TypeSpacebase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a85de9d19ce1dc44476a414f5ce69b97e">getTypeSpacebase</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *id, const <a class="el" href="classAddress.html">Address</a> &amp;addr)</td></tr>
<tr class="memdesc:a85de9d19ce1dc44476a414f5ce69b97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a "spacebase" type.  <a href="classTypeFactory.html#a85de9d19ce1dc44476a414f5ce69b97e">More...</a><br /></td></tr>
<tr class="separator:a85de9d19ce1dc44476a414f5ce69b97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99362bf53b0ead2d57a2221bc2fd03cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeCode.html">TypeCode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a99362bf53b0ead2d57a2221bc2fd03cc">getTypeCode</a> (<a class="el" href="classProtoModel.html">ProtoModel</a> *model, <a class="el" href="classDatatype.html">Datatype</a> *outtype, const vector&lt; <a class="el" href="classDatatype.html">Datatype</a> * &gt; &amp;intypes, bool dotdotdot)</td></tr>
<tr class="memdesc:a99362bf53b0ead2d57a2221bc2fd03cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a "function" datatype.  <a href="classTypeFactory.html#a99362bf53b0ead2d57a2221bc2fd03cc">More...</a><br /></td></tr>
<tr class="separator:a99362bf53b0ead2d57a2221bc2fd03cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4edd4fa31629380ec4124c840022f5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#ab4edd4fa31629380ec4124c840022f5a">destroyType</a> (<a class="el" href="classDatatype.html">Datatype</a> *ct)</td></tr>
<tr class="memdesc:ab4edd4fa31629380ec4124c840022f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a data-type from <b>this</b>.  <a href="classTypeFactory.html#ab4edd4fa31629380ec4124c840022f5a">More...</a><br /></td></tr>
<tr class="separator:ab4edd4fa31629380ec4124c840022f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979852b4d0b186f833d16d4638fe6f08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a979852b4d0b186f833d16d4638fe6f08">downChain</a> (<a class="el" href="classDatatype.html">Datatype</a> *ptrtype, uintb &amp;off)</td></tr>
<tr class="memdesc:a979852b4d0b186f833d16d4638fe6f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a sub-type matching a pointer and offset.  <a href="classTypeFactory.html#a979852b4d0b186f833d16d4638fe6f08">More...</a><br /></td></tr>
<tr class="separator:a979852b4d0b186f833d16d4638fe6f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5c58286d60717b8305f4f26a39c5ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#aab5c58286d60717b8305f4f26a39c5ac">concretize</a> (<a class="el" href="classDatatype.html">Datatype</a> *ct)</td></tr>
<tr class="memdesc:aab5c58286d60717b8305f4f26a39c5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert given data-type to concrete form.  <a href="classTypeFactory.html#aab5c58286d60717b8305f4f26a39c5ac">More...</a><br /></td></tr>
<tr class="separator:aab5c58286d60717b8305f4f26a39c5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab143d57ae08682ff4fbc28a6ace5a54e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#ab143d57ae08682ff4fbc28a6ace5a54e">dependentOrder</a> (vector&lt; <a class="el" href="classDatatype.html">Datatype</a> * &gt; &amp;deporder) const</td></tr>
<tr class="memdesc:ab143d57ae08682ff4fbc28a6ace5a54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place all data-types in dependency order.  <a href="classTypeFactory.html#ab143d57ae08682ff4fbc28a6ace5a54e">More...</a><br /></td></tr>
<tr class="separator:ab143d57ae08682ff4fbc28a6ace5a54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9b9838cfe8166a236de6562f6dfcc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#adf9b9838cfe8166a236de6562f6dfcc3">saveXml</a> (ostream &amp;s) const</td></tr>
<tr class="memdesc:adf9b9838cfe8166a236de6562f6dfcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save <b>this</b> container to stream.  <a href="classTypeFactory.html#adf9b9838cfe8166a236de6562f6dfcc3">More...</a><br /></td></tr>
<tr class="separator:adf9b9838cfe8166a236de6562f6dfcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1caebbe3620eee3ba78427608b1126dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a1caebbe3620eee3ba78427608b1126dd">saveXmlCoreTypes</a> (ostream &amp;s) const</td></tr>
<tr class="memdesc:a1caebbe3620eee3ba78427608b1126dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save core types to stream.  <a href="classTypeFactory.html#a1caebbe3620eee3ba78427608b1126dd">More...</a><br /></td></tr>
<tr class="separator:a1caebbe3620eee3ba78427608b1126dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a16d80bfd84732a8dca11ed4a23fab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#af9a16d80bfd84732a8dca11ed4a23fab">restoreXml</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:af9a16d80bfd84732a8dca11ed4a23fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore <b>this</b> container from a stream.  <a href="classTypeFactory.html#af9a16d80bfd84732a8dca11ed4a23fab">More...</a><br /></td></tr>
<tr class="separator:af9a16d80bfd84732a8dca11ed4a23fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c7308dab804e4f89fd567500b97d63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a24c7308dab804e4f89fd567500b97d63">restoreXmlCoreTypes</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a24c7308dab804e4f89fd567500b97d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize basic type names.  <a href="classTypeFactory.html#a24c7308dab804e4f89fd567500b97d63">More...</a><br /></td></tr>
<tr class="separator:a24c7308dab804e4f89fd567500b97d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e13c732148b6c5f78797d60e1a115f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a6e13c732148b6c5f78797d60e1a115f5">parseDataOrganization</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a6e13c732148b6c5f78797d60e1a115f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the &lt;data_organization&gt; tag.  <a href="classTypeFactory.html#a6e13c732148b6c5f78797d60e1a115f5">More...</a><br /></td></tr>
<tr class="separator:a6e13c732148b6c5f78797d60e1a115f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d10b37cae4c213ca3a613f454ada676"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a8d10b37cae4c213ca3a613f454ada676">parseEnumConfig</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a8d10b37cae4c213ca3a613f454ada676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the &lt;enum&gt; tag.  <a href="classTypeFactory.html#a8d10b37cae4c213ca3a613f454ada676">More...</a><br /></td></tr>
<tr class="separator:a8d10b37cae4c213ca3a613f454ada676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f142a54450d41bc12ca18fe06c6e1e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a7f142a54450d41bc12ca18fe06c6e1e0">setCoreType</a> (const string &amp;name, int4 size, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a> meta, bool chartp)</td></tr>
<tr class="memdesc:a7f142a54450d41bc12ca18fe06c6e1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a core data-type.  <a href="classTypeFactory.html#a7f142a54450d41bc12ca18fe06c6e1e0">More...</a><br /></td></tr>
<tr class="separator:a7f142a54450d41bc12ca18fe06c6e1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ccfeecd29c1d5d40ada6b1d4032212"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a16ccfeecd29c1d5d40ada6b1d4032212">cacheCoreTypes</a> (void)</td></tr>
<tr class="memdesc:a16ccfeecd29c1d5d40ada6b1d4032212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache common types.  <a href="classTypeFactory.html#a16ccfeecd29c1d5d40ada6b1d4032212">More...</a><br /></td></tr>
<tr class="separator:a16ccfeecd29c1d5d40ada6b1d4032212"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab86f43d69c0f879d315ce2aacc1f7326"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#ab86f43d69c0f879d315ce2aacc1f7326">findByIdLocal</a> (const string &amp;nm, uint8 id) const</td></tr>
<tr class="memdesc:ab86f43d69c0f879d315ce2aacc1f7326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search locally by name and id.  <a href="classTypeFactory.html#ab86f43d69c0f879d315ce2aacc1f7326">More...</a><br /></td></tr>
<tr class="separator:ab86f43d69c0f879d315ce2aacc1f7326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cd8d76884043080a3430f3aff8b010"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a79cd8d76884043080a3430f3aff8b010">findById</a> (const string &amp;n, uint8 id)</td></tr>
<tr class="memdesc:a79cd8d76884043080a3430f3aff8b010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search by name and id.  <a href="classTypeFactory.html#a79cd8d76884043080a3430f3aff8b010">More...</a><br /></td></tr>
<tr class="separator:a79cd8d76884043080a3430f3aff8b010"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0652ec9d4b9d9d0943d1fbffe9b9c740"><td class="memItemLeft" align="right" valign="top"><a id="a0652ec9d4b9d9d0943d1fbffe9b9c740"></a>
<a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a0652ec9d4b9d9d0943d1fbffe9b9c740">glb</a></td></tr>
<tr class="memdesc:a0652ec9d4b9d9d0943d1fbffe9b9c740"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a> object that owns this <a class="el" href="classTypeFactory.html" title="Container class for all Datatype objects in an Architecture.">TypeFactory</a>. <br /></td></tr>
<tr class="separator:a0652ec9d4b9d9d0943d1fbffe9b9c740"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afc2ac2061c8ef5121cdd247164a275c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#afc2ac2061c8ef5121cdd247164a275c3">findNoName</a> (<a class="el" href="classDatatype.html">Datatype</a> &amp;ct)</td></tr>
<tr class="memdesc:afc2ac2061c8ef5121cdd247164a275c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find data-type (in this container) by function.  <a href="classTypeFactory.html#afc2ac2061c8ef5121cdd247164a275c3">More...</a><br /></td></tr>
<tr class="separator:afc2ac2061c8ef5121cdd247164a275c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df9fbdeaf67e5f8b4e7b8d02d67cfcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd</a> (<a class="el" href="classDatatype.html">Datatype</a> &amp;ct)</td></tr>
<tr class="memdesc:a8df9fbdeaf67e5f8b4e7b8d02d67cfcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find data-type in this container or add it.  <a href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">More...</a><br /></td></tr>
<tr class="separator:a8df9fbdeaf67e5f8b4e7b8d02d67cfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb600c342fe81efd7feb673ccc6c894"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a3eb600c342fe81efd7feb673ccc6c894">orderRecurse</a> (vector&lt; <a class="el" href="classDatatype.html">Datatype</a> * &gt; &amp;deporder, <a class="el" href="type_8hh.html#a718b9f8902a3f2dcc61b4eb84c58adf2">DatatypeSet</a> &amp;mark, <a class="el" href="classDatatype.html">Datatype</a> *ct) const</td></tr>
<tr class="memdesc:a3eb600c342fe81efd7feb673ccc6c894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out dependency list.  <a href="classTypeFactory.html#a3eb600c342fe81efd7feb673ccc6c894">More...</a><br /></td></tr>
<tr class="separator:a3eb600c342fe81efd7feb673ccc6c894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefbb272df63d0e3bddd0195e52fd308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#adefbb272df63d0e3bddd0195e52fd308">restoreXmlTypeNoRef</a> (const <a class="el" href="classElement.html">Element</a> *el, bool forcecore)</td></tr>
<tr class="memdesc:adefbb272df63d0e3bddd0195e52fd308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore from an XML tag.  <a href="classTypeFactory.html#adefbb272df63d0e3bddd0195e52fd308">More...</a><br /></td></tr>
<tr class="separator:adefbb272df63d0e3bddd0195e52fd308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a52357e69fba6dd4b4adaf4b5279a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a82a52357e69fba6dd4b4adaf4b5279a2">clearCache</a> (void)</td></tr>
<tr class="memdesc:a82a52357e69fba6dd4b4adaf4b5279a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the common type cache.  <a href="classTypeFactory.html#a82a52357e69fba6dd4b4adaf4b5279a2">More...</a><br /></td></tr>
<tr class="separator:a82a52357e69fba6dd4b4adaf4b5279a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a9fd247245e31f9eeeec29d245cfa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeChar.html">TypeChar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#af2a9fd247245e31f9eeeec29d245cfa2">getTypeChar</a> (const string &amp;n)</td></tr>
<tr class="memdesc:af2a9fd247245e31f9eeeec29d245cfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a default "char" type.  <a href="classTypeFactory.html#af2a9fd247245e31f9eeeec29d245cfa2">More...</a><br /></td></tr>
<tr class="separator:af2a9fd247245e31f9eeeec29d245cfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a15ff2da4b9476d4f2e9eeeb012fbc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeUnicode.html">TypeUnicode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a7a15ff2da4b9476d4f2e9eeeb012fbc7">getTypeUnicode</a> (const string &amp;nm, int4 sz, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a> m)</td></tr>
<tr class="memdesc:a7a15ff2da4b9476d4f2e9eeeb012fbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a default "unicode" type.  <a href="classTypeFactory.html#a7a15ff2da4b9476d4f2e9eeeb012fbc7">More...</a><br /></td></tr>
<tr class="separator:a7a15ff2da4b9476d4f2e9eeeb012fbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264037dc13d6d5d5c643bc805c373375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeCode.html">TypeCode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a264037dc13d6d5d5c643bc805c373375">getTypeCode</a> (const string &amp;n)</td></tr>
<tr class="memdesc:a264037dc13d6d5d5c643bc805c373375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a default "code" type.  <a href="classTypeFactory.html#a264037dc13d6d5d5c643bc805c373375">More...</a><br /></td></tr>
<tr class="separator:a264037dc13d6d5d5c643bc805c373375"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a29c926d1ab19f6cd2d5fa7df86eba78e"><td class="memItemLeft" align="right" valign="top"><a id="a29c926d1ab19f6cd2d5fa7df86eba78e"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a29c926d1ab19f6cd2d5fa7df86eba78e">sizeOfInt</a></td></tr>
<tr class="memdesc:a29c926d1ab19f6cd2d5fa7df86eba78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the core "int" datatype. <br /></td></tr>
<tr class="separator:a29c926d1ab19f6cd2d5fa7df86eba78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180f8e14584ec0dba65dfc258f96e7ea"><td class="memItemLeft" align="right" valign="top"><a id="a180f8e14584ec0dba65dfc258f96e7ea"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a180f8e14584ec0dba65dfc258f96e7ea">align</a></td></tr>
<tr class="memdesc:a180f8e14584ec0dba65dfc258f96e7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment of structures. <br /></td></tr>
<tr class="separator:a180f8e14584ec0dba65dfc258f96e7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fe3fddd79a56398f5d9dc7cd537bf3"><td class="memItemLeft" align="right" valign="top"><a id="a47fe3fddd79a56398f5d9dc7cd537bf3"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a47fe3fddd79a56398f5d9dc7cd537bf3">enumsize</a></td></tr>
<tr class="memdesc:a47fe3fddd79a56398f5d9dc7cd537bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of an enumerated type. <br /></td></tr>
<tr class="separator:a47fe3fddd79a56398f5d9dc7cd537bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b53c08b2845563e7b03253e0474559b"><td class="memItemLeft" align="right" valign="top"><a id="a9b53c08b2845563e7b03253e0474559b"></a>
<a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a9b53c08b2845563e7b03253e0474559b">enumtype</a></td></tr>
<tr class="memdesc:a9b53c08b2845563e7b03253e0474559b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default enumeration meta-type (when parsing C) <br /></td></tr>
<tr class="separator:a9b53c08b2845563e7b03253e0474559b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9d31778ed2c9ccc958ba9f52125de2"><td class="memItemLeft" align="right" valign="top"><a id="aed9d31778ed2c9ccc958ba9f52125de2"></a>
<a class="el" href="type_8hh.html#a718b9f8902a3f2dcc61b4eb84c58adf2">DatatypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#aed9d31778ed2c9ccc958ba9f52125de2">tree</a></td></tr>
<tr class="memdesc:aed9d31778ed2c9ccc958ba9f52125de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Datatypes within this factory (sorted by function) <br /></td></tr>
<tr class="separator:aed9d31778ed2c9ccc958ba9f52125de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35525edc1bb4b769c3e9fbe48d8b642b"><td class="memItemLeft" align="right" valign="top"><a id="a35525edc1bb4b769c3e9fbe48d8b642b"></a>
<a class="el" href="type_8hh.html#aa1db0a143363e2b1d1150e3f2168c3ea">DatatypeNameSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a35525edc1bb4b769c3e9fbe48d8b642b">nametree</a></td></tr>
<tr class="memdesc:a35525edc1bb4b769c3e9fbe48d8b642b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-reference by name. <br /></td></tr>
<tr class="separator:a35525edc1bb4b769c3e9fbe48d8b642b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f8367763c472cfe82ebf0c7ef7c6e0"><td class="memItemLeft" align="right" valign="top"><a id="aa5f8367763c472cfe82ebf0c7ef7c6e0"></a>
<a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#aa5f8367763c472cfe82ebf0c7ef7c6e0">typecache</a> [9][8]</td></tr>
<tr class="memdesc:aa5f8367763c472cfe82ebf0c7ef7c6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix of the most common atomic data-types. <br /></td></tr>
<tr class="separator:aa5f8367763c472cfe82ebf0c7ef7c6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2e98189b4baf44aee9f715375ecd4f"><td class="memItemLeft" align="right" valign="top"><a id="a8e2e98189b4baf44aee9f715375ecd4f"></a>
<a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a8e2e98189b4baf44aee9f715375ecd4f">typecache10</a></td></tr>
<tr class="memdesc:a8e2e98189b4baf44aee9f715375ecd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specially cached 10-byte float type. <br /></td></tr>
<tr class="separator:a8e2e98189b4baf44aee9f715375ecd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6071eb27ddaaa93055c521420442a865"><td class="memItemLeft" align="right" valign="top"><a id="a6071eb27ddaaa93055c521420442a865"></a>
<a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a6071eb27ddaaa93055c521420442a865">typecache16</a></td></tr>
<tr class="memdesc:a6071eb27ddaaa93055c521420442a865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specially cached 16-byte float type. <br /></td></tr>
<tr class="separator:a6071eb27ddaaa93055c521420442a865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8366394e6205c501a1e128465566b761"><td class="memItemLeft" align="right" valign="top"><a id="a8366394e6205c501a1e128465566b761"></a>
<a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a8366394e6205c501a1e128465566b761">type_nochar</a></td></tr>
<tr class="memdesc:a8366394e6205c501a1e128465566b761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same dimensions as char but acts and displays as an INT. <br /></td></tr>
<tr class="separator:a8366394e6205c501a1e128465566b761"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Container class for all <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> objects in an <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a68a14752ee51f674664cce90522fe559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a14752ee51f674664cce90522fe559">&#9670;&nbsp;</a></span>TypeFactory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TypeFactory::TypeFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a factory. </p>
<p>Initialize an empty container </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>is the owning <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a16ccfeecd29c1d5d40ada6b1d4032212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ccfeecd29c1d5d40ada6b1d4032212">&#9670;&nbsp;</a></span>cacheCoreTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::cacheCoreTypes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cache common types. </p>
<p>Run through the list of "core" data-types and cache the most commonly accessed ones for quick access (avoiding the tree lookup). The "core" data-types must have been previously initialized. </p>

<p class="reference">References <a class="el" href="classTypeFactory.html#aed9d31778ed2c9ccc958ba9f52125de2">tree</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa3e0f738756c5205d71c69d955603f46c">TYPE_BOOL</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa88922d1c65a64d2f39ebaba3411aa057">TYPE_CODE</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa19a0a402d33a2e049e91ea9e37e90c2f">TYPE_FLOAT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa4fcd4421533bb21c827865bdbac4fef9">TYPE_INT</a>, <a class="el" href="classTypeFactory.html#a8366394e6205c501a1e128465566b761">type_nochar</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61faba807ad7d41a3ac08fd4a71e9e013192">TYPE_UINT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa84de340fe64164ed0dcf473aad846961">TYPE_VOID</a>, <a class="el" href="classTypeFactory.html#aa5f8367763c472cfe82ebf0c7ef7c6e0">typecache</a>, <a class="el" href="classTypeFactory.html#a8e2e98189b4baf44aee9f715375ecd4f">typecache10</a>, and <a class="el" href="classTypeFactory.html#a6071eb27ddaaa93055c521420442a865">typecache16</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitectureGhidra.html#afdc4a7c905c401909628967b4b249ddc">ArchitectureGhidra::buildTypegrp()</a>, <a class="el" href="classArchitecture.html#aaf041374ee649d2c0d8e95e450af5bf9">Architecture::buildTypegrp()</a>, and <a class="el" href="classTypeFactory.html#a24c7308dab804e4f89fd567500b97d63">restoreXmlCoreTypes()</a>.</p>

</div>
</div>
<a id="a8497930bbd88dd89d91536de06a79f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8497930bbd88dd89d91536de06a79f3f">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear out all types. </p>
<p>Remove all <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> objects owned by this <a class="el" href="classTypeFactory.html" title="Container class for all Datatype objects in an Architecture.">TypeFactory</a>. </p>

<p class="reference">References <a class="el" href="classTypeFactory.html#a82a52357e69fba6dd4b4adaf4b5279a2">clearCache()</a>, <a class="el" href="classTypeFactory.html#a35525edc1bb4b769c3e9fbe48d8b642b">nametree</a>, and <a class="el" href="classTypeFactory.html#aed9d31778ed2c9ccc958ba9f52125de2">tree</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTypeFactory.html#a24c7308dab804e4f89fd567500b97d63">restoreXmlCoreTypes()</a>, and <a class="el" href="classTypeFactory.html#a2d006876061f78e680f8697a335399d5">~TypeFactory()</a>.</p>

</div>
</div>
<a id="a82a52357e69fba6dd4b4adaf4b5279a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a52357e69fba6dd4b4adaf4b5279a2">&#9670;&nbsp;</a></span>clearCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::clearCache </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the common type cache. </p>
<p>Clear the matrix of commonly used atomic types. </p>

<p class="reference">Referenced by <a class="el" href="classTypeFactory.html#a8497930bbd88dd89d91536de06a79f3f">clear()</a>.</p>

</div>
</div>
<a id="afa4b55a83c2f6dbb6f4f13b5ca930ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4b55a83c2f6dbb6f4f13b5ca930ae4">&#9670;&nbsp;</a></span>clearNoncore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::clearNoncore </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear out non-core types. </p>
<p>Delete anything that isn't a core type. </p>

<p class="reference">References <a class="el" href="classTypeFactory.html#a35525edc1bb4b769c3e9fbe48d8b642b">nametree</a>, and <a class="el" href="classTypeFactory.html#aed9d31778ed2c9ccc958ba9f52125de2">tree</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFlushNative.html#a92fb03dcd3fb080a2033442403cde93c">FlushNative::rawAction()</a>.</p>

</div>
</div>
<a id="aab5c58286d60717b8305f4f26a39c5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5c58286d60717b8305f4f26a39c5ac">&#9670;&nbsp;</a></span>concretize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::concretize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert given data-type to concrete form. </p>
<p>The data-type propagation system can push around data-types that are <em>partial</em> or are otherwise unrepresentable in the source language. This method substitutes those data-types with a concrete data-type that is representable, or returns the same data-type if is already concrete. Its important that the returned data-type have the same size as the original data-type regardless. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>is the given data-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the concrete data-type </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">getBase()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa88922d1c65a64d2f39ebaba3411aa057">TYPE_CODE</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeLocal.html#a9776a5769d4422c1e9b9d2dd7c6dfd06">ScopeLocal::createEntry()</a>.</p>

</div>
</div>
<a id="ab143d57ae08682ff4fbc28a6ace5a54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab143d57ae08682ff4fbc28a6ace5a54e">&#9670;&nbsp;</a></span>dependentOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::dependentOrder </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classDatatype.html">Datatype</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>deporder</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place all data-types in dependency order. </p>
<p>Place data-types in an order such that if the definition of data-type "a" depends on the definition of data-type "b", then "b" occurs earlier in the order </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deporder</td><td>will hold the generated dependency list of data-types </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a3eb600c342fe81efd7feb673ccc6c894">orderRecurse()</a>, and <a class="el" href="classTypeFactory.html#aed9d31778ed2c9ccc958ba9f52125de2">tree</a>.</p>

<p class="reference">Referenced by <a class="el" href="classPrintC.html#a6511933f0b8fd3f2fef8aa3920aa9de6">PrintC::docTypeDefinitions()</a>, and <a class="el" href="classTypeFactory.html#adf9b9838cfe8166a236de6562f6dfcc3">saveXml()</a>.</p>

</div>
</div>
<a id="ab4edd4fa31629380ec4124c840022f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4edd4fa31629380ec4124c840022f5a">&#9670;&nbsp;</a></span>destroyType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::destroyType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a data-type from <b>this</b>. </p>
<p>The indicated <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object is removed from this container. Indirect references (via <a class="el" href="classTypeArray.html" title="Datatype object representing an array of elements.">TypeArray</a> <a class="el" href="classTypeStruct.html" title="A composite Datatype object: A &quot;structure&quot; with component &quot;fields&quot;.">TypeStruct</a> etc.) are not affected </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>is the data-type to destroy </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a35525edc1bb4b769c3e9fbe48d8b642b">nametree</a>, and <a class="el" href="classTypeFactory.html#aed9d31778ed2c9ccc958ba9f52125de2">tree</a>.</p>

</div>
</div>
<a id="a979852b4d0b186f833d16d4638fe6f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979852b4d0b186f833d16d4638fe6f08">&#9670;&nbsp;</a></span>downChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::downChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ptrtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb &amp;&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a sub-type matching a pointer and offset. </p>
<p>Add a constant offset to a pointer with known data-type. If there is a valid component at that offset, return a pointer to the data-type of the component or NULL otherwise. This routine only goes down one level at most. Pass back the renormalized offset relative to the new data-type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrtype</td><td>is the pointer data-type being added to </td></tr>
    <tr><td class="paramname">off</td><td>is a reference to the offset to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer datatype for the component or NULL </dd></dl>

<p class="reference">References <a class="el" href="classDatatype.html#ac310ccfdc47d145f10699fa1e14e73b4">Datatype::getSubType()</a>, <a class="el" href="classTypeFactory.html#a2ff26aa7e6197ffb865907313f752d43">getTypePointer()</a>, <a class="el" href="classDatatype.html#a79a16cdae5aff36880bee9122889a0b9">Datatype::metatype</a>, <a class="el" href="classTypePointer.html#aa8c502781518e5f51b3020ddd4ac9fe1">TypePointer::ptrto</a>, <a class="el" href="classDatatype.html#a14476d90cd8993852b349b621876b292">Datatype::size</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa311715f465e358409d513be004f82b2f">TYPE_PTR</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTypeOpPtrsub.html#a1830a4ee48307559c378c4147aa19979">TypeOpPtrsub::getOutputToken()</a>, and <a class="el" href="classActionInferTypes.html#ab2646ac81500c316b9a563ab68a32a79">ActionInferTypes::propagateAddIn2Out()</a>.</p>

</div>
</div>
<a id="a8df9fbdeaf67e5f8b4e7b8d02d67cfcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">&#9670;&nbsp;</a></span>findAdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::findAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> &amp;&#160;</td>
          <td class="paramname"><em>ct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find data-type in this container or add it. </p>
<p>Use quickest method (name or id is possible) to locate the matching data-type. If its not currently in <b>this</b> container, clone the data-type and add it to the container. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>is the data-type to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object in this container </dd></dl>

<p class="reference">References <a class="el" href="classDatatype.html#a6bd032d91f40efe36841adc85b3ff0ec">Datatype::clone()</a>, <a class="el" href="classDatatype.html#ab26e4ca2c3091d3c5a34b4fbd7be76ae">Datatype::compareDependency()</a>, <a class="el" href="classTypeFactory.html#ab86f43d69c0f879d315ce2aacc1f7326">findByIdLocal()</a>, <a class="el" href="classTypeFactory.html#afc2ac2061c8ef5121cdd247164a275c3">findNoName()</a>, <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>, <a class="el" href="classDatatype.html#a66d6613a73e69cd4665c90441c4613b3">Datatype::name</a>, <a class="el" href="classTypeFactory.html#a35525edc1bb4b769c3e9fbe48d8b642b">nametree</a>, <a class="el" href="classDatatype.html#a034a9b665df1a06f17fd3dfe61e7bf41">Datatype::printRaw()</a>, and <a class="el" href="classTypeFactory.html#aed9d31778ed2c9ccc958ba9f52125de2">tree</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">getBase()</a>, <a class="el" href="classTypeFactory.html#ad1efe412493c66b6072ae0def3b53004">getTypeArray()</a>, <a class="el" href="classTypeFactory.html#af2a9fd247245e31f9eeeec29d245cfa2">getTypeChar()</a>, <a class="el" href="classTypeFactory.html#a47c3d70d9598d2b4ce3770593f6ce97e">getTypeCode()</a>, <a class="el" href="classTypeFactory.html#a3bb1aba15e198a7ba2b67741c571de3a">getTypeEnum()</a>, <a class="el" href="classTypeFactory.html#a2ff26aa7e6197ffb865907313f752d43">getTypePointer()</a>, <a class="el" href="classTypeFactory.html#a2295006d8d970d51dc205f5242846d54">getTypePointerAbsolute()</a>, <a class="el" href="classTypeFactory.html#a85de9d19ce1dc44476a414f5ce69b97e">getTypeSpacebase()</a>, <a class="el" href="classTypeFactory.html#aaa4a75179b840571eeb97e24642c55ee">getTypeStruct()</a>, <a class="el" href="classTypeFactory.html#a7a15ff2da4b9476d4f2e9eeeb012fbc7">getTypeUnicode()</a>, <a class="el" href="classTypeFactory.html#adefbb272df63d0e3bddd0195e52fd308">restoreXmlTypeNoRef()</a>, and <a class="el" href="classTypeFactory.html#a1b1dcb82c1c7493b55aae9b339e909c7">restoreXmlTypeWithCodeFlags()</a>.</p>

</div>
</div>
<a id="a79cd8d76884043080a3430f3aff8b010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cd8d76884043080a3430f3aff8b010">&#9670;&nbsp;</a></span>findById()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::findById </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search by name and id. </p>
<p>Search for a <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> by <b>name</b> and/or <b>id</b>. Derived classes may search outside this container. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the name of the data-type </td></tr>
    <tr><td class="paramname">id</td><td>is the type id of the data-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object </dd></dl>

<p>Reimplemented in <a class="el" href="classTypeFactoryGhidra.html#a494fd9c2fb18db1b1f9ee4d7078d590c">TypeFactoryGhidra</a>.</p>

<p class="reference">References <a class="el" href="classTypeFactory.html#ab86f43d69c0f879d315ce2aacc1f7326">findByIdLocal()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTypeFactoryGhidra.html#a494fd9c2fb18db1b1f9ee4d7078d590c">TypeFactoryGhidra::findById()</a>, <a class="el" href="classTypeFactory.html#a5e139f5b338e423fd2b1beb7d941d30f">findByName()</a>, and <a class="el" href="classTypeFactory.html#aea5f4036abb11e63ca5f79a9eacfc93c">restoreXmlType()</a>.</p>

</div>
</div>
<a id="ab86f43d69c0f879d315ce2aacc1f7326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86f43d69c0f879d315ce2aacc1f7326">&#9670;&nbsp;</a></span>findByIdLocal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::findByIdLocal </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search locally by name and id. </p>
<p>Looking just within this container, find a <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> by <b>name</b> and/or <b>id</b>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the name of the data-type </td></tr>
    <tr><td class="paramname">id</td><td>is the type id of the data-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object </dd></dl>

<p class="reference">References <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>, <a class="el" href="classTypeFactory.html#a35525edc1bb4b769c3e9fbe48d8b642b">nametree</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>, <a class="el" href="classTypeFactory.html#a79cd8d76884043080a3430f3aff8b010">findById()</a>, and <a class="el" href="classTypeFactory.html#adefbb272df63d0e3bddd0195e52fd308">restoreXmlTypeNoRef()</a>.</p>

</div>
</div>
<a id="a5e139f5b338e423fd2b1beb7d941d30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e139f5b338e423fd2b1beb7d941d30f">&#9670;&nbsp;</a></span>findByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::findByName </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return type of given name. </p>
<p>Find type with given name. If there are more than, return first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the name to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object with the name or NULL </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a79cd8d76884043080a3430f3aff8b010">findById()</a>.</p>

</div>
</div>
<a id="afc2ac2061c8ef5121cdd247164a275c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2ac2061c8ef5121cdd247164a275c3">&#9670;&nbsp;</a></span>findNoName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::findNoName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> &amp;&#160;</td>
          <td class="paramname"><em>ct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find data-type (in this container) by function. </p>
<p>Find data-type without reference to name, using the functional comparators For this to work, the type must be built out of dependencies that are already present in <b>this</b> type factory </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>is the data-type to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> or NULL </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#aed9d31778ed2c9ccc958ba9f52125de2">tree</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>.</p>

</div>
</div>
<a id="a5fe1ae26c0b76b18d59d5cd27a9b8ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">&#9670;&nbsp;</a></span>getBase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::getBase </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get atomic type. </p>
<p>Get one of the "base" datatypes. This routine is called a lot, so we go through a cache first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the desired size </td></tr>
    <tr><td class="paramname">m</td><td>is the desired meta-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>, <a class="el" href="classTypeFactory.html#ad1efe412493c66b6072ae0def3b53004">getTypeArray()</a>, <a class="el" href="classTypeFactory.html#a0652ec9d4b9d9d0943d1fbffe9b9c740">glb</a>, <a class="el" href="classArchitecture.html#a37de4bf5cb39955f32a24074e768a591">Architecture::max_basetype_size</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa19a0a402d33a2e049e91ea9e37e90c2f">TYPE_FLOAT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, <a class="el" href="classTypeFactory.html#aa5f8367763c472cfe82ebf0c7ef7c6e0">typecache</a>, <a class="el" href="classTypeFactory.html#a8e2e98189b4baf44aee9f715375ecd4f">typecache10</a>, and <a class="el" href="classTypeFactory.html#a6071eb27ddaaa93055c521420442a865">typecache16</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMapState.html#a967931fd52c114a90cbbeedd5abc124b">MapState::addGuard()</a>, <a class="el" href="classCastStrategyC.html#a478423d83d44c4c2d28a461dad75654c">CastStrategyC::arithmeticOutputStandard()</a>, <a class="el" href="classTypeFactory.html#aab5c58286d60717b8305f4f26a39c5ac">concretize()</a>, <a class="el" href="classTypeFactory.html#adca2937f24e37c5ac19ba442cd1df0d8">getBaseNoChar()</a>, <a class="el" href="classTypeOp.html#abe2e4b619932cf94bafb084963a0fc66">TypeOp::getInputLocal()</a>, <a class="el" href="classTypeOpBinary.html#a6b8460b8ee0e97579321c6d02fe4fd29">TypeOpBinary::getInputLocal()</a>, <a class="el" href="classTypeOpUnary.html#a80df02d6ff2783f44b3c9dca6f580044">TypeOpUnary::getInputLocal()</a>, <a class="el" href="classTypeOpFunc.html#a7f2860d7c345a794c665f72dbc41c44d">TypeOpFunc::getInputLocal()</a>, <a class="el" href="classTypeOpCbranch.html#af7d6764f79c316780136fab4e67b8a3f">TypeOpCbranch::getInputLocal()</a>, <a class="el" href="classTypeOpPtradd.html#a80258521d1b2a930d1472fcf1b6c53eb">TypeOpPtradd::getInputLocal()</a>, <a class="el" href="classTypeOpPtrsub.html#aeb893948a1260af75942c71c4a2e19cd">TypeOpPtrsub::getInputLocal()</a>, <a class="el" href="classTypeOpCpoolref.html#a08047a47da143613ebf78d36dd22c564">TypeOpCpoolref::getInputLocal()</a>, <a class="el" href="classTypeOpInsert.html#af5fda9d3fc8949de3671a165d285c36c">TypeOpInsert::getInputLocal()</a>, <a class="el" href="classTypeOpExtract.html#a92ff401c8559c6c30806f15377810536">TypeOpExtract::getInputLocal()</a>, <a class="el" href="classTypeOp.html#a3454cadfb15f6794829123a7ecfe38f5">TypeOp::getOutputLocal()</a>, <a class="el" href="classTypeOpBinary.html#a183a65ebb3716a380229e38c3383fd98">TypeOpBinary::getOutputLocal()</a>, <a class="el" href="classTypeOpUnary.html#a33872e1381109a5fdb1030a2771e0c6e">TypeOpUnary::getOutputLocal()</a>, <a class="el" href="classTypeOpFunc.html#a279fd2e0aaf14e6a15bb12548cd3cc69">TypeOpFunc::getOutputLocal()</a>, <a class="el" href="classTypeOpPtradd.html#af8fe09a62086231038f5c181dc0d0a03">TypeOpPtradd::getOutputLocal()</a>, <a class="el" href="classTypeOpPtrsub.html#ada6371e868ebf8d0f5aae1ba70a60e36">TypeOpPtrsub::getOutputLocal()</a>, <a class="el" href="classTypeOpCpoolref.html#af6f8c8b7ce807d7773e55820c11a08f1">TypeOpCpoolref::getOutputLocal()</a>, <a class="el" href="classTypeOpIntLeft.html#a0c99823cd347ae28c3608a3f02fdda09">TypeOpIntLeft::getOutputToken()</a>, <a class="el" href="classTypeOpIntRight.html#a3c470ddca0dbdab3b01d8734308edd26">TypeOpIntRight::getOutputToken()</a>, <a class="el" href="classTypeOpIntSright.html#a2e2989e20e9ccdcd2e56d719202ac0fc">TypeOpIntSright::getOutputToken()</a>, <a class="el" href="classTypeOpPiece.html#a951c2e42be991699b04945bb1c71de04">TypeOpPiece::getOutputToken()</a>, <a class="el" href="classTypeOpSubpiece.html#ac93ca300b551f16888008869eca39150">TypeOpSubpiece::getOutputToken()</a>, <a class="el" href="classTypeFactory.html#a77988d5cf50fc10fe92dec8e265a720f">getTypePointerNoDepth()</a>, <a class="el" href="classFuncdata.html#aed6aefa7321e887e3b759de94e4d3d4f">Funcdata::mapGlobals()</a>, <a class="el" href="classRangeHint.html#acce59afd659776a70a7086f9d9024a1e">RangeHint::merge()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncdata.html#a731f6fd415269577b7bb1943315b8a76">Funcdata::newUnique()</a>, <a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">Funcdata::newUniqueOut()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">Funcdata::newVarnode()</a>, <a class="el" href="classFuncdata.html#a13da637294b7cae252ffc6c9e2116da2">Funcdata::newVarnodeCallSpecs()</a>, <a class="el" href="classFuncdata.html#a8ee39fe2d1f2f4702864e78dc06e6bb8">Funcdata::newVarnodeIop()</a>, <a class="el" href="classFuncdata.html#a100e6704e4c245e076170268d31b47ec">Funcdata::newVarnodeOut()</a>, <a class="el" href="classFuncdata.html#acc9f6fb3e8a36e0e1e633660fc05fdbf">Funcdata::newVarnodeSpace()</a>, <a class="el" href="classFuncProto.html#a75f9569f65cd6472f80d3e85d8453ced">FuncProto::paramShift()</a>, <a class="el" href="classActionInferTypes.html#ab2646ac81500c316b9a563ab68a32a79">ActionInferTypes::propagateAddIn2Out()</a>, <a class="el" href="classActionInferTypes.html#a7cd85268ef220778b05b1fcaa38b2c91">ActionInferTypes::propagateTypeEdge()</a>, <a class="el" href="classPrintC.html#a234b95d9f3fdb8a79eeff02eb4acbca3">PrintC::pushAnnotation()</a>, <a class="el" href="classScope.html#a4af52229967e3a507a5367e14a298142">Scope::resetSizeLockType()</a>, <a class="el" href="classParameterBasic.html#ac3aed750efa13f72a9a674ceb666eb9a">ParameterBasic::resetSizeLockType()</a>, <a class="el" href="classEquateSymbol.html#ab4aa7cdacdd28777f82bf0be1ad55454">EquateSymbol::restoreXml()</a>, <a class="el" href="classScopeLocal.html#a308e308109ca1964d49d6a3a539a9acf">ScopeLocal::restructureHigh()</a>, <a class="el" href="classScopeLocal.html#a4f0d61de6d043ae92af2c2cf1836453a">ScopeLocal::restructureVarnode()</a>, <a class="el" href="classTypeFactory.html#a7f142a54450d41bc12ca18fe06c6e1e0">setCoreType()</a>, <a class="el" href="classFuncProto.html#ad2b6986a4cf61f042579472e394ad7f8">FuncProto::updateInputNoTypes()</a>, and <a class="el" href="classFuncProto.html#a882e34d08f3e4e44ba5aa25b87c84bfe">FuncProto::updateOutputNoTypes()</a>.</p>

</div>
</div>
<a id="a2848b5923834b755de0749d9f96880e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2848b5923834b755de0749d9f96880e1">&#9670;&nbsp;</a></span>getBase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::getBase </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get named atomic type. </p>
<p>Get or create a "base" type with a specified name and properties </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the desired size </td></tr>
    <tr><td class="paramname">m</td><td>is the desired meta-type </td></tr>
    <tr><td class="paramname">n</td><td>is the desired name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classDatabase.html" title="A manager for symbol scopes for a whole executable.">Database</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>, <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, and <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>.</p>

</div>
</div>
<a id="adca2937f24e37c5ac19ba442cd1df0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca2937f24e37c5ac19ba442cd1df0d8">&#9670;&nbsp;</a></span>getBaseNoChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::getBaseNoChar </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get atomic type excluding "char". </p>
<p>Get a "base" data-type, given its size and <b>metatype</b>. If a 1-byte integer is requested, do NOT return a <a class="el" href="classTypeChar.html" title="Base type for character data-types: i.e. char.">TypeChar</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the data-type </td></tr>
    <tr><td class="paramname">m</td><td>is the meta-type of the data-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">getBase()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa4fcd4421533bb21c827865bdbac4fef9">TYPE_INT</a>, and <a class="el" href="classTypeFactory.html#a8366394e6205c501a1e128465566b761">type_nochar</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTypeOpIntLeft.html#ace4697dce938154ffc5098b0c582cf3b">TypeOpIntLeft::getInputLocal()</a>, <a class="el" href="classTypeOpIntRight.html#afd6976a40304a509b940a874da58b31b">TypeOpIntRight::getInputLocal()</a>, and <a class="el" href="classTypeOpIntSright.html#a684bdbbed1aa1ac2fc0d08caf5e0ca24">TypeOpIntSright::getInputLocal()</a>.</p>

</div>
</div>
<a id="ad1efe412493c66b6072ae0def3b53004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1efe412493c66b6072ae0def3b53004">&#9670;&nbsp;</a></span>getTypeArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeArray.html">TypeArray</a> * TypeFactory::getTypeArray </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>as</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ao</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an array data-type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>is the number of elements in the desired array </td></tr>
    <tr><td class="paramname">ao</td><td>is the data-type of the array element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypeArray.html" title="Datatype object representing an array of elements.">TypeArray</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeLocal.html#a9776a5769d4422c1e9b9d2dd7c6dfd06">ScopeLocal::createEntry()</a>, and <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">getBase()</a>.</p>

</div>
</div>
<a id="af2a9fd247245e31f9eeeec29d245cfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a9fd247245e31f9eeeec29d245cfa2">&#9670;&nbsp;</a></span>getTypeChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeChar.html">TypeChar</a> * TypeFactory::getTypeChar </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a default "char" type. </p>
<p>This creates a 1-byte character datatype (assumed to use UTF8 encoding) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the name to give the data-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new character <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>, <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, and <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTypeFactory.html#a7f142a54450d41bc12ca18fe06c6e1e0">setCoreType()</a>.</p>

</div>
</div>
<a id="a264037dc13d6d5d5c643bc805c373375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264037dc13d6d5d5c643bc805c373375">&#9670;&nbsp;</a></span>getTypeCode() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeCode.html">TypeCode</a> * TypeFactory::getTypeCode </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a default "code" type. </p>
<p>Create a "function" or "executable" <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object This is used for anonymous function pointers with no prototype </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the name of the data-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>, <a class="el" href="classTypeFactory.html#a47c3d70d9598d2b4ce3770593f6ce97e">getTypeCode()</a>, <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, and <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>.</p>

<p class="reference">Referenced by <a class="el" href="classExternRefSymbol.html#aa4910e1cd3e935b25574a07752a0b6ea">ExternRefSymbol::buildNameType()</a>, <a class="el" href="classFunctionSymbol.html#afdba700a8ea13faf3b57747ab4f08503">FunctionSymbol::buildType()</a>, <a class="el" href="classTypeOpCbranch.html#af7d6764f79c316780136fab4e67b8a3f">TypeOpCbranch::getInputLocal()</a>, <a class="el" href="classTypeOpCallind.html#a12ae23733dbb5b171ab30f32a90b973c">TypeOpCallind::getInputLocal()</a>, <a class="el" href="classTypeOpIndirect.html#a556bb0789c0ef43a825befed5f4068c4">TypeOpIndirect::getInputLocal()</a>, and <a class="el" href="classFuncdata.html#a24e80f56ef371a0010a9e67ae8510086">Funcdata::newCodeRef()</a>.</p>

</div>
</div>
<a id="a99362bf53b0ead2d57a2221bc2fd03cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99362bf53b0ead2d57a2221bc2fd03cc">&#9670;&nbsp;</a></span>getTypeCode() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeCode.html">TypeCode</a> * TypeFactory::getTypeCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classProtoModel.html">ProtoModel</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>outtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classDatatype.html">Datatype</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>intypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dotdotdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a "function" datatype. </p>
<p>Creates a <a class="el" href="classTypeCode.html" title="Datatype object representing executable code.">TypeCode</a> object and associates a specific function prototype with it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>is the prototype model associated with the function </td></tr>
    <tr><td class="paramname">outtype</td><td>is the return type of the function </td></tr>
    <tr><td class="paramname">intypes</td><td>is the array of input parameters of the function </td></tr>
    <tr><td class="paramname">dotdotdot</td><td>is true if the function takes variable arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypeCode.html" title="Datatype object representing executable code.">TypeCode</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>, <a class="el" href="classTypeFactory.html#ab7277908ef32101f172633ec00fbecb1">getTypeVoid()</a>, and <a class="el" href="classTypeCode.html#a6f6acdba3bf4b363ffaf4b71501970a5">TypeCode::set()</a>.</p>

</div>
</div>
<a id="a47c3d70d9598d2b4ce3770593f6ce97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c3d70d9598d2b4ce3770593f6ce97e">&#9670;&nbsp;</a></span>getTypeCode() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeCode.html">TypeCode</a> * TypeFactory::getTypeCode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an "anonymous" function data-type. </p>
<p>Retrieve or create the core "code" <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object This has no prototype attached to it and is appropriate for anonymous function pointers. </p><dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypeCode.html" title="Datatype object representing executable code.">TypeCode</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa88922d1c65a64d2f39ebaba3411aa057">TYPE_CODE</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa19a0a402d33a2e049e91ea9e37e90c2f">TYPE_FLOAT</a>, and <a class="el" href="classTypeFactory.html#aa5f8367763c472cfe82ebf0c7ef7c6e0">typecache</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTypeFactory.html#a264037dc13d6d5d5c643bc805c373375">getTypeCode()</a>, and <a class="el" href="classTypeFactory.html#a7f142a54450d41bc12ca18fe06c6e1e0">setCoreType()</a>.</p>

</div>
</div>
<a id="a3bb1aba15e198a7ba2b67741c571de3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb1aba15e198a7ba2b67741c571de3a">&#9670;&nbsp;</a></span>getTypeEnum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeEnum.html">TypeEnum</a> * TypeFactory::getTypeEnum </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an (empty) enumeration. </p>
<p>The created enumeration will have no named values and a default configuration Named values must be added later. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the name of the enumeration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypeEnum.html" title="An enumerated Datatype object: an integer with named values.">TypeEnum</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a47fe3fddd79a56398f5d9dc7cd537bf3">enumsize</a>, <a class="el" href="classTypeFactory.html#a9b53c08b2845563e7b03253e0474559b">enumtype</a>, <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>, <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, and <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>.</p>

</div>
</div>
<a id="a2ff26aa7e6197ffb865907313f752d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff26aa7e6197ffb865907313f752d43">&#9670;&nbsp;</a></span>getTypePointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypePointer.html">TypePointer</a> * TypeFactory::getTypePointer </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>ws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a pointer data-type. </p>
<p>This creates a pointer to a given data-type. It doesn't allow a "pointer to array" to be created however and will drill-down to the first non-array data-type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the pointer </td></tr>
    <tr><td class="paramname">pt</td><td>is the pointed-to data-type </td></tr>
    <tr><td class="paramname">ws</td><td>is the wordsize associated with the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypePointer.html" title="Datatype object representing a pointer.">TypePointer</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fad189c0a53681ec74eeea1f56d08d741f">TYPE_ARRAY</a>.</p>

<p class="reference">Referenced by <a class="el" href="classExternRefSymbol.html#aa4910e1cd3e935b25574a07752a0b6ea">ExternRefSymbol::buildNameType()</a>, <a class="el" href="classTypeFactory.html#a979852b4d0b186f833d16d4638fe6f08">downChain()</a>, <a class="el" href="classTypeOpLoad.html#a42e0b10ae74a6839bffc18f3e36bb02a">TypeOpLoad::getInputCast()</a>, <a class="el" href="classTypeOpStore.html#a37da7d884a84478b4fa72451c47411c0">TypeOpStore::getInputCast()</a>, <a class="el" href="classTypeOpCbranch.html#af7d6764f79c316780136fab4e67b8a3f">TypeOpCbranch::getInputLocal()</a>, <a class="el" href="classTypeOpCallind.html#a12ae23733dbb5b171ab30f32a90b973c">TypeOpCallind::getInputLocal()</a>, <a class="el" href="classTypeOpIndirect.html#a556bb0789c0ef43a825befed5f4068c4">TypeOpIndirect::getInputLocal()</a>, <a class="el" href="classTypeFactory.html#a77988d5cf50fc10fe92dec8e265a720f">getTypePointerNoDepth()</a>, <a class="el" href="classActionInferTypes.html#ab2646ac81500c316b9a563ab68a32a79">ActionInferTypes::propagateAddIn2Out()</a>, <a class="el" href="classActionInferTypes.html#a7cd85268ef220778b05b1fcaa38b2c91">ActionInferTypes::propagateTypeEdge()</a>, <a class="el" href="classFuncdata.html#a96433773ee0126ce9a25b0970a6ef513">Funcdata::spacebase()</a>, and <a class="el" href="classFuncdata.html#aaf4a89f4e3da37a4107992689f7b89ff">Funcdata::spacebaseConstant()</a>.</p>

</div>
</div>
<a id="a2295006d8d970d51dc205f5242846d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2295006d8d970d51dc205f5242846d54">&#9670;&nbsp;</a></span>getTypePointerAbsolute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypePointer.html">TypePointer</a> * TypeFactory::getTypePointerAbsolute </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>ws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an absolute pointer data-type. </p>
<p>Allows "pointer to array" to be constructed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the pointer </td></tr>
    <tr><td class="paramname">pt</td><td>is the pointed-to data-type </td></tr>
    <tr><td class="paramname">ws</td><td>is the wordsize associated with the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypePointer.html" title="Datatype object representing a pointer.">TypePointer</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classParamListStandard.html#a4819bb8291e202e3d11737d586878525">ParamListStandard::assignMap()</a>, and <a class="el" href="classParamListStandardOut.html#af50fd192a944d885223b263e5c31a69e">ParamListStandardOut::assignMap()</a>.</p>

</div>
</div>
<a id="a77988d5cf50fc10fe92dec8e265a720f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77988d5cf50fc10fe92dec8e265a720f">&#9670;&nbsp;</a></span>getTypePointerNoDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypePointer.html">TypePointer</a> * TypeFactory::getTypePointerNoDepth </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>ws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a depth limited pointer data-type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the pointer </td></tr>
    <tr><td class="paramname">pt</td><td>is the pointed-to data-type </td></tr>
    <tr><td class="paramname">ws</td><td>is the wordsize associated with the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypePointer.html" title="Datatype object representing a pointer.">TypePointer</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">getBase()</a>, <a class="el" href="classTypeFactory.html#a2ff26aa7e6197ffb865907313f752d43">getTypePointer()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa311715f465e358409d513be004f82b2f">TYPE_PTR</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>.</p>

<p class="reference">Referenced by <a class="el" href="classActionInferTypes.html#a7cd85268ef220778b05b1fcaa38b2c91">ActionInferTypes::propagateTypeEdge()</a>.</p>

</div>
</div>
<a id="a85de9d19ce1dc44476a414f5ce69b97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85de9d19ce1dc44476a414f5ce69b97e">&#9670;&nbsp;</a></span>getTypeSpacebase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeSpacebase.html">TypeSpacebase</a> * TypeFactory::getTypeSpacebase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a "spacebase" type. </p>
<p>Creates the special <a class="el" href="classTypeSpacebase.html" title="Special Datatype object used to describe pointers that index into the symbol table.">TypeSpacebase</a> with an associated address space and scope </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the address space </td></tr>
    <tr><td class="paramname">addr</td><td>specifies the function scope, or isInvalid() for global scope </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypeSpacebase.html" title="Special Datatype object used to describe pointers that index into the symbol table.">TypeSpacebase</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>, and <a class="el" href="classTypeFactory.html#a0652ec9d4b9d9d0943d1fbffe9b9c740">glb</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFuncdata.html#a96433773ee0126ce9a25b0970a6ef513">Funcdata::spacebase()</a>, and <a class="el" href="classFuncdata.html#aaf4a89f4e3da37a4107992689f7b89ff">Funcdata::spacebaseConstant()</a>.</p>

</div>
</div>
<a id="aaa4a75179b840571eeb97e24642c55ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4a75179b840571eeb97e24642c55ee">&#9670;&nbsp;</a></span>getTypeStruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeStruct.html">TypeStruct</a> * TypeFactory::getTypeStruct </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an (empty) structure. </p>
<p>The created structure will have no fields. They must be added later. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the name of the structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypeStruct.html" title="A composite Datatype object: A &quot;structure&quot; with component &quot;fields&quot;.">TypeStruct</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>, <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, and <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>.</p>

</div>
</div>
<a id="a7a15ff2da4b9476d4f2e9eeeb012fbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a15ff2da4b9476d4f2e9eeeb012fbc7">&#9670;&nbsp;</a></span>getTypeUnicode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeUnicode.html">TypeUnicode</a> * TypeFactory::getTypeUnicode </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a default "unicode" type. </p>
<p>This creates a multi-byte character data-type (using UTF16 or UTF32 encoding) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the name to give the data-type </td></tr>
    <tr><td class="paramname">sz</td><td>is the size of the data-type in bytes </td></tr>
    <tr><td class="paramname">m</td><td>is the presumed <b>meta-type</b> when treating the character as an integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new character <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>, <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, and <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTypeFactory.html#a7f142a54450d41bc12ca18fe06c6e1e0">setCoreType()</a>.</p>

</div>
</div>
<a id="ab7277908ef32101f172633ec00fbecb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7277908ef32101f172633ec00fbecb1">&#9670;&nbsp;</a></span>getTypeVoid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeVoid.html">TypeVoid</a> * TypeFactory::getTypeVoid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the "void" data-type. </p>
<p>There should be exactly one instance of the "void" <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object, which this fetches </p><dl class="section return"><dt>Returns</dt><dd>the "void" data-type </dd></dl>

<p class="reference">References <a class="el" href="classTypeVoid.html#a4fe8a82cb4657566119e63b73164d22a">TypeVoid::clone()</a>, <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>, <a class="el" href="classTypeFactory.html#a35525edc1bb4b769c3e9fbe48d8b642b">nametree</a>, <a class="el" href="classTypeFactory.html#aed9d31778ed2c9ccc958ba9f52125de2">tree</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa19a0a402d33a2e049e91ea9e37e90c2f">TYPE_FLOAT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa84de340fe64164ed0dcf473aad846961">TYPE_VOID</a>, and <a class="el" href="classTypeFactory.html#aa5f8367763c472cfe82ebf0c7ef7c6e0">typecache</a>.</p>

<p class="reference">Referenced by <a class="el" href="classProtoModel.html#a5c32e533f079fc91875ccd486f70f36e">ProtoModel::assignParameterStorage()</a>, <a class="el" href="classPrintC.html#a18fa1574b22c87e7ef25e4a0b99284ac">PrintC::buildTypeStack()</a>, <a class="el" href="classTypeFactory.html#a99362bf53b0ead2d57a2221bc2fd03cc">getTypeCode()</a>, <a class="el" href="classFuncProto.html#a75f9569f65cd6472f80d3e85d8453ced">FuncProto::paramShift()</a>, <a class="el" href="classPrintJava.html#af82e5ca143891ea052778b1ed234d3e0">PrintJava::pushTypeStart()</a>, <a class="el" href="classOverride.html#a81f34dfc11c427ea0873358bef93ada3">Override::restoreXml()</a>, <a class="el" href="classTypeFactory.html#adefbb272df63d0e3bddd0195e52fd308">restoreXmlTypeNoRef()</a>, and <a class="el" href="classTypeFactory.html#a7f142a54450d41bc12ca18fe06c6e1e0">setCoreType()</a>.</p>

</div>
</div>
<a id="a3eb600c342fe81efd7feb673ccc6c894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb600c342fe81efd7feb673ccc6c894">&#9670;&nbsp;</a></span>orderRecurse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::orderRecurse </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classDatatype.html">Datatype</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>deporder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="type_8hh.html#a718b9f8902a3f2dcc61b4eb84c58adf2">DatatypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write out dependency list. </p>
<p>Recursively write out all the components of a data-type in dependency order Component data-types will come before the data-type containing them in the list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deporder</td><td>holds the ordered list of data-types to construct </td></tr>
    <tr><td class="paramname">mark</td><td>is a "marking" container to prevent cycles </td></tr>
    <tr><td class="paramname">ct</td><td>is the data-type to have written out </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classTypeFactory.html#ab143d57ae08682ff4fbc28a6ace5a54e">dependentOrder()</a>.</p>

</div>
</div>
<a id="a6e13c732148b6c5f78797d60e1a115f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e13c732148b6c5f78797d60e1a115f5">&#9670;&nbsp;</a></span>parseDataOrganization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::parseDataOrganization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the &lt;data_organization&gt; tag. </p>
<p>Recover various sizes relevant to <b>this</b> container, such as the default size of "int" and structure alignment, by parsing the &lt;data_organization&gt; tag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a180f8e14584ec0dba65dfc258f96e7ea">align</a>, <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>, and <a class="el" href="classTypeFactory.html#a29c926d1ab19f6cd2d5fa7df86eba78e">sizeOfInt</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">Architecture::parseCompilerConfig()</a>.</p>

</div>
</div>
<a id="a8d10b37cae4c213ca3a613f454ada676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d10b37cae4c213ca3a613f454ada676">&#9670;&nbsp;</a></span>parseEnumConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::parseEnumConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the &lt;enum&gt; tag. </p>
<p>Recover default enumeration properties (size and meta-type) from an &lt;enum&gt; XML tag. Should probably consider this deprecated. These values are only used by the internal C parser. param el is the XML element </p>

<p class="reference">References <a class="el" href="classTypeFactory.html#a47fe3fddd79a56398f5d9dc7cd537bf3">enumsize</a>, <a class="el" href="classTypeFactory.html#a9b53c08b2845563e7b03253e0474559b">enumtype</a>, <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa4fcd4421533bb21c827865bdbac4fef9">TYPE_INT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61faba807ad7d41a3ac08fd4a71e9e013192">TYPE_UINT</a>, and <a class="el" href="xml_8hh.html#ac2d01d7c2986f1143b2f6145311d093e">xml_readbool()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">Architecture::parseCompilerConfig()</a>.</p>

</div>
</div>
<a id="af9a16d80bfd84732a8dca11ed4a23fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a16d80bfd84732a8dca11ed4a23fab">&#9670;&nbsp;</a></span>restoreXml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::restoreXml </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore <b>this</b> container from a stream. </p>
<p>Read data-types into this container from an XML stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the root XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a180f8e14584ec0dba65dfc258f96e7ea">align</a>, <a class="el" href="classTypeFactory.html#a47fe3fddd79a56398f5d9dc7cd537bf3">enumsize</a>, <a class="el" href="classTypeFactory.html#a9b53c08b2845563e7b03253e0474559b">enumtype</a>, <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>, <a class="el" href="classTypeFactory.html#adefbb272df63d0e3bddd0195e52fd308">restoreXmlTypeNoRef()</a>, <a class="el" href="classTypeFactory.html#a29c926d1ab19f6cd2d5fa7df86eba78e">sizeOfInt</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa4fcd4421533bb21c827865bdbac4fef9">TYPE_INT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61faba807ad7d41a3ac08fd4a71e9e013192">TYPE_UINT</a>, and <a class="el" href="xml_8hh.html#ac2d01d7c2986f1143b2f6145311d093e">xml_readbool()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#ab15a398b9f84dd62ad36d1e83895783a">Architecture::restoreXml()</a>.</p>

</div>
</div>
<a id="a24c7308dab804e4f89fd567500b97d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c7308dab804e4f89fd567500b97d63">&#9670;&nbsp;</a></span>restoreXmlCoreTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::restoreXmlCoreTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize basic type names. </p>
<p>Restore data-types from an XML stream into this container This stream is presumed to contain "core" datatypes and the cached matrix will be populated from this set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the root XML element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a16ccfeecd29c1d5d40ada6b1d4032212">cacheCoreTypes()</a>, <a class="el" href="classTypeFactory.html#a8497930bbd88dd89d91536de06a79f3f">clear()</a>, and <a class="el" href="classTypeFactory.html#adefbb272df63d0e3bddd0195e52fd308">restoreXmlTypeNoRef()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitectureGhidra.html#afdc4a7c905c401909628967b4b249ddc">ArchitectureGhidra::buildTypegrp()</a>, and <a class="el" href="classArchitecture.html#aaf041374ee649d2c0d8e95e450af5bf9">Architecture::buildTypegrp()</a>.</p>

</div>
</div>
<a id="aea5f4036abb11e63ca5f79a9eacfc93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5f4036abb11e63ca5f79a9eacfc93c">&#9670;&nbsp;</a></span>restoreXmlType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::restoreXmlType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> from XML. </p>
<p>Restore a <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object from an XML tag description: either &lt;type&gt;, &lt;typeref&gt;, or &lt;void&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element describing the data-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the restored <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a79cd8d76884043080a3430f3aff8b010">findById()</a>, <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>, <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, and <a class="el" href="classTypeFactory.html#adefbb272df63d0e3bddd0195e52fd308">restoreXmlTypeNoRef()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTypeFactoryGhidra.html#a494fd9c2fb18db1b1f9ee4d7078d590c">TypeFactoryGhidra::findById()</a>, <a class="el" href="classCPoolRecord.html#a93e21b4afa8d1db68152b7d6e56c3413">CPoolRecord::restoreXml()</a>, <a class="el" href="classProtoStoreInternal.html#ae1c3cd409eda277f1ff924cf858eddef">ProtoStoreInternal::restoreXml()</a>, and <a class="el" href="classFuncProto.html#a4c4f9da74ee904e6abfa195bd843521e">FuncProto::restoreXml()</a>.</p>

</div>
</div>
<a id="adefbb272df63d0e3bddd0195e52fd308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefbb272df63d0e3bddd0195e52fd308">&#9670;&nbsp;</a></span>restoreXmlTypeNoRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::restoreXmlTypeNoRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forcecore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore from an XML tag. </p>
<p>Restore a <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object from an XML &lt;type&gt; tag. (Don't use for &lt;typeref&gt; tags) The new <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> is added to <b>this</b> container </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
    <tr><td class="paramname">forcecore</td><td>is true if the new type should be labeled as a core type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object </dd></dl>

<p class="reference">References <a class="el" href="classDatatype.html#ab26e4ca2c3091d3c5a34b4fbd7be76ae">Datatype::compareDependency()</a>, <a class="el" href="classDatatype.html#abf874c38e872ed1e2c2c78736e288626a8efcece19aae42262429fbf59330a2c7">Datatype::coretype</a>, <a class="el" href="classTypeStruct.html#a4d5a49b12324fb588f6c1631c35bc37d">TypeStruct::field</a>, <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>, <a class="el" href="classTypeFactory.html#ab86f43d69c0f879d315ce2aacc1f7326">findByIdLocal()</a>, <a class="el" href="classDatatype.html#a82e59a9379488b5afdae69817c0955fb">Datatype::flags</a>, <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>, <a class="el" href="classTypeFactory.html#ab7277908ef32101f172633ec00fbecb1">getTypeVoid()</a>, <a class="el" href="classTypeFactory.html#a0652ec9d4b9d9d0943d1fbffe9b9c740">glb</a>, <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>, <a class="el" href="classDatatype.html#aed882ae693a31a64d56fffb9abdaa575">Datatype::restoreXml()</a>, <a class="el" href="classTypeUnicode.html#a3158417117649e59ffe402137c22bb67">TypeUnicode::restoreXml()</a>, <a class="el" href="classTypePointer.html#a8f62fbff5e735eb8ad562878bc5efed7">TypePointer::restoreXml()</a>, <a class="el" href="classTypeArray.html#a3f933b477f4089344f7a58ef67aa6ee1">TypeArray::restoreXml()</a>, <a class="el" href="classTypeEnum.html#a1bd4dc88f4ea0b58b4b164b4b5f4f5e5">TypeEnum::restoreXml()</a>, <a class="el" href="classTypeStruct.html#af2b09832da8420f6da67382a4e2d9f0e">TypeStruct::restoreXml()</a>, <a class="el" href="classTypeCode.html#a8b721a26b30c296fe2510738601e3333">TypeCode::restoreXml()</a>, <a class="el" href="classTypeSpacebase.html#ad47f882d367ee73d16adf3140862ca65">TypeSpacebase::restoreXml()</a>, <a class="el" href="classTypeFactory.html#a17480d8c1040602a1becb483e6c59652">setFields()</a>, <a class="el" href="classDatatype.html#a14476d90cd8993852b349b621876b292">Datatype::size</a>, <a class="el" href="type_8hh.html#ae2f04f32a572d784b4c46f6745239c42">string2metatype()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fad189c0a53681ec74eeea1f56d08d741f">TYPE_ARRAY</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa88922d1c65a64d2f39ebaba3411aa057">TYPE_CODE</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa4fcd4421533bb21c827865bdbac4fef9">TYPE_INT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa311715f465e358409d513be004f82b2f">TYPE_PTR</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fae8e2fb69af09eb8907e86b16ff585324">TYPE_SPACEBASE</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa9001cd1bc103bb1d664228d46715f65c">TYPE_STRUCT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, and <a class="el" href="xml_8hh.html#ac2d01d7c2986f1143b2f6145311d093e">xml_readbool()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTypeFactory.html#af9a16d80bfd84732a8dca11ed4a23fab">restoreXml()</a>, <a class="el" href="classTypeFactory.html#a24c7308dab804e4f89fd567500b97d63">restoreXmlCoreTypes()</a>, and <a class="el" href="classTypeFactory.html#aea5f4036abb11e63ca5f79a9eacfc93c">restoreXmlType()</a>.</p>

</div>
</div>
<a id="a1b1dcb82c1c7493b55aae9b339e909c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1dcb82c1c7493b55aae9b339e909c7">&#9670;&nbsp;</a></span>restoreXmlTypeWithCodeFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::restoreXmlTypeWithCodeFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hasThisPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isConstructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isDestructor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore data-type from XML with extra "code" flags. </p>
<p>Kludge to get flags into code pointer types, when they can't come through XML </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element describing the <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> </td></tr>
    <tr><td class="paramname">hasThisPtr</td><td>toggles "this" pointer property on "function" datatypes </td></tr>
    <tr><td class="paramname">isConstructor</td><td>toggles "constructor" property on "function" datatypes </td></tr>
    <tr><td class="paramname">isDestructor</td><td>toggles "destructor" property on "function" datatypes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the restored <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd()</a>, <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>, <a class="el" href="classTypePointer.html#aa8c502781518e5f51b3020ddd4ac9fe1">TypePointer::ptrto</a>, <a class="el" href="classTypeCode.html#a8b721a26b30c296fe2510738601e3333">TypeCode::restoreXml()</a>, <a class="el" href="classDatatype.html#afeb70488c52d024b293d5198c98b3f49">Datatype::restoreXmlBasic()</a>, <a class="el" href="classTypeCode.html#a12a5097d49a87e482795d0b299d718cc">TypeCode::setProperties()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa311715f465e358409d513be004f82b2f">TYPE_PTR</a>, and <a class="el" href="classTypePointer.html#a32eee64befc16e8200d81477a5846ec6">TypePointer::wordsize</a>.</p>

<p class="reference">Referenced by <a class="el" href="classCPoolRecord.html#a93e21b4afa8d1db68152b7d6e56c3413">CPoolRecord::restoreXml()</a>.</p>

</div>
</div>
<a id="adf9b9838cfe8166a236de6562f6dfcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9b9838cfe8166a236de6562f6dfcc3">&#9670;&nbsp;</a></span>saveXml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::saveXml </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save <b>this</b> container to stream. </p>
<p>All data-types, in dependency order, are written out to an XML stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="xml_8hh.html#a87634423f394bc832a51957ee6fc85c9">a_v_b()</a>, <a class="el" href="xml_8hh.html#aa12f4a381037faf4e90d1876bb44aa02">a_v_i()</a>, <a class="el" href="classTypeFactory.html#a180f8e14584ec0dba65dfc258f96e7ea">align</a>, <a class="el" href="classTypeFactory.html#ab143d57ae08682ff4fbc28a6ace5a54e">dependentOrder()</a>, <a class="el" href="classTypeFactory.html#a47fe3fddd79a56398f5d9dc7cd537bf3">enumsize</a>, <a class="el" href="classTypeFactory.html#a9b53c08b2845563e7b03253e0474559b">enumtype</a>, <a class="el" href="classTypeFactory.html#a29c926d1ab19f6cd2d5fa7df86eba78e">sizeOfInt</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fad189c0a53681ec74eeea1f56d08d741f">TYPE_ARRAY</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa4fcd4421533bb21c827865bdbac4fef9">TYPE_INT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa311715f465e358409d513be004f82b2f">TYPE_PTR</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa9001cd1bc103bb1d664228d46715f65c">TYPE_STRUCT</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#af760a127622d4cdd4b6b436122478cb5">Architecture::saveXml()</a>.</p>

</div>
</div>
<a id="a1caebbe3620eee3ba78427608b1126dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1caebbe3620eee3ba78427608b1126dd">&#9670;&nbsp;</a></span>saveXmlCoreTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::saveXmlCoreTypes </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save core types to stream. </p>
<p>Any data-type within this container marked as "core" will be written to an XML &lt;coretypes&gt; stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classDatatype.html#a33339824f1c50d4354952296070c3902">Datatype::saveXml()</a>, <a class="el" href="classTypeFactory.html#aed9d31778ed2c9ccc958ba9f52125de2">tree</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fad189c0a53681ec74eeea1f56d08d741f">TYPE_ARRAY</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa311715f465e358409d513be004f82b2f">TYPE_PTR</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa9001cd1bc103bb1d664228d46715f65c">TYPE_STRUCT</a>.</p>

<p class="reference">Referenced by <a class="el" href="classXmlArchitecture.html#abf5dd16b5343f89d2b165cf2206c7bf6">XmlArchitecture::saveXml()</a>, <a class="el" href="classRawBinaryArchitecture.html#a3aafb658662f5d6af564e22f5b35aafc">RawBinaryArchitecture::saveXml()</a>, and <a class="el" href="classBfdArchitecture.html#ac775d8894dd3abba1effafe22881a131">BfdArchitecture::saveXml()</a>.</p>

</div>
</div>
<a id="a7f142a54450d41bc12ca18fe06c6e1e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f142a54450d41bc12ca18fe06c6e1e0">&#9670;&nbsp;</a></span>setCoreType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::setCoreType </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a>&#160;</td>
          <td class="paramname"><em>meta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chartp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a core data-type. </p>
<p>Manually create a "base" core type. This currently must be called before any pointers or arrays are defined off of the type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the data-type name </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the data-type </td></tr>
    <tr><td class="paramname">meta</td><td>is the meta-type of the data-type </td></tr>
    <tr><td class="paramname">chartp</td><td>is true if a character type should be created </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classDatatype.html#abf874c38e872ed1e2c2c78736e288626a8efcece19aae42262429fbf59330a2c7">Datatype::coretype</a>, <a class="el" href="classDatatype.html#a82e59a9379488b5afdae69817c0955fb">Datatype::flags</a>, <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">getBase()</a>, <a class="el" href="classTypeFactory.html#af2a9fd247245e31f9eeeec29d245cfa2">getTypeChar()</a>, <a class="el" href="classTypeFactory.html#a47c3d70d9598d2b4ce3770593f6ce97e">getTypeCode()</a>, <a class="el" href="classTypeFactory.html#a7a15ff2da4b9476d4f2e9eeeb012fbc7">getTypeUnicode()</a>, <a class="el" href="classTypeFactory.html#ab7277908ef32101f172633ec00fbecb1">getTypeVoid()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa88922d1c65a64d2f39ebaba3411aa057">TYPE_CODE</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa84de340fe64164ed0dcf473aad846961">TYPE_VOID</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitectureGhidra.html#afdc4a7c905c401909628967b4b249ddc">ArchitectureGhidra::buildTypegrp()</a>, and <a class="el" href="classArchitecture.html#aaf041374ee649d2c0d8e95e450af5bf9">Architecture::buildTypegrp()</a>.</p>

</div>
</div>
<a id="a17cf58ac6b927a91b4f794a3347b2822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cf58ac6b927a91b4f794a3347b2822">&#9670;&nbsp;</a></span>setEnumValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeFactory::setEnumValues </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>namelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; uintb &gt; &amp;&#160;</td>
          <td class="paramname"><em>vallist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>assignlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypeEnum.html">TypeEnum</a> *&#160;</td>
          <td class="paramname"><em>te</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set named values for an enumeration. </p>
<p>Set the list of enumeration values and identifiers for a <a class="el" href="classTypeEnum.html" title="An enumerated Datatype object: an integer with named values.">TypeEnum</a> Fill in any values for any names that weren't explicitly assigned and check for duplicates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">namelist</td><td>is the list of names in the enumeration </td></tr>
    <tr><td class="paramname">vallist</td><td>is the corresponding list of values assigned to names in namelist </td></tr>
    <tr><td class="paramname">assignlist</td><td>is true if the corresponding name in namelist has an assigned value </td></tr>
    <tr><td class="paramname">te</td><td>is the enumeration object to modify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the modification is successful (no duplicate names) </dd></dl>

<p class="reference">References <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="classTypeEnum.html#a888839555ff7b768f371e794a979a8dc">TypeEnum::setNameMap()</a>, and <a class="el" href="classTypeFactory.html#aed9d31778ed2c9ccc958ba9f52125de2">tree</a>.</p>

</div>
</div>
<a id="a17480d8c1040602a1becb483e6c59652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17480d8c1040602a1becb483e6c59652">&#9670;&nbsp;</a></span>setFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeFactory::setFields </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structTypeField.html">TypeField</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypeStruct.html">TypeStruct</a> *&#160;</td>
          <td class="paramname"><em>ot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>fixedsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set fields on a <a class="el" href="classTypeStruct.html" title="A composite Datatype object: A &quot;structure&quot; with component &quot;fields&quot;.">TypeStruct</a>. </p>
<p>Make sure all the offsets are fully established then set fields of the structure If -fixedsize- is greater than 0, force the final structure to have that size </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>is the list of fields to set </td></tr>
    <tr><td class="paramname">ot</td><td>is the <a class="el" href="classTypeStruct.html" title="A composite Datatype object: A &quot;structure&quot; with component &quot;fields&quot;.">TypeStruct</a> object to modify </td></tr>
    <tr><td class="paramname">fixedsize</td><td>is 0 or the forced size of the structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if modification was successful </dd></dl>

<p class="reference">References <a class="el" href="classTypeFactory.html#a180f8e14584ec0dba65dfc258f96e7ea">align</a>, <a class="el" href="classTypeStruct.html#abf9d27b301d027a5fad874b1f8c93b8c">TypeStruct::setFields()</a>, <a class="el" href="classDatatype.html#a14476d90cd8993852b349b621876b292">Datatype::size</a>, <a class="el" href="classTypeFactory.html#aed9d31778ed2c9ccc958ba9f52125de2">tree</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa84de340fe64164ed0dcf473aad846961">TYPE_VOID</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTypeFactory.html#adefbb272df63d0e3bddd0195e52fd308">restoreXmlTypeNoRef()</a>.</p>

</div>
</div>
<a id="a6a2c74462f5a832e6233421bb6cb1beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2c74462f5a832e6233421bb6cb1beb">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::setName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the given types name. </p>
<p>This routine renames a <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object and fixes up cross-referencing </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>is the data-type to rename </td></tr>
    <tr><td class="paramname">n</td><td>is the new name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the renamed <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler.">Datatype</a> object </dd></dl>

<p class="reference">References <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>, <a class="el" href="classDatatype.html#a66d6613a73e69cd4665c90441c4613b3">Datatype::name</a>, <a class="el" href="classTypeFactory.html#a35525edc1bb4b769c3e9fbe48d8b642b">nametree</a>, and <a class="el" href="classTypeFactory.html#aed9d31778ed2c9ccc958ba9f52125de2">tree</a>.</p>

</div>
</div>
<a id="afae3189d62867e5358bcbb98e7723b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae3189d62867e5358bcbb98e7723b75">&#9670;&nbsp;</a></span>setupSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::setupSizes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derive some size information from <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a>. </p>
<p>Set up default values for size of "int", structure alignment, and enums. </p>

<p class="reference">References <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitecture.html#a20147b2a4be785c30ea29cc7d9278b42">Architecture::parseCompilerConfig()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="type_8hh.html">type.hh</a></li>
<li>type.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
