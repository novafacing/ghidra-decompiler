<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>decompiler: ScopeGhidra Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classScopeGhidra-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ScopeGhidra Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An implementation of the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> interface by querying a Ghidra client for <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> information.  
 <a href="classScopeGhidra.html#details">More...</a></p>

<p><code>#include &lt;database_ghidra.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ScopeGhidra:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classScopeGhidra.png" usemap="#ScopeGhidra_map" alt=""/>
  <map id="ScopeGhidra_map" name="ScopeGhidra_map">
<area href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope." alt="Scope" shape="rect" coords="0,0,86,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a715046c5b708da35b3547780a3226713"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a715046c5b708da35b3547780a3226713">ScopeGhidra</a> (<a class="el" href="classArchitectureGhidra.html">ArchitectureGhidra</a> *g)</td></tr>
<tr class="memdesc:a715046c5b708da35b3547780a3226713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classScopeGhidra.html#a715046c5b708da35b3547780a3226713">More...</a><br /></td></tr>
<tr class="separator:a715046c5b708da35b3547780a3226713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912898628da7cab6ec50207b9d9bd418"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a912898628da7cab6ec50207b9d9bd418">lockDefaultProperties</a> (void)</td></tr>
<tr class="memdesc:a912898628da7cab6ec50207b9d9bd418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock in the default state of the boolean property map.  <a href="classScopeGhidra.html#a912898628da7cab6ec50207b9d9bd418">More...</a><br /></td></tr>
<tr class="separator:a912898628da7cab6ec50207b9d9bd418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebfecc6211081f8f2411c006cc867de"><td class="memItemLeft" align="right" valign="top"><a id="a2ebfecc6211081f8f2411c006cc867de"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a2ebfecc6211081f8f2411c006cc867de">clear</a> (void)</td></tr>
<tr class="memdesc:a2ebfecc6211081f8f2411c006cc867de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all symbols from <b>this</b> scope. <br /></td></tr>
<tr class="separator:a2ebfecc6211081f8f2411c006cc867de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb80f5f1b2391d5865f3c75ec1e03644"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#abb80f5f1b2391d5865f3c75ec1e03644">addSymbol</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, <a class="el" href="classDatatype.html">Datatype</a> *ct, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint)</td></tr>
<tr class="memdesc:abb80f5f1b2391d5865f3c75ec1e03644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> to <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>, given a name, data-type, and a single mapping.  <a href="classScopeGhidra.html#abb80f5f1b2391d5865f3c75ec1e03644">More...</a><br /></td></tr>
<tr class="separator:abb80f5f1b2391d5865f3c75ec1e03644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8ab1c82c0d5101e7e2f5cdd5cc8268"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a4a8ab1c82c0d5101e7e2f5cdd5cc8268">buildVariableName</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;pc, <a class="el" href="classDatatype.html">Datatype</a> *ct, int4 &amp;index, uint4 flags) const</td></tr>
<tr class="memdesc:a4a8ab1c82c0d5101e7e2f5cdd5cc8268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an address and data-type, build a suitable generic symbol name.  <a href="classScopeGhidra.html#a4a8ab1c82c0d5101e7e2f5cdd5cc8268">More...</a><br /></td></tr>
<tr class="separator:a4a8ab1c82c0d5101e7e2f5cdd5cc8268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f55a3495b08a4caafaaeb5c1cf8bed"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a25f55a3495b08a4caafaaeb5c1cf8bed">buildUndefinedName</a> (void) const</td></tr>
<tr class="memdesc:a25f55a3495b08a4caafaaeb5c1cf8bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formal <b>undefined</b> name, used internally when a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is not given a name.  <a href="classScopeGhidra.html#a25f55a3495b08a4caafaaeb5c1cf8bed">More...</a><br /></td></tr>
<tr class="separator:a25f55a3495b08a4caafaaeb5c1cf8bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de7736cd5930af6bdcd29b4673ab037"><td class="memItemLeft" align="right" valign="top"><a id="a8de7736cd5930af6bdcd29b4673ab037"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a8de7736cd5930af6bdcd29b4673ab037">setAttribute</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, uint4 attr)</td></tr>
<tr class="memdesc:a8de7736cd5930af6bdcd29b4673ab037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boolean <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> properties on a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>. <br /></td></tr>
<tr class="separator:a8de7736cd5930af6bdcd29b4673ab037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f1b5f561b339b03471d39349d108dd"><td class="memItemLeft" align="right" valign="top"><a id="a82f1b5f561b339b03471d39349d108dd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a82f1b5f561b339b03471d39349d108dd">clearAttribute</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, uint4 attr)</td></tr>
<tr class="memdesc:a82f1b5f561b339b03471d39349d108dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear boolean <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> properties on a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>. <br /></td></tr>
<tr class="separator:a82f1b5f561b339b03471d39349d108dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74dd0dfc3b70347a2ed19688adfd155"><td class="memItemLeft" align="right" valign="top"><a id="ae74dd0dfc3b70347a2ed19688adfd155"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#ae74dd0dfc3b70347a2ed19688adfd155">setDisplayFormat</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, uint4 attr)</td></tr>
<tr class="memdesc:ae74dd0dfc3b70347a2ed19688adfd155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the display format for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>. <br /></td></tr>
<tr class="separator:ae74dd0dfc3b70347a2ed19688adfd155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444989f8c48787af5df27c2a8b234fd3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a444989f8c48787af5df27c2a8b234fd3">findAddr</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const</td></tr>
<tr class="memdesc:a444989f8c48787af5df27c2a8b234fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> at a given address and <b>usepoint</b>.  <a href="classScopeGhidra.html#a444989f8c48787af5df27c2a8b234fd3">More...</a><br /></td></tr>
<tr class="separator:a444989f8c48787af5df27c2a8b234fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5b1b303d3d6adf93822224aa7bd19f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a6b5b1b303d3d6adf93822224aa7bd19f">findContainer</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const</td></tr>
<tr class="memdesc:a6b5b1b303d3d6adf93822224aa7bd19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the smallest <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> containing the given memory range.  <a href="classScopeGhidra.html#a6b5b1b303d3d6adf93822224aa7bd19f">More...</a><br /></td></tr>
<tr class="separator:a6b5b1b303d3d6adf93822224aa7bd19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9d46c27a627260abfe9cce2724267b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#ace9d46c27a627260abfe9cce2724267b">findClosestFit</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const</td></tr>
<tr class="memdesc:ace9d46c27a627260abfe9cce2724267b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> which is the closest fit to the given memory range.  <a href="classScopeGhidra.html#ace9d46c27a627260abfe9cce2724267b">More...</a><br /></td></tr>
<tr class="separator:ace9d46c27a627260abfe9cce2724267b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc17a80d5b2bd69f7900be5b55a382a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a8bc17a80d5b2bd69f7900be5b55a382a">findFunction</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:a8bc17a80d5b2bd69f7900be5b55a382a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the function starting at the given address.  <a href="classScopeGhidra.html#a8bc17a80d5b2bd69f7900be5b55a382a">More...</a><br /></td></tr>
<tr class="separator:a8bc17a80d5b2bd69f7900be5b55a382a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de8e7d9e97f48516f8bb7b5edd4dfcd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a0de8e7d9e97f48516f8bb7b5edd4dfcd">findExternalRef</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:a0de8e7d9e97f48516f8bb7b5edd4dfcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an <em>external</em> <em>reference</em> at the given address.  <a href="classScopeGhidra.html#a0de8e7d9e97f48516f8bb7b5edd4dfcd">More...</a><br /></td></tr>
<tr class="separator:a0de8e7d9e97f48516f8bb7b5edd4dfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81328af0bc4954612d1e107e592a246a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLabSymbol.html">LabSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a81328af0bc4954612d1e107e592a246a">findCodeLabel</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:a81328af0bc4954612d1e107e592a246a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a label <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> at the given address.  <a href="classScopeGhidra.html#a81328af0bc4954612d1e107e592a246a">More...</a><br /></td></tr>
<tr class="separator:a81328af0bc4954612d1e107e592a246a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb2e6de63033bb78e6c4168c8e25227"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#afdb2e6de63033bb78e6c4168c8e25227">resolveExternalRefFunction</a> (<a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> *sym) const</td></tr>
<tr class="memdesc:afdb2e6de63033bb78e6c4168c8e25227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <em>external</em> <em>reference</em> to the referenced function.  <a href="classScopeGhidra.html#afdb2e6de63033bb78e6c4168c8e25227">More...</a><br /></td></tr>
<tr class="separator:afdb2e6de63033bb78e6c4168c8e25227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb59d45c8fa404fe023e054b255d5a3d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#afb59d45c8fa404fe023e054b255d5a3d">findOverlap</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const</td></tr>
<tr class="memdesc:afb59d45c8fa404fe023e054b255d5a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> overlapping the given memory range.  <a href="classScopeGhidra.html#afb59d45c8fa404fe023e054b255d5a3d">More...</a><br /></td></tr>
<tr class="separator:afb59d45c8fa404fe023e054b255d5a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26072ceb4215a022050d12b9487e3e87"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a26072ceb4215a022050d12b9487e3e87">findByName</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; &amp;res) const</td></tr>
<tr class="memdesc:a26072ceb4215a022050d12b9487e3e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> by name within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScopeGhidra.html#a26072ceb4215a022050d12b9487e3e87">More...</a><br /></td></tr>
<tr class="separator:a26072ceb4215a022050d12b9487e3e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f59b75cfddbd3537c4e2087ce0f22aa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a0f59b75cfddbd3537c4e2087ce0f22aa">isNameUsed</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>) const</td></tr>
<tr class="memdesc:a0f59b75cfddbd3537c4e2087ce0f22aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given name is used within <b>this</b> scope.  <a href="classScopeGhidra.html#a0f59b75cfddbd3537c4e2087ce0f22aa">More...</a><br /></td></tr>
<tr class="separator:a0f59b75cfddbd3537c4e2087ce0f22aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17a63dadd4390989eaf9f20b8cbf173"><td class="memItemLeft" align="right" valign="top"><a id="ad17a63dadd4390989eaf9f20b8cbf173"></a>
virtual <a class="el" href="classMapIterator.html">MapIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#ad17a63dadd4390989eaf9f20b8cbf173">begin</a> (void) const</td></tr>
<tr class="memdesc:ad17a63dadd4390989eaf9f20b8cbf173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beginning iterator to mapped SymbolEntrys. <br /></td></tr>
<tr class="separator:ad17a63dadd4390989eaf9f20b8cbf173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf4b95214a2232a84e36ea5bfdd368c"><td class="memItemLeft" align="right" valign="top"><a id="a7cf4b95214a2232a84e36ea5bfdd368c"></a>
virtual <a class="el" href="classMapIterator.html">MapIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a7cf4b95214a2232a84e36ea5bfdd368c">end</a> (void) const</td></tr>
<tr class="memdesc:a7cf4b95214a2232a84e36ea5bfdd368c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending iterator to mapped SymbolEntrys. <br /></td></tr>
<tr class="separator:a7cf4b95214a2232a84e36ea5bfdd368c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5b42e5c99ea0581c4819b550c2fc27"><td class="memItemLeft" align="right" valign="top"><a id="a4f5b42e5c99ea0581c4819b550c2fc27"></a>
virtual list&lt; <a class="el" href="classSymbolEntry.html">SymbolEntry</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a4f5b42e5c99ea0581c4819b550c2fc27">beginDynamic</a> (void) const</td></tr>
<tr class="memdesc:a4f5b42e5c99ea0581c4819b550c2fc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beginning iterator to dynamic SymbolEntrys. <br /></td></tr>
<tr class="separator:a4f5b42e5c99ea0581c4819b550c2fc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb53b6abc143a87ab2ad12337d9d571"><td class="memItemLeft" align="right" valign="top"><a id="abbb53b6abc143a87ab2ad12337d9d571"></a>
virtual list&lt; <a class="el" href="classSymbolEntry.html">SymbolEntry</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#abbb53b6abc143a87ab2ad12337d9d571">endDynamic</a> (void) const</td></tr>
<tr class="memdesc:abbb53b6abc143a87ab2ad12337d9d571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending iterator to dynamic SymbolEntrys. <br /></td></tr>
<tr class="separator:abbb53b6abc143a87ab2ad12337d9d571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c510456a060e6bbfb503f7e861afd2e"><td class="memItemLeft" align="right" valign="top"><a id="a9c510456a060e6bbfb503f7e861afd2e"></a>
virtual list&lt; <a class="el" href="classSymbolEntry.html">SymbolEntry</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a9c510456a060e6bbfb503f7e861afd2e">beginDynamic</a> (void)</td></tr>
<tr class="memdesc:a9c510456a060e6bbfb503f7e861afd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beginning iterator to dynamic SymbolEntrys. <br /></td></tr>
<tr class="separator:a9c510456a060e6bbfb503f7e861afd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb947fec06dcffbf611e30686a37657"><td class="memItemLeft" align="right" valign="top"><a id="abeb947fec06dcffbf611e30686a37657"></a>
virtual list&lt; <a class="el" href="classSymbolEntry.html">SymbolEntry</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#abeb947fec06dcffbf611e30686a37657">endDynamic</a> (void)</td></tr>
<tr class="memdesc:abeb947fec06dcffbf611e30686a37657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending iterator to dynamic SymbolEntrys. <br /></td></tr>
<tr class="separator:abeb947fec06dcffbf611e30686a37657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c52834934353c6d92f5ae459d08e2ad"><td class="memItemLeft" align="right" valign="top"><a id="a7c52834934353c6d92f5ae459d08e2ad"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a7c52834934353c6d92f5ae459d08e2ad">clearCategory</a> (int4 cat)</td></tr>
<tr class="memdesc:a7c52834934353c6d92f5ae459d08e2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all symbols of the given category from <b>this</b> scope. <br /></td></tr>
<tr class="separator:a7c52834934353c6d92f5ae459d08e2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8f2ce3c7783b86d375bc6d702c461c"><td class="memItemLeft" align="right" valign="top"><a id="a1c8f2ce3c7783b86d375bc6d702c461c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a1c8f2ce3c7783b86d375bc6d702c461c">clearUnlockedCategory</a> (int4 cat)</td></tr>
<tr class="memdesc:a1c8f2ce3c7783b86d375bc6d702c461c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear unlocked symbols of the given category from <b>this</b> scope. <br /></td></tr>
<tr class="separator:a1c8f2ce3c7783b86d375bc6d702c461c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e0189b87b6c66641c7de9baf118457"><td class="memItemLeft" align="right" valign="top"><a id="a32e0189b87b6c66641c7de9baf118457"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a32e0189b87b6c66641c7de9baf118457">clearUnlocked</a> (void)</td></tr>
<tr class="memdesc:a32e0189b87b6c66641c7de9baf118457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all unlocked symbols from <b>this</b> scope. <br /></td></tr>
<tr class="separator:a32e0189b87b6c66641c7de9baf118457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de93cdd506ae1490d939b957738f656"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a0de93cdd506ae1490d939b957738f656">restrictScope</a> (<a class="el" href="classFuncdata.html">Funcdata</a> *f)</td></tr>
<tr class="memdesc:a0de93cdd506ae1490d939b957738f656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <b>this</b> to a local <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScopeGhidra.html#a0de93cdd506ae1490d939b957738f656">More...</a><br /></td></tr>
<tr class="separator:a0de93cdd506ae1490d939b957738f656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06e4f5d4391dfb6bff788e93f9baa9d"><td class="memItemLeft" align="right" valign="top"><a id="af06e4f5d4391dfb6bff788e93f9baa9d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#af06e4f5d4391dfb6bff788e93f9baa9d">removeSymbolMappings</a> (<a class="el" href="classSymbol.html">Symbol</a> *symbol)</td></tr>
<tr class="memdesc:af06e4f5d4391dfb6bff788e93f9baa9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all SymbolEntrys from the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>. <br /></td></tr>
<tr class="separator:af06e4f5d4391dfb6bff788e93f9baa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54aaf6bcabc70b6b705fd1b49ecd720"><td class="memItemLeft" align="right" valign="top"><a id="af54aaf6bcabc70b6b705fd1b49ecd720"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#af54aaf6bcabc70b6b705fd1b49ecd720">removeSymbol</a> (<a class="el" href="classSymbol.html">Symbol</a> *symbol)</td></tr>
<tr class="memdesc:af54aaf6bcabc70b6b705fd1b49ecd720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> from <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. <br /></td></tr>
<tr class="separator:af54aaf6bcabc70b6b705fd1b49ecd720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6476f25701e4bc419644bab003d5513"><td class="memItemLeft" align="right" valign="top"><a id="af6476f25701e4bc419644bab003d5513"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#af6476f25701e4bc419644bab003d5513">renameSymbol</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, const string &amp;newname)</td></tr>
<tr class="memdesc:af6476f25701e4bc419644bab003d5513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. <br /></td></tr>
<tr class="separator:af6476f25701e4bc419644bab003d5513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086054a08a1916c410fa10b3e8afca76"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a086054a08a1916c410fa10b3e8afca76">retypeSymbol</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, <a class="el" href="classDatatype.html">Datatype</a> *ct)</td></tr>
<tr class="memdesc:a086054a08a1916c410fa10b3e8afca76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the data-type of a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScopeGhidra.html#a086054a08a1916c410fa10b3e8afca76">More...</a><br /></td></tr>
<tr class="separator:a086054a08a1916c410fa10b3e8afca76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458977d1e0a9826d5cf7bca487ecf327"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a458977d1e0a9826d5cf7bca487ecf327">makeNameUnique</a> (const string &amp;nm) const</td></tr>
<tr class="memdesc:a458977d1e0a9826d5cf7bca487ecf327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a version of the given symbol name that won't collide with other names in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScopeGhidra.html#a458977d1e0a9826d5cf7bca487ecf327">More...</a><br /></td></tr>
<tr class="separator:a458977d1e0a9826d5cf7bca487ecf327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb73fa9a07b114dfa8994423f2aae170"><td class="memItemLeft" align="right" valign="top"><a id="abb73fa9a07b114dfa8994423f2aae170"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#abb73fa9a07b114dfa8994423f2aae170">saveXml</a> (ostream &amp;s) const</td></tr>
<tr class="memdesc:abb73fa9a07b114dfa8994423f2aae170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out <b>this</b> as a &lt;scope&gt; XML tag. <br /></td></tr>
<tr class="separator:abb73fa9a07b114dfa8994423f2aae170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6efdd1eb3b3189dc6020a0440128be3"><td class="memItemLeft" align="right" valign="top"><a id="ad6efdd1eb3b3189dc6020a0440128be3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#ad6efdd1eb3b3189dc6020a0440128be3">restoreXml</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:ad6efdd1eb3b3189dc6020a0440128be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> from a &lt;scope&gt; XML tag. <br /></td></tr>
<tr class="separator:ad6efdd1eb3b3189dc6020a0440128be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3865ed7c8917f5f1594f4dd63ade7a"><td class="memItemLeft" align="right" valign="top"><a id="a6d3865ed7c8917f5f1594f4dd63ade7a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a6d3865ed7c8917f5f1594f4dd63ade7a">printEntries</a> (ostream &amp;s) const</td></tr>
<tr class="memdesc:a6d3865ed7c8917f5f1594f4dd63ade7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a description of all <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> objects to a stream. <br /></td></tr>
<tr class="separator:a6d3865ed7c8917f5f1594f4dd63ade7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6c26ca7dd639659313e8fe86d798c8"><td class="memItemLeft" align="right" valign="top">virtual int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a4c6c26ca7dd639659313e8fe86d798c8">getCategorySize</a> (int4 cat) const</td></tr>
<tr class="memdesc:a4c6c26ca7dd639659313e8fe86d798c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of Symbols in the given category.  <a href="classScopeGhidra.html#a4c6c26ca7dd639659313e8fe86d798c8">More...</a><br /></td></tr>
<tr class="separator:a4c6c26ca7dd639659313e8fe86d798c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b3e331ed319e74af4a5927f7e70660"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#aa3b3e331ed319e74af4a5927f7e70660">getCategorySymbol</a> (int4 cat, int4 ind) const</td></tr>
<tr class="memdesc:aa3b3e331ed319e74af4a5927f7e70660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> by index within a specific <em>category</em>.  <a href="classScopeGhidra.html#aa3b3e331ed319e74af4a5927f7e70660">More...</a><br /></td></tr>
<tr class="separator:aa3b3e331ed319e74af4a5927f7e70660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafecf1b8615812bdbd8efeca910594a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#aafecf1b8615812bdbd8efeca910594a2">setCategory</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, int4 cat, int4 ind)</td></tr>
<tr class="memdesc:aafecf1b8615812bdbd8efeca910594a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <em>category</em> and index for the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>.  <a href="classScopeGhidra.html#aafecf1b8615812bdbd8efeca910594a2">More...</a><br /></td></tr>
<tr class="separator:aafecf1b8615812bdbd8efeca910594a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classScope"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classScope')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classScope.html">Scope</a></td></tr>
<tr class="memitem:a203cfd8813735894486ed2c57f378f1e inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a id="a203cfd8813735894486ed2c57f378f1e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a203cfd8813735894486ed2c57f378f1e">Scope</a> (const string &amp;nm, <a class="el" href="classArchitecture.html">Architecture</a> *g)</td></tr>
<tr class="memdesc:a203cfd8813735894486ed2c57f378f1e inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty scope, given a name and <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a>. <br /></td></tr>
<tr class="separator:a203cfd8813735894486ed2c57f378f1e inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571dad0bea947a7c5c1cfea083733963 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a id="a571dad0bea947a7c5c1cfea083733963"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a571dad0bea947a7c5c1cfea083733963">~Scope</a> (void)</td></tr>
<tr class="memdesc:a571dad0bea947a7c5c1cfea083733963 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a571dad0bea947a7c5c1cfea083733963 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcaec6d7678dabe548680747d843a52 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a4fcaec6d7678dabe548680747d843a52">inScope</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const</td></tr>
<tr class="memdesc:a4fcaec6d7678dabe548680747d843a52 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if the given range is owned by <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScope.html#a4fcaec6d7678dabe548680747d843a52">More...</a><br /></td></tr>
<tr class="separator:a4fcaec6d7678dabe548680747d843a52 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d2e4eeed5fbc77e0477936f60cfde5 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ae7d2e4eeed5fbc77e0477936f60cfde5">queryByName</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; &amp;res) const</td></tr>
<tr class="memdesc:ae7d2e4eeed5fbc77e0477936f60cfde5 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up symbols by name.  <a href="classScope.html#ae7d2e4eeed5fbc77e0477936f60cfde5">More...</a><br /></td></tr>
<tr class="separator:ae7d2e4eeed5fbc77e0477936f60cfde5 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9b49c7da91626fcb1cfacda5236991 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a6f9b49c7da91626fcb1cfacda5236991">queryFunction</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>) const</td></tr>
<tr class="memdesc:a6f9b49c7da91626fcb1cfacda5236991 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up a function by name.  <a href="classScope.html#a6f9b49c7da91626fcb1cfacda5236991">More...</a><br /></td></tr>
<tr class="separator:a6f9b49c7da91626fcb1cfacda5236991 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc95566b073624a0d12231a8e70bc5ce inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#afc95566b073624a0d12231a8e70bc5ce">queryByAddr</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const</td></tr>
<tr class="memdesc:afc95566b073624a0d12231a8e70bc5ce inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> with matching address.  <a href="classScope.html#afc95566b073624a0d12231a8e70bc5ce">More...</a><br /></td></tr>
<tr class="separator:afc95566b073624a0d12231a8e70bc5ce inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50dcbdbad011571fc24398781a2bab2 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#af50dcbdbad011571fc24398781a2bab2">queryContainer</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const</td></tr>
<tr class="memdesc:af50dcbdbad011571fc24398781a2bab2 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the smallest containing <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>.  <a href="classScope.html#af50dcbdbad011571fc24398781a2bab2">More...</a><br /></td></tr>
<tr class="separator:af50dcbdbad011571fc24398781a2bab2 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8c2c2302eba2666e319a4c18a67d51 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a1b8c2c2302eba2666e319a4c18a67d51">queryProperties</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint, uint4 &amp;flags) const</td></tr>
<tr class="memdesc:a1b8c2c2302eba2666e319a4c18a67d51 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> or properties at the given address.  <a href="classScope.html#a1b8c2c2302eba2666e319a4c18a67d51">More...</a><br /></td></tr>
<tr class="separator:a1b8c2c2302eba2666e319a4c18a67d51 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6c56240bdb6df2d2670077cf5e08ca inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a5d6c56240bdb6df2d2670077cf5e08ca">queryFunction</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:a5d6c56240bdb6df2d2670077cf5e08ca inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up a function by address.  <a href="classScope.html#a5d6c56240bdb6df2d2670077cf5e08ca">More...</a><br /></td></tr>
<tr class="separator:a5d6c56240bdb6df2d2670077cf5e08ca inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7850e4fd00c5dcc9299e646d13aae3dc inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a7850e4fd00c5dcc9299e646d13aae3dc">queryExternalRefFunction</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:a7850e4fd00c5dcc9299e646d13aae3dc inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up a function thru an <em>external</em> <em>reference</em>.  <a href="classScope.html#a7850e4fd00c5dcc9299e646d13aae3dc">More...</a><br /></td></tr>
<tr class="separator:a7850e4fd00c5dcc9299e646d13aae3dc inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88982df383433525505723b19b8aaa13 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLabSymbol.html">LabSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a88982df383433525505723b19b8aaa13">queryCodeLabel</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:a88982df383433525505723b19b8aaa13 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up a code label by address.  <a href="classScope.html#a88982df383433525505723b19b8aaa13">More...</a><br /></td></tr>
<tr class="separator:a88982df383433525505723b19b8aaa13 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b252ca0ce3155c06fe0cee6eae9265b inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a3b252ca0ce3155c06fe0cee6eae9265b">resolveScope</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>) const</td></tr>
<tr class="memdesc:a3b252ca0ce3155c06fe0cee6eae9265b inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> of <b>this</b>.  <a href="classScope.html#a3b252ca0ce3155c06fe0cee6eae9265b">More...</a><br /></td></tr>
<tr class="separator:a3b252ca0ce3155c06fe0cee6eae9265b inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef5f179b42a9696fd077dbc7144ecc2 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aaef5f179b42a9696fd077dbc7144ecc2">discoverScope</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 sz, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint)</td></tr>
<tr class="memdesc:aaef5f179b42a9696fd077dbc7144ecc2 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the owning <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> of a given memory range.  <a href="classScope.html#aaef5f179b42a9696fd077dbc7144ecc2">More...</a><br /></td></tr>
<tr class="separator:aaef5f179b42a9696fd077dbc7144ecc2 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c1f312cf9173871baa1b2fad29bb58 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a68c1f312cf9173871baa1b2fad29bb58">saveXmlRecursive</a> (ostream &amp;s, bool onlyGlobal) const</td></tr>
<tr class="memdesc:a68c1f312cf9173871baa1b2fad29bb58 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save all contained scopes as an XML stream.  <a href="classScope.html#a68c1f312cf9173871baa1b2fad29bb58">More...</a><br /></td></tr>
<tr class="separator:a68c1f312cf9173871baa1b2fad29bb58 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a05df4f8df1764859bec8372d64b1ee inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a0a05df4f8df1764859bec8372d64b1ee">overrideSizeLockType</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, <a class="el" href="classDatatype.html">Datatype</a> *ct)</td></tr>
<tr class="memdesc:a0a05df4f8df1764859bec8372d64b1ee inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the data-type of a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> that is <em>sizelocked</em>.  <a href="classScope.html#a0a05df4f8df1764859bec8372d64b1ee">More...</a><br /></td></tr>
<tr class="separator:a0a05df4f8df1764859bec8372d64b1ee inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af52229967e3a507a5367e14a298142 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a4af52229967e3a507a5367e14a298142">resetSizeLockType</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym)</td></tr>
<tr class="memdesc:a4af52229967e3a507a5367e14a298142 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>'s <em>size-locked</em> data-type.  <a href="classScope.html#a4af52229967e3a507a5367e14a298142">More...</a><br /></td></tr>
<tr class="separator:a4af52229967e3a507a5367e14a298142 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abf50d101c65af19281910dac990ca5 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a1abf50d101c65af19281910dac990ca5">isSubScope</a> (const <a class="el" href="classScope.html">Scope</a> *scp) const</td></tr>
<tr class="memdesc:a1abf50d101c65af19281910dac990ca5 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a sub-scope of the given <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScope.html#a1abf50d101c65af19281910dac990ca5">More...</a><br /></td></tr>
<tr class="separator:a1abf50d101c65af19281910dac990ca5 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0c1eab94766936cb73686e39b2ab6d inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a id="a6e0c1eab94766936cb73686e39b2ab6d"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a6e0c1eab94766936cb73686e39b2ab6d">getFullName</a> (void) const</td></tr>
<tr class="memdesc:a6e0c1eab94766936cb73686e39b2ab6d inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the full name of <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. <br /></td></tr>
<tr class="separator:a6e0c1eab94766936cb73686e39b2ab6d inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0befa1009748f0af39a1e6b7704b7b inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a0d0befa1009748f0af39a1e6b7704b7b">getNameSegments</a> (vector&lt; string &gt; &amp;vec) const</td></tr>
<tr class="memdesc:a0d0befa1009748f0af39a1e6b7704b7b inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fullname of <b>this</b> in segments.  <a href="classScope.html#a0d0befa1009748f0af39a1e6b7704b7b">More...</a><br /></td></tr>
<tr class="separator:a0d0befa1009748f0af39a1e6b7704b7b inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea425f0c244ce263988024ec0eb537ae inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aea425f0c244ce263988024ec0eb537ae">getScopePath</a> (vector&lt; <a class="el" href="classScope.html">Scope</a> * &gt; &amp;vec) const</td></tr>
<tr class="memdesc:aea425f0c244ce263988024ec0eb537ae inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ordered list of parent scopes to <b>this</b>.  <a href="classScope.html#aea425f0c244ce263988024ec0eb537ae">More...</a><br /></td></tr>
<tr class="separator:aea425f0c244ce263988024ec0eb537ae inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84da27186e9a57fa4c8ae1f6ca02744 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ad84da27186e9a57fa4c8ae1f6ca02744">isNameUsed</a> (const string &amp;nm, const <a class="el" href="classScope.html">Scope</a> *op2) const</td></tr>
<tr class="memdesc:ad84da27186e9a57fa4c8ae1f6ca02744 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given name in use within given scope path.  <a href="classScope.html#ad84da27186e9a57fa4c8ae1f6ca02744">More...</a><br /></td></tr>
<tr class="separator:ad84da27186e9a57fa4c8ae1f6ca02744 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab269032369c349fe61278304791e0130 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ab269032369c349fe61278304791e0130">findDistinguishingScope</a> (const <a class="el" href="classScope.html">Scope</a> *op2) const</td></tr>
<tr class="memdesc:ab269032369c349fe61278304791e0130 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first ancestor of <b>this</b> not shared by given scope.  <a href="classScope.html#ab269032369c349fe61278304791e0130">More...</a><br /></td></tr>
<tr class="separator:ab269032369c349fe61278304791e0130 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e7adcd07f0dbd9cf1777e2b3be9fe2 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a96e7adcd07f0dbd9cf1777e2b3be9fe2">addSymbol</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, <a class="el" href="classDatatype.html">Datatype</a> *ct)</td></tr>
<tr class="memdesc:a96e7adcd07f0dbd9cf1777e2b3be9fe2 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> <em>without</em> mapping it to an address.  <a href="classScope.html#a96e7adcd07f0dbd9cf1777e2b3be9fe2">More...</a><br /></td></tr>
<tr class="separator:a96e7adcd07f0dbd9cf1777e2b3be9fe2 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a0309ce54c25e56871edbfdfe25675 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a03a0309ce54c25e56871edbfdfe25675">addMapPoint</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint)</td></tr>
<tr class="memdesc:a03a0309ce54c25e56871edbfdfe25675 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> to a specific address.  <a href="classScope.html#a03a0309ce54c25e56871edbfdfe25675">More...</a><br /></td></tr>
<tr class="separator:a03a0309ce54c25e56871edbfdfe25675 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421f1b66be24bd5a20c77761e7a51268 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a421f1b66be24bd5a20c77761e7a51268">addMapSym</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a421f1b66be24bd5a20c77761e7a51268 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a mapped <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> from a &lt;mapsym&gt; XML tag.  <a href="classScope.html#a421f1b66be24bd5a20c77761e7a51268">More...</a><br /></td></tr>
<tr class="separator:a421f1b66be24bd5a20c77761e7a51268 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7f8bc9f073a957d43298394cac0678 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFunctionSymbol.html">FunctionSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a8f7f8bc9f073a957d43298394cac0678">addFunction</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const string &amp;nm)</td></tr>
<tr class="memdesc:a8f7f8bc9f073a957d43298394cac0678 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a function <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> at the given address in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScope.html#a8f7f8bc9f073a957d43298394cac0678">More...</a><br /></td></tr>
<tr class="separator:a8f7f8bc9f073a957d43298394cac0678 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648715fd4a06419df21ecdc060ff2911 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a648715fd4a06419df21ecdc060ff2911">addExternalRef</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;refaddr, const string &amp;nm)</td></tr>
<tr class="separator:a648715fd4a06419df21ecdc060ff2911 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcaf595e4437d91af6a243ef0d49640 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLabSymbol.html">LabSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a4dcaf595e4437d91af6a243ef0d49640">addCodeLabel</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const string &amp;nm)</td></tr>
<tr class="memdesc:a4dcaf595e4437d91af6a243ef0d49640 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a code label at the given address in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScope.html#a4dcaf595e4437d91af6a243ef0d49640">More...</a><br /></td></tr>
<tr class="separator:a4dcaf595e4437d91af6a243ef0d49640 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42668b79a23d2e4e67f54e2185a2b58 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#af42668b79a23d2e4e67f54e2185a2b58">addDynamicSymbol</a> (const string &amp;nm, <a class="el" href="classDatatype.html">Datatype</a> *ct, const <a class="el" href="classAddress.html">Address</a> &amp;caddr, uint8 hash)</td></tr>
<tr class="memdesc:af42668b79a23d2e4e67f54e2185a2b58 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dynamically mapped <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> attached to a specific data-flow.  <a href="classScope.html#af42668b79a23d2e4e67f54e2185a2b58">More...</a><br /></td></tr>
<tr class="separator:af42668b79a23d2e4e67f54e2185a2b58 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7dbb309986d8622ec0721f7a80bda1 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a1b7dbb309986d8622ec0721f7a80bda1">buildDefaultName</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, int4 &amp;base, <a class="el" href="classVarnode.html">Varnode</a> *vn) const</td></tr>
<tr class="memdesc:a1b7dbb309986d8622ec0721f7a80bda1 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a default name for the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>.  <a href="classScope.html#a1b7dbb309986d8622ec0721f7a80bda1">More...</a><br /></td></tr>
<tr class="separator:a1b7dbb309986d8622ec0721f7a80bda1 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6645d4ce07bea82322ac366b8c6168 inherit pub_methods_classScope"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a7b6645d4ce07bea82322ac366b8c6168">isReadOnly</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const</td></tr>
<tr class="memdesc:a7b6645d4ce07bea82322ac366b8c6168 inherit pub_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given memory range marked as <em>read-only</em>.  <a href="classScope.html#a7b6645d4ce07bea82322ac366b8c6168">More...</a><br /></td></tr>
<tr class="separator:a7b6645d4ce07bea82322ac366b8c6168 inherit pub_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3f1694263c1bbb543c387b4c182872b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a3f1694263c1bbb543c387b4c182872b0">dump2Cache</a> (<a class="el" href="classDocument.html">Document</a> *doc) const</td></tr>
<tr class="memdesc:a3f1694263c1bbb543c387b4c182872b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a response into the cache.  <a href="classScopeGhidra.html#a3f1694263c1bbb543c387b4c182872b0">More...</a><br /></td></tr>
<tr class="separator:a3f1694263c1bbb543c387b4c182872b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2def877a64531dcebbf852328053c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a4b2def877a64531dcebbf852328053c9">removeQuery</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:a4b2def877a64531dcebbf852328053c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a query that missed the cache.  <a href="classScopeGhidra.html#a4b2def877a64531dcebbf852328053c9">More...</a><br /></td></tr>
<tr class="separator:a4b2def877a64531dcebbf852328053c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c4a843ad067fe2ec612a37d2b76d49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a91c4a843ad067fe2ec612a37d2b76d49">processHole</a> (const <a class="el" href="classElement.html">Element</a> *el) const</td></tr>
<tr class="memdesc:a91c4a843ad067fe2ec612a37d2b76d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a response describing a hole.  <a href="classScopeGhidra.html#a91c4a843ad067fe2ec612a37d2b76d49">More...</a><br /></td></tr>
<tr class="separator:a91c4a843ad067fe2ec612a37d2b76d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a3cdb0e8edd44d9ae61b0295a942dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a68a3cdb0e8edd44d9ae61b0295a942dc">createNewScope</a> (const string &amp;nm, <a class="el" href="classScope.html">Scope</a> *par) const</td></tr>
<tr class="memdesc:a68a3cdb0e8edd44d9ae61b0295a942dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global <em>namespace</em> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScopeGhidra.html#a68a3cdb0e8edd44d9ae61b0295a942dc">More...</a><br /></td></tr>
<tr class="separator:a68a3cdb0e8edd44d9ae61b0295a942dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a78e5e6659762cae118d3601d3a372d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a7a78e5e6659762cae118d3601d3a372d">reresolveScope</a> (const vector&lt; string &gt; &amp;path) const</td></tr>
<tr class="memdesc:a7a78e5e6659762cae118d3601d3a372d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> that will contain a result <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>.  <a href="classScopeGhidra.html#a7a78e5e6659762cae118d3601d3a372d">More...</a><br /></td></tr>
<tr class="separator:a7a78e5e6659762cae118d3601d3a372d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fb1f31ee095f0bb37b5181ab3af192"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#ac5fb1f31ee095f0bb37b5181ab3af192">addRange</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, uintb first, uintb last)</td></tr>
<tr class="memdesc:ac5fb1f31ee095f0bb37b5181ab3af192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a memory range to the ownership of <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScopeGhidra.html#ac5fb1f31ee095f0bb37b5181ab3af192">More...</a><br /></td></tr>
<tr class="separator:ac5fb1f31ee095f0bb37b5181ab3af192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a418b9b4ee25fbda17df511c61bebb8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a6a418b9b4ee25fbda17df511c61bebb8">removeRange</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, uintb first, uintb last)</td></tr>
<tr class="memdesc:a6a418b9b4ee25fbda17df511c61bebb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a memory range from the ownership of <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>.  <a href="classScopeGhidra.html#a6a418b9b4ee25fbda17df511c61bebb8">More...</a><br /></td></tr>
<tr class="separator:a6a418b9b4ee25fbda17df511c61bebb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7a72e8defe6b25f13fc4ab81781a36"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#add7a72e8defe6b25f13fc4ab81781a36">addSymbolInternal</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym)</td></tr>
<tr class="memdesc:add7a72e8defe6b25f13fc4ab81781a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> into the name map.  <a href="classScopeGhidra.html#add7a72e8defe6b25f13fc4ab81781a36">More...</a><br /></td></tr>
<tr class="separator:add7a72e8defe6b25f13fc4ab81781a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc5b238357161e4661c8616312cef12"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#addc5b238357161e4661c8616312cef12">addMapInternal</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, uint4 exfl, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 off, int4 sz, const <a class="el" href="classRangeList.html">RangeList</a> &amp;uselim)</td></tr>
<tr class="memdesc:addc5b238357161e4661c8616312cef12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> given a memory range.  <a href="classScopeGhidra.html#addc5b238357161e4661c8616312cef12">More...</a><br /></td></tr>
<tr class="separator:addc5b238357161e4661c8616312cef12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1344895b80746ac226f1b86029c17e05"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a1344895b80746ac226f1b86029c17e05">addDynamicMapInternal</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, uint4 exfl, uint8 hash, int4 off, int4 sz, const <a class="el" href="classRangeList.html">RangeList</a> &amp;uselim)</td></tr>
<tr class="memdesc:a1344895b80746ac226f1b86029c17e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> given a dynamic hash.  <a href="classScopeGhidra.html#a1344895b80746ac226f1b86029c17e05">More...</a><br /></td></tr>
<tr class="separator:a1344895b80746ac226f1b86029c17e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:adb3a80015ea458220c8c3dae82a03eee"><td class="memItemLeft" align="right" valign="top"><a id="adb3a80015ea458220c8c3dae82a03eee"></a>
<a class="el" href="classArchitectureGhidra.html">ArchitectureGhidra</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#adb3a80015ea458220c8c3dae82a03eee">ghidra</a></td></tr>
<tr class="memdesc:adb3a80015ea458220c8c3dae82a03eee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a> and connection to the Ghidra client. <br /></td></tr>
<tr class="separator:adb3a80015ea458220c8c3dae82a03eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74f35a4fc2b58a02a228de2a7bbb300"><td class="memItemLeft" align="right" valign="top"><a id="ac74f35a4fc2b58a02a228de2a7bbb300"></a>
<a class="el" href="classScopeInternal.html">ScopeInternal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#ac74f35a4fc2b58a02a228de2a7bbb300">cache</a></td></tr>
<tr class="memdesc:ac74f35a4fc2b58a02a228de2a7bbb300"><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal cache of previously fetched <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> objects. <br /></td></tr>
<tr class="separator:ac74f35a4fc2b58a02a228de2a7bbb300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711e3d852854338b53e104f0c20aeaee"><td class="memItemLeft" align="right" valign="top"><a id="a711e3d852854338b53e104f0c20aeaee"></a>
<a class="el" href="classRangeList.html">RangeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a711e3d852854338b53e104f0c20aeaee">holes</a></td></tr>
<tr class="memdesc:a711e3d852854338b53e104f0c20aeaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of (queried) memory ranges with no <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> in them. <br /></td></tr>
<tr class="separator:a711e3d852854338b53e104f0c20aeaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5afe1eb6dd8848b27bc39443bb2d5e"><td class="memItemLeft" align="right" valign="top"><a id="a6a5afe1eb6dd8848b27bc39443bb2d5e"></a>
vector&lt; int4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a6a5afe1eb6dd8848b27bc39443bb2d5e">spacerange</a></td></tr>
<tr class="memdesc:a6a5afe1eb6dd8848b27bc39443bb2d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of address spaces that are in the global range. <br /></td></tr>
<tr class="separator:a6a5afe1eb6dd8848b27bc39443bb2d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76db66d609147a5edad756cc77da3642"><td class="memItemLeft" align="right" valign="top"><a id="a76db66d609147a5edad756cc77da3642"></a>
<a class="el" href="classpartmap.html">partmap</a>&lt; <a class="el" href="classAddress.html">Address</a>, uint4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a76db66d609147a5edad756cc77da3642">flagbaseDefault</a></td></tr>
<tr class="memdesc:a76db66d609147a5edad756cc77da3642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default boolean properties on memory. <br /></td></tr>
<tr class="separator:a76db66d609147a5edad756cc77da3642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7142930885438d908d6e904645b901"><td class="memItemLeft" align="right" valign="top"><a id="a7f7142930885438d908d6e904645b901"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopeGhidra.html#a7f7142930885438d908d6e904645b901">cacheDirty</a></td></tr>
<tr class="memdesc:a7f7142930885438d908d6e904645b901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is flagbaseDefault different from cache. <br /></td></tr>
<tr class="separator:a7f7142930885438d908d6e904645b901"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classScope"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classScope')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classScope.html">Scope</a></td></tr>
<tr class="memitem:ab93f6dfecb978ac52b56f967896ca758 inherit pro_methods_classScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ab93f6dfecb978ac52b56f967896ca758">addMap</a> (const <a class="el" href="classSymbolEntry.html">SymbolEntry</a> &amp;entry)</td></tr>
<tr class="memdesc:ab93f6dfecb978ac52b56f967896ca758 inherit pro_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate a <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> into the range maps.  <a href="classScope.html#ab93f6dfecb978ac52b56f967896ca758">More...</a><br /></td></tr>
<tr class="separator:ab93f6dfecb978ac52b56f967896ca758 inherit pro_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classScope"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classScope')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classScope.html">Scope</a></td></tr>
<tr class="memitem:a598536926659c304d35346aba6d79fa2 inherit pro_static_methods_classScope"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a598536926659c304d35346aba6d79fa2">stackAddr</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint, <a class="el" href="classSymbolEntry.html">SymbolEntry</a> **addrmatch)</td></tr>
<tr class="memdesc:a598536926659c304d35346aba6d79fa2 inherit pro_static_methods_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query for Symbols starting at a given address, which match a given <b>usepoint</b>.  <a href="classScope.html#a598536926659c304d35346aba6d79fa2">More...</a><br /></td></tr>
<tr class="separator:a598536926659c304d35346aba6d79fa2 inherit pro_static_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e00dad81427a8595cf7bf13d8e1e0d inherit pro_static_methods_classScope"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a63e00dad81427a8595cf7bf13d8e1e0d">stackContainer</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint, <a class="el" href="classSymbolEntry.html">SymbolEntry</a> **addrmatch)</td></tr>
<tr class="separator:a63e00dad81427a8595cf7bf13d8e1e0d inherit pro_static_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de9b51d8c57e33e9394512489539664 inherit pro_static_methods_classScope"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a4de9b51d8c57e33e9394512489539664">stackClosestFit</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint, <a class="el" href="classSymbolEntry.html">SymbolEntry</a> **addrmatch)</td></tr>
<tr class="separator:a4de9b51d8c57e33e9394512489539664 inherit pro_static_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0d2e90ee5d4bc7e3dc761390be5e47 inherit pro_static_methods_classScope"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a1e0d2e90ee5d4bc7e3dc761390be5e47">stackFunction</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, <a class="el" href="classFuncdata.html">Funcdata</a> **addrmatch)</td></tr>
<tr class="separator:a1e0d2e90ee5d4bc7e3dc761390be5e47 inherit pro_static_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44898a2294de74a77dd21583ca6254e2 inherit pro_static_methods_classScope"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a44898a2294de74a77dd21583ca6254e2">stackExternalRef</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, <a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> **addrmatch)</td></tr>
<tr class="separator:a44898a2294de74a77dd21583ca6254e2 inherit pro_static_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26992d3bf69e5c2c02e57943b1355f0d inherit pro_static_methods_classScope"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a26992d3bf69e5c2c02e57943b1355f0d">stackCodeLabel</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, <a class="el" href="classLabSymbol.html">LabSymbol</a> **addrmatch)</td></tr>
<tr class="separator:a26992d3bf69e5c2c02e57943b1355f0d inherit pro_static_methods_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classScope"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classScope')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classScope.html">Scope</a></td></tr>
<tr class="memitem:aa5939cb5690f2f2b4f52a88ae561622d inherit pro_attribs_classScope"><td class="memItemLeft" align="right" valign="top"><a id="aa5939cb5690f2f2b4f52a88ae561622d"></a>
<a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">glb</a></td></tr>
<tr class="memdesc:aa5939cb5690f2f2b4f52a88ae561622d inherit pro_attribs_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a> of <b>this</b> scope. <br /></td></tr>
<tr class="separator:aa5939cb5690f2f2b4f52a88ae561622d inherit pro_attribs_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4900f6409e8a82c1b1cea827e4e2c5 inherit pro_attribs_classScope"><td class="memItemLeft" align="right" valign="top"><a id="abb4900f6409e8a82c1b1cea827e4e2c5"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a></td></tr>
<tr class="memdesc:abb4900f6409e8a82c1b1cea827e4e2c5 inherit pro_attribs_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of <b>this</b> scope. <br /></td></tr>
<tr class="separator:abb4900f6409e8a82c1b1cea827e4e2c5 inherit pro_attribs_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f6c31e73c46216482a6902d22b3330 inherit pro_attribs_classScope"><td class="memItemLeft" align="right" valign="top"><a id="a72f6c31e73c46216482a6902d22b3330"></a>
<a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a72f6c31e73c46216482a6902d22b3330">fd</a></td></tr>
<tr class="memdesc:a72f6c31e73c46216482a6902d22b3330 inherit pro_attribs_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">(If non-null) the function which <b>this</b> is the local <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> for <br /></td></tr>
<tr class="separator:a72f6c31e73c46216482a6902d22b3330 inherit pro_attribs_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67040159cc1bea1399308eda8aa0f22 inherit pro_attribs_classScope"><td class="memItemLeft" align="right" valign="top"><a id="ad67040159cc1bea1399308eda8aa0f22"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ad67040159cc1bea1399308eda8aa0f22">uniqueId</a></td></tr>
<tr class="memdesc:ad67040159cc1bea1399308eda8aa0f22 inherit pro_attribs_classScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique id for the scope, for deduping scope names, assigning symbol ids. <br /></td></tr>
<tr class="separator:ad67040159cc1bea1399308eda8aa0f22 inherit pro_attribs_classScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An implementation of the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> interface by querying a Ghidra client for <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> information. </p>
<p>This object is generally instantiated once for an executable and acts as the <em>global</em> <em>scope</em> for the decompiler. Queries for symbol information are forwarded to the Ghidra client and the response is cached. This object fields queries for all scopes above functions. Responses may be for <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> objects that are not global but belong to sub-scopes, like <em>namespace</em> and function Scopes. This object will build any new <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> or <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function.">Funcdata</a>, object as necessary and stick the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> in, returning as if the new <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> had caught the query in the first place. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a715046c5b708da35b3547780a3226713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715046c5b708da35b3547780a3226713">&#9670;&nbsp;</a></span>ScopeGhidra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScopeGhidra::ScopeGhidra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArchitectureGhidra.html">ArchitectureGhidra</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>is the <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems.">Architecture</a> and connection to the Ghidra client </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classScopeGhidra.html#ac74f35a4fc2b58a02a228de2a7bbb300">cache</a>, <a class="el" href="classScopeGhidra.html#a7f7142930885438d908d6e904645b901">cacheDirty</a>, and <a class="el" href="classScopeGhidra.html#adb3a80015ea458220c8c3dae82a03eee">ghidra</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1344895b80746ac226f1b86029c17e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1344895b80746ac226f1b86029c17e05">&#9670;&nbsp;</a></span>addDynamicMapInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a>* ScopeGhidra::addDynamicMapInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>exfl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRangeList.html">RangeList</a> &amp;&#160;</td>
          <td class="paramname"><em>uselim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> given a dynamic hash. </p>
<p>The <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> is specified in terms of a <b>hash</b> and <b>usepoint</b>, which describe how to find the temporary <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> holding the symbol value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> being mapped </td></tr>
    <tr><td class="paramname">exfl</td><td>are any boolean <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> properties </td></tr>
    <tr><td class="paramname">hash</td><td>is the given dynamic hash </td></tr>
    <tr><td class="paramname">off</td><td>is the byte offset of the new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> (relative to the whole <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>) </td></tr>
    <tr><td class="paramname">sz</td><td>is the number of bytes occupied by the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> </td></tr>
    <tr><td class="paramname">uselim</td><td>is the given <b>usepoint</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> </dd></dl>

<p>Implements <a class="el" href="classScope.html#a5d3b5f792b07b023d43309472cd6f4d9">Scope</a>.</p>

</div>
</div>
<a id="addc5b238357161e4661c8616312cef12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc5b238357161e4661c8616312cef12">&#9670;&nbsp;</a></span>addMapInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a>* ScopeGhidra::addMapInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>exfl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRangeList.html">RangeList</a> &amp;&#160;</td>
          <td class="paramname"><em>uselim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> given a memory range. </p>
<p>The <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> is specified in terms of a memory range and <b>usepoint</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> being mapped </td></tr>
    <tr><td class="paramname">exfl</td><td>are any boolean <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> properties specific to the memory range </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the given memory range </td></tr>
    <tr><td class="paramname">off</td><td>is the byte offset of the new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> (relative to the whole <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>) </td></tr>
    <tr><td class="paramname">sz</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">uselim</td><td>is the given <b>usepoint</b> (which may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> </dd></dl>

<p>Implements <a class="el" href="classScope.html#aec0451f131ea214a174e00a434be36e9">Scope</a>.</p>

</div>
</div>
<a id="ac5fb1f31ee095f0bb37b5181ab3af192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fb1f31ee095f0bb37b5181ab3af192">&#9670;&nbsp;</a></span>addRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ScopeGhidra::addRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a memory range to the ownership of <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the address space of the range </td></tr>
    <tr><td class="paramname">first</td><td>is the offset of the first byte in the range </td></tr>
    <tr><td class="paramname">last</td><td>is the offset of the last byte in the range </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classScope.html#a33adf8d24b5e22aa420b840b817131e0">Scope</a>.</p>

<p class="reference">References <a class="el" href="classScope.html#a33adf8d24b5e22aa420b840b817131e0">Scope::addRange()</a>, <a class="el" href="classAddrSpace.html#abac46fe0121579ac29f2e8e93753183d">AddrSpace::getIndex()</a>, and <a class="el" href="classScopeGhidra.html#a6a5afe1eb6dd8848b27bc39443bb2d5e">spacerange</a>.</p>

</div>
</div>
<a id="abb80f5f1b2391d5865f3c75ec1e03644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb80f5f1b2391d5865f3c75ec1e03644">&#9670;&nbsp;</a></span>addSymbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> * ScopeGhidra::addSymbol </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> to <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>, given a name, data-type, and a single mapping. </p>
<p>The <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> object will be created with the given name and data-type. A single mapping (<a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a>) will be created for the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> based on a given storage address for the symbol and an address for code that accesses the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> at that storage location. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the new name of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
    <tr><td class="paramname">ct</td><td>is the data-type of the new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> storage </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point accessing that storage (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> matching the new mapping </dd></dl>

<p>Reimplemented from <a class="el" href="classScope.html#a7c79f7f535ba4e819fcf95185896a019">Scope</a>.</p>

<p class="reference">References <a class="el" href="classScope.html#a7c79f7f535ba4e819fcf95185896a019">Scope::addSymbol()</a>, <a class="el" href="classScopeGhidra.html#ac74f35a4fc2b58a02a228de2a7bbb300">cache</a>, and <a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">Scope::name</a>.</p>

</div>
</div>
<a id="add7a72e8defe6b25f13fc4ab81781a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7a72e8defe6b25f13fc4ab81781a36">&#9670;&nbsp;</a></span>addSymbolInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ScopeGhidra::addSymbolInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> into the name map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the preconstructed <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classScope.html#a66d3198f4bd28cf9e8a2a6bc00d065d8">Scope</a>.</p>

</div>
</div>
<a id="a25f55a3495b08a4caafaaeb5c1cf8bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f55a3495b08a4caafaaeb5c1cf8bed">&#9670;&nbsp;</a></span>buildUndefinedName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string ScopeGhidra::buildUndefinedName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a formal <b>undefined</b> name, used internally when a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is not given a name. </p>
<dl class="section return"><dt>Returns</dt><dd>a special internal name that won't collide with other names in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> </dd></dl>

<p>Implements <a class="el" href="classScope.html#ac47d5c1c949be84a27a138be0febacb2">Scope</a>.</p>

<p class="reference">References <a class="el" href="classScopeInternal.html#a17225ae39210e0dbf1efb1a3ee847d72">ScopeInternal::buildUndefinedName()</a>, and <a class="el" href="classScopeGhidra.html#ac74f35a4fc2b58a02a228de2a7bbb300">cache</a>.</p>

</div>
</div>
<a id="a4a8ab1c82c0d5101e7e2f5cdd5cc8268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8ab1c82c0d5101e7e2f5cdd5cc8268">&#9670;&nbsp;</a></span>buildVariableName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string ScopeGhidra::buildVariableName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4 &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an address and data-type, build a suitable generic symbol name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
    <tr><td class="paramname">pc</td><td>is the address at which the name is getting used </td></tr>
    <tr><td class="paramname">ct</td><td>is a data-type used to inform the name </td></tr>
    <tr><td class="paramname">index</td><td>is a reference to an index used to make the name unique, which will be updated </td></tr>
    <tr><td class="paramname">flags</td><td>are boolean properties of the variable we need the name for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new variable name </dd></dl>

<p>Implements <a class="el" href="classScope.html#a925baecb33b6f0d9212e42c1b48a64ba">Scope</a>.</p>

<p class="reference">References <a class="el" href="classScopeInternal.html#a6009aeaf0d3973344438fb412adccd00">ScopeInternal::buildVariableName()</a>, and <a class="el" href="classScopeGhidra.html#ac74f35a4fc2b58a02a228de2a7bbb300">cache</a>.</p>

</div>
</div>
<a id="a68a3cdb0e8edd44d9ae61b0295a942dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a3cdb0e8edd44d9ae61b0295a942dc">&#9670;&nbsp;</a></span>createNewScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classScope.html">Scope</a> * ScopeGhidra::createNewScope </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a global <em>namespace</em> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<p>Ghidra may report that a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is in a <em>namespace</em>. This method creates a dedicated <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> object to hold such a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>. The immediate parent for the new <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> must already exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the name of the new <em>namespace</em> </td></tr>
    <tr><td class="paramname">par</td><td>is the parent <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <em>namespace</em> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> </dd></dl>

<p class="reference">References <a class="el" href="classDatabase.html#a1bc096166a8cfde3d77229c9e38bfabf">Database::attachScope()</a>, <a class="el" href="classScopeGhidra.html#adb3a80015ea458220c8c3dae82a03eee">ghidra</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">Architecture::symboltab</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeGhidra.html#a7a78e5e6659762cae118d3601d3a372d">reresolveScope()</a>.</p>

</div>
</div>
<a id="a3f1694263c1bbb543c387b4c182872b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1694263c1bbb543c387b4c182872b0">&#9670;&nbsp;</a></span>dump2Cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * ScopeGhidra::dump2Cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDocument.html">Document</a> *&#160;</td>
          <td class="paramname"><em>doc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a response into the cache. </p>
<p>Build the global object described by the XML document and put it in the cache. The XML can either be a &lt;hole&gt; tag, describing the absence of symbols at the queried address, or one of the symbol tags </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doc</td><td>is the XML document </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly constructed <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> or NULL if there was a hole </dd></dl>

<p class="reference">References <a class="el" href="classScope.html#a421f1b66be24bd5a20c77761e7a51268">Scope::addMapSym()</a>, <a class="el" href="classScopeGhidra.html#ac74f35a4fc2b58a02a228de2a7bbb300">cache</a>, <a class="el" href="classScopeGhidra.html#a7f7142930885438d908d6e904645b901">cacheDirty</a>, <a class="el" href="structLowlevelError.html#afa821264468ba7772c966aab644796c4">LowlevelError::explain</a>, <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>, <a class="el" href="classSymbol.html#a9176f3c0f44f3373ef092043486a147b">Symbol::getFirstWholeMap()</a>, <a class="el" href="classFunctionSymbol.html#ab54ed780e0dd1abdc9447c2e772114fb">FunctionSymbol::getFunction()</a>, <a class="el" href="classScopeGhidra.html#adb3a80015ea458220c8c3dae82a03eee">ghidra</a>, <a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">Scope::glb</a>, <a class="el" href="classScopeGhidra.html#a711e3d852854338b53e104f0c20aeaee">holes</a>, <a class="el" href="classRangeList.html#ab0ab4e29f9f3b6b096e985d99daac763">RangeList::insertRange()</a>, <a class="el" href="classScopeGhidra.html#a91c4a843ad067fe2ec612a37d2b76d49">processHole()</a>, <a class="el" href="classScope.html#ae7d2e4eeed5fbc77e0477936f60cfde5">Scope::queryByName()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca0d7f659884b50f2fa71a3d700a729258">Varnode::readonly</a>, <a class="el" href="classScopeGhidra.html#a7a78e5e6659762cae118d3601d3a372d">reresolveScope()</a>, <a class="el" href="classAddress.html#a31fdc8c33088abb3040027d35e7c4026">Address::restoreXml()</a>, <a class="el" href="classDatabase.html#aca0311269bfa73f5673c998dec92bb95">Database::setPropertyRange()</a>, <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">Architecture::symboltab</a>, and <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cafd8f85c37b5ee3374d865cafbaf6f7e5">Varnode::volatil</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeGhidra.html#a4b2def877a64531dcebbf852328053c9">removeQuery()</a>, and <a class="el" href="classScopeGhidra.html#afdb2e6de63033bb78e6c4168c8e25227">resolveExternalRefFunction()</a>.</p>

</div>
</div>
<a id="a444989f8c48787af5df27c2a8b234fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444989f8c48787af5df27c2a8b234fd3">&#9670;&nbsp;</a></span>findAddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> * ScopeGhidra::findAddr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> at a given address and <b>usepoint</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point at which the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is accessed (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> or NULL </dd></dl>

<p>Implements <a class="el" href="classScope.html#aae4ea61f9a55ddfc9defd8548654c8e5">Scope</a>.</p>

<p class="reference">References <a class="el" href="classScopeGhidra.html#ac74f35a4fc2b58a02a228de2a7bbb300">cache</a>, <a class="el" href="classScopeInternal.html#ac256d087718065edb1c3a96fbfdf7a33">ScopeInternal::findAddr()</a>, <a class="el" href="classScopeInternal.html#ae1eedf2f27fd8b0a7431568c4e4e2994">ScopeInternal::findContainer()</a>, <a class="el" href="classSymbol.html#a0f86b85ac74fc36f1df80b48b658af1c">Symbol::getMapEntry()</a>, and <a class="el" href="classScopeGhidra.html#a4b2def877a64531dcebbf852328053c9">removeQuery()</a>.</p>

</div>
</div>
<a id="a26072ceb4215a022050d12b9487e3e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26072ceb4215a022050d12b9487e3e87">&#9670;&nbsp;</a></span>findByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ScopeGhidra::findByName </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> by name within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<p>If there are multiple Symbols with the same name, all are passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the name to search for </td></tr>
    <tr><td class="paramname">res</td><td>will contain any matching Symbols </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classScope.html#a979222d28577e6e8d07e35f12d38bff7">Scope</a>.</p>

</div>
</div>
<a id="ace9d46c27a627260abfe9cce2724267b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9d46c27a627260abfe9cce2724267b">&#9670;&nbsp;</a></span>findClosestFit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a>* ScopeGhidra::findClosestFit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> which is the closest fit to the given memory range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given memory range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point at which the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is accessed (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> or NULL </dd></dl>

<p>Implements <a class="el" href="classScope.html#ab679fe786be2fb949af78054cb2041a8">Scope</a>.</p>

</div>
</div>
<a id="a81328af0bc4954612d1e107e592a246a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81328af0bc4954612d1e107e592a246a">&#9670;&nbsp;</a></span>findCodeLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLabSymbol.html">LabSymbol</a> * ScopeGhidra::findCodeLabel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a label <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> at the given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classLabSymbol.html" title="A Symbol that labels code internal to a function.">LabSymbol</a> or NULL </dd></dl>

<p>Implements <a class="el" href="classScope.html#af4bac52b9d64974b87432c0379cc38c6">Scope</a>.</p>

<p class="reference">References <a class="el" href="classScope.html#a4dcaf595e4437d91af6a243ef0d49640">Scope::addCodeLabel()</a>, <a class="el" href="classScopeGhidra.html#ac74f35a4fc2b58a02a228de2a7bbb300">cache</a>, <a class="el" href="classScopeInternal.html#ac256d087718065edb1c3a96fbfdf7a33">ScopeInternal::findAddr()</a>, <a class="el" href="classScopeInternal.html#a602029280a3bc0dac8aac016ec934d5b">ScopeInternal::findCodeLabel()</a>, <a class="el" href="classArchitectureGhidra.html#ad66f093e36881a04b3dd40971373ce9e">ArchitectureGhidra::getCodeLabel()</a>, and <a class="el" href="classScopeGhidra.html#adb3a80015ea458220c8c3dae82a03eee">ghidra</a>.</p>

</div>
</div>
<a id="a6b5b1b303d3d6adf93822224aa7bd19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5b1b303d3d6adf93822224aa7bd19f">&#9670;&nbsp;</a></span>findContainer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> * ScopeGhidra::findContainer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the smallest <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> containing the given memory range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given memory range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point at which the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is accessed (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> or NULL </dd></dl>

<p>Implements <a class="el" href="classScope.html#a609fc1ef47d047717da65827e025cfdd">Scope</a>.</p>

<p class="reference">References <a class="el" href="classScopeGhidra.html#ac74f35a4fc2b58a02a228de2a7bbb300">cache</a>, <a class="el" href="classScopeInternal.html#a27135ecccccc6784b292a354d6801289">ScopeInternal::findClosestFit()</a>, <a class="el" href="classSymbol.html#a0f86b85ac74fc36f1df80b48b658af1c">Symbol::getMapEntry()</a>, <a class="el" href="classAddress.html#a208ce07ecf27e5c148d8395913831c2a">Address::getOffset()</a>, and <a class="el" href="classScopeGhidra.html#a4b2def877a64531dcebbf852328053c9">removeQuery()</a>.</p>

</div>
</div>
<a id="a0de8e7d9e97f48516f8bb7b5edd4dfcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de8e7d9e97f48516f8bb7b5edd4dfcd">&#9670;&nbsp;</a></span>findExternalRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> * ScopeGhidra::findExternalRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an <em>external</em> <em>reference</em> at the given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classExternRefSymbol.html" title="A function Symbol referring to an external location.">ExternRefSymbol</a> or NULL </dd></dl>

<p>Implements <a class="el" href="classScope.html#af69e0f77b621a3ba6436f8a1c0010d1c">Scope</a>.</p>

<p class="reference">References <a class="el" href="classScopeGhidra.html#ac74f35a4fc2b58a02a228de2a7bbb300">cache</a>, <a class="el" href="classScopeInternal.html#ae1eedf2f27fd8b0a7431568c4e4e2994">ScopeInternal::findContainer()</a>, <a class="el" href="classScopeInternal.html#a7e440965cfb5642bcc751a622e5ec58d">ScopeInternal::findExternalRef()</a>, and <a class="el" href="classScopeGhidra.html#a4b2def877a64531dcebbf852328053c9">removeQuery()</a>.</p>

</div>
</div>
<a id="a8bc17a80d5b2bd69f7900be5b55a382a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc17a80d5b2bd69f7900be5b55a382a">&#9670;&nbsp;</a></span>findFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFuncdata.html">Funcdata</a> * ScopeGhidra::findFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the function starting at the given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given starting address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function.">Funcdata</a> object or NULL </dd></dl>

<p>Implements <a class="el" href="classScope.html#a2c621196f6fdb4b8ce4ee1f3dc953107">Scope</a>.</p>

<p class="reference">References <a class="el" href="classScopeGhidra.html#ac74f35a4fc2b58a02a228de2a7bbb300">cache</a>, <a class="el" href="classScope.html#a72f6c31e73c46216482a6902d22b3330">Scope::fd</a>, <a class="el" href="classScopeInternal.html#ae1eedf2f27fd8b0a7431568c4e4e2994">ScopeInternal::findContainer()</a>, <a class="el" href="classScopeInternal.html#a03a52c629c51ad660eec8d10cf7f92aa">ScopeInternal::findFunction()</a>, <a class="el" href="classFunctionSymbol.html#ab54ed780e0dd1abdc9447c2e772114fb">FunctionSymbol::getFunction()</a>, and <a class="el" href="classScopeGhidra.html#a4b2def877a64531dcebbf852328053c9">removeQuery()</a>.</p>

</div>
</div>
<a id="afb59d45c8fa404fe023e054b255d5a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb59d45c8fa404fe023e054b255d5a3d">&#9670;&nbsp;</a></span>findOverlap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a>* ScopeGhidra::findOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find first <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> overlapping the given memory range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an overlapping <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a> or NULL if none exists </dd></dl>

<p>Implements <a class="el" href="classScope.html#a3395b6194a59515caa1ede92fd6ac511">Scope</a>.</p>

</div>
</div>
<a id="a4c6c26ca7dd639659313e8fe86d798c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6c26ca7dd639659313e8fe86d798c8">&#9670;&nbsp;</a></span>getCategorySize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int4 ScopeGhidra::getCategorySize </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>cat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of Symbols in the given category. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cat</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> <em>category</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number in that <em>category</em> </dd></dl>

<p>Implements <a class="el" href="classScope.html#a909e15a7a96c9b402855b56b6bfdbd9f">Scope</a>.</p>

</div>
</div>
<a id="aa3b3e331ed319e74af4a5927f7e70660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b3e331ed319e74af4a5927f7e70660">&#9670;&nbsp;</a></span>getCategorySymbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbol.html">Symbol</a>* ScopeGhidra::getCategorySymbol </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>cat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> by index within a specific <em>category</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cat</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> <em>category</em> </td></tr>
    <tr><td class="paramname">ind</td><td>is the index (within the category) of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the indicated <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> or NULL if no <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> with that index exists </dd></dl>

<p>Implements <a class="el" href="classScope.html#a491a168d7ea71f00da419dd864901ccb">Scope</a>.</p>

</div>
</div>
<a id="a0f59b75cfddbd3537c4e2087ce0f22aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f59b75cfddbd3537c4e2087ce0f22aa">&#9670;&nbsp;</a></span>isNameUsed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ScopeGhidra::isNameUsed </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given name is used within <b>this</b> scope. </p>
<p>Only <b>this</b> scope is checked. If one or more symbols exist with the given name, <b>true</b> is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the given name to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the name is used within <b>this</b> scope </dd></dl>

<p>Implements <a class="el" href="classScope.html#a9eeda63eacff8611321ba44508ccef3e">Scope</a>.</p>

</div>
</div>
<a id="a912898628da7cab6ec50207b9d9bd418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912898628da7cab6ec50207b9d9bd418">&#9670;&nbsp;</a></span>lockDefaultProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ScopeGhidra::lockDefaultProperties </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock in the default state of the boolean property map. </p>
<p>When <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> gets created, parsing of .pspec and .cspec files may lay down property information about memory before any the load-image is consulted. This method locks creates a copy of this state of memory, so the decompiler can reset to it before decompiling a new function. </p>

<p class="reference">References <a class="el" href="classScopeGhidra.html#a7f7142930885438d908d6e904645b901">cacheDirty</a>, <a class="el" href="classScopeGhidra.html#a76db66d609147a5edad756cc77da3642">flagbaseDefault</a>, <a class="el" href="classScopeGhidra.html#adb3a80015ea458220c8c3dae82a03eee">ghidra</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">Architecture::symboltab</a>.</p>

<p class="reference">Referenced by <a class="el" href="classArchitectureGhidra.html#a9be8696499656bb4127cb5bddc7ccf77">ArchitectureGhidra::postSpecFile()</a>.</p>

</div>
</div>
<a id="a458977d1e0a9826d5cf7bca487ecf327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458977d1e0a9826d5cf7bca487ecf327">&#9670;&nbsp;</a></span>makeNameUnique()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string ScopeGhidra::makeNameUnique </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce a version of the given symbol name that won't collide with other names in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the given name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return a unique version of the name </dd></dl>

<p>Implements <a class="el" href="classScope.html#a2e0d945c44f4874743496b2814fbb631">Scope</a>.</p>

</div>
</div>
<a id="a91c4a843ad067fe2ec612a37d2b76d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c4a843ad067fe2ec612a37d2b76d49">&#9670;&nbsp;</a></span>processHole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ScopeGhidra::processHole </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process a response describing a hole. </p>
<p>The Ghidra client can respond to a query negatively by sending a &lt;hole&gt; tag, which describes the (largest) range of addresses containing the query address that do not have any <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> mapped to them. This object stores this information in the <b>holes</b> map, which it consults to avoid sending queries for the same unmapped address repeatedly. The tag may also contain boolean property information about the memory range, which also gets stored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the &lt;hole&gt; element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classScopeGhidra.html#a7f7142930885438d908d6e904645b901">cacheDirty</a>, <a class="el" href="classElement.html#aa7c399eff3cfca934ee7fb9cc559d039">Element::getAttributeValue()</a>, <a class="el" href="classScopeGhidra.html#adb3a80015ea458220c8c3dae82a03eee">ghidra</a>, <a class="el" href="classScopeGhidra.html#a711e3d852854338b53e104f0c20aeaee">holes</a>, <a class="el" href="classRangeList.html#ab0ab4e29f9f3b6b096e985d99daac763">RangeList::insertRange()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca0d7f659884b50f2fa71a3d700a729258">Varnode::readonly</a>, <a class="el" href="classRange.html#ad88a42471281f5bc6abf1dc1fb79f12b">Range::restoreXml()</a>, <a class="el" href="classDatabase.html#aca0311269bfa73f5673c998dec92bb95">Database::setPropertyRange()</a>, <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">Architecture::symboltab</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cafd8f85c37b5ee3374d865cafbaf6f7e5">Varnode::volatil</a>, and <a class="el" href="xml_8hh.html#ac2d01d7c2986f1143b2f6145311d093e">xml_readbool()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeGhidra.html#a3f1694263c1bbb543c387b4c182872b0">dump2Cache()</a>.</p>

</div>
</div>
<a id="a4b2def877a64531dcebbf852328053c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2def877a64531dcebbf852328053c9">&#9670;&nbsp;</a></span>removeQuery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * ScopeGhidra::removeQuery </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process a query that missed the cache. </p>
<p>Determine if the given address should be sent to the Ghidra client at all, by checking the hole map and other factors. If it passes, send the query to the client, process the result, and update the cache. If a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> is ultimately recovered, return it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the address to potentially query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> or NULL if there is hole </dd></dl>

<p class="reference">References <a class="el" href="classScopeGhidra.html#a3f1694263c1bbb543c387b4c182872b0">dump2Cache()</a>, <a class="el" href="classAddrSpace.html#abac46fe0121579ac29f2e8e93753183d">AddrSpace::getIndex()</a>, <a class="el" href="classArchitectureGhidra.html#a03d6804fba40e0c09e6be5e3ad5f8723">ArchitectureGhidra::getMappedSymbolsXML()</a>, <a class="el" href="classAddress.html#a2e1cbf153126eebf5ba92f52c5dbc6a8">Address::getSpace()</a>, <a class="el" href="classScopeGhidra.html#adb3a80015ea458220c8c3dae82a03eee">ghidra</a>, <a class="el" href="classScopeGhidra.html#a711e3d852854338b53e104f0c20aeaee">holes</a>, <a class="el" href="classRangeList.html#a61b4034c6930b45dd8d365c382c73b86">RangeList::inRange()</a>, and <a class="el" href="classScopeGhidra.html#a6a5afe1eb6dd8848b27bc39443bb2d5e">spacerange</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeGhidra.html#a444989f8c48787af5df27c2a8b234fd3">findAddr()</a>, <a class="el" href="classScopeGhidra.html#a6b5b1b303d3d6adf93822224aa7bd19f">findContainer()</a>, <a class="el" href="classScopeGhidra.html#a0de8e7d9e97f48516f8bb7b5edd4dfcd">findExternalRef()</a>, and <a class="el" href="classScopeGhidra.html#a8bc17a80d5b2bd69f7900be5b55a382a">findFunction()</a>.</p>

</div>
</div>
<a id="a6a418b9b4ee25fbda17df511c61bebb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a418b9b4ee25fbda17df511c61bebb8">&#9670;&nbsp;</a></span>removeRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ScopeGhidra::removeRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a memory range from the ownership of <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the address space of the range </td></tr>
    <tr><td class="paramname">first</td><td>is the offset of the first byte in the range </td></tr>
    <tr><td class="paramname">last</td><td>is the offset of the last byte in the range </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classScope.html#ad1b4a9faa5d12ef3b0be55810dac6d35">Scope</a>.</p>

</div>
</div>
<a id="a7a78e5e6659762cae118d3601d3a372d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a78e5e6659762cae118d3601d3a372d">&#9670;&nbsp;</a></span>reresolveScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classScope.html">Scope</a> * ScopeGhidra::reresolveScope </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> that will contain a result <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>. </p>
<p>The Ghidra client reports a <em>namespace</em> path associated with <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>. Determine if this <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> already exists in the cache and built it if it isn't. This may mean creating a new <em>namespace</em> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>is absolute path to the desired <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a> matching the path. </dd></dl>

<p class="reference">References <a class="el" href="classScopeGhidra.html#ac74f35a4fc2b58a02a228de2a7bbb300">cache</a>, <a class="el" href="classScopeGhidra.html#a68a3cdb0e8edd44d9ae61b0295a942dc">createNewScope()</a>, <a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">Scope::glb</a>, <a class="el" href="classScope.html#a3b252ca0ce3155c06fe0cee6eae9265b">Scope::resolveScope()</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">Architecture::symboltab</a>.</p>

<p class="reference">Referenced by <a class="el" href="classScopeGhidra.html#a3f1694263c1bbb543c387b4c182872b0">dump2Cache()</a>.</p>

</div>
</div>
<a id="afdb2e6de63033bb78e6c4168c8e25227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb2e6de63033bb78e6c4168c8e25227">&#9670;&nbsp;</a></span>resolveExternalRefFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFuncdata.html">Funcdata</a> * ScopeGhidra::resolveExternalRefFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an <em>external</em> <em>reference</em> to the referenced function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> marking the external reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the underlying <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function.">Funcdata</a> object or NULL if none exists </dd></dl>

<p>Implements <a class="el" href="classScope.html#af4c45025894f1996ef0f3556752cd997">Scope</a>.</p>

<p class="reference">References <a class="el" href="classScopeGhidra.html#ac74f35a4fc2b58a02a228de2a7bbb300">cache</a>, <a class="el" href="classScopeGhidra.html#a3f1694263c1bbb543c387b4c182872b0">dump2Cache()</a>, <a class="el" href="classScope.html#a72f6c31e73c46216482a6902d22b3330">Scope::fd</a>, <a class="el" href="classScopeInternal.html#a03a52c629c51ad660eec8d10cf7f92aa">ScopeInternal::findFunction()</a>, <a class="el" href="classArchitectureGhidra.html#ab3f7d8642e6d84aa7ee3806620ef34ff">ArchitectureGhidra::getExternalRefXML()</a>, <a class="el" href="classSymbol.html#a9176f3c0f44f3373ef092043486a147b">Symbol::getFirstWholeMap()</a>, <a class="el" href="classFunctionSymbol.html#ab54ed780e0dd1abdc9447c2e772114fb">FunctionSymbol::getFunction()</a>, <a class="el" href="classScopeGhidra.html#adb3a80015ea458220c8c3dae82a03eee">ghidra</a>, <a class="el" href="classDatabase.html#ab3840564f424238dd3a498fdb1a02644">Database::mapScope()</a>, <a class="el" href="classScope.html#a1e0d2e90ee5d4bc7e3dc761390be5e47">Scope::stackFunction()</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">Architecture::symboltab</a>.</p>

</div>
</div>
<a id="a0de93cdd506ae1490d939b957738f656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de93cdd506ae1490d939b957738f656">&#9670;&nbsp;</a></span>restrictScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ScopeGhidra::restrictScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <b>this</b> to a local <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<p>Attach <b>this</b> to the given function, which makes <b>this</b> the local scope for the function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>is the given function to attach to </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classScope.html#a21556c257fbea888f9004c654599dfe9">Scope</a>.</p>

</div>
</div>
<a id="a086054a08a1916c410fa10b3e8afca76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086054a08a1916c410fa10b3e8afca76">&#9670;&nbsp;</a></span>retypeSymbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ScopeGhidra::retypeSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the data-type of a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope.">Scope</a>. </p>
<p>If the size of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> changes, any mapping (<a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol.">SymbolEntry</a>) is adjusted </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
    <tr><td class="paramname">ct</td><td>is the new data-type </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classScope.html#afeef6a133b07fa176c08b67c44064e69">Scope</a>.</p>

</div>
</div>
<a id="aafecf1b8615812bdbd8efeca910594a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafecf1b8615812bdbd8efeca910594a2">&#9670;&nbsp;</a></span>setCategory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ScopeGhidra::setCategory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>cat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the <em>category</em> and index for the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
    <tr><td class="paramname">cat</td><td>is the <em>category</em> to set for the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope.">Symbol</a> </td></tr>
    <tr><td class="paramname">ind</td><td>is the index position to set (within the category) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classScope.html#ac807e11df36854d2f7983bdd6779e83a">Scope</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="database__ghidra_8hh.html">database_ghidra.hh</a></li>
<li>database_ghidra.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
